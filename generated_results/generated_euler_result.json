{
    "CodeLlama-13b-hf": {
        "go": {
            "cpp": [
                "int multiplesOf3And5(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int evenFibonacciNumbers(int n) {\n    int result = 0;\n    int a = 1;\n    int b = 2;\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a;\n        }\n        int tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "int largestPrimeFactor(int n) {\n    int result = n;\n    int i = 2;\n    while (i * i <= result) {\n        if (result % i != 0) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint largestPalindromeProduct(int n) {\n    int result = 0;\n    for (int i = 100; i < 1000; i++) {\n        for (int j = i; j < 1000; j++) {\n            int prod = i * j;\n            if (isPalindrome(to_string(prod)) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "int smallestMultiple(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        if (result % i != 0) {\n            for (int j = 1; j <= n; j++) {\n                if ((result * j) % i == 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int sumSquareDifference(int n) {\n    int sqrSum = 0;\n    int numSum = 0;\n    for (int i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "int nthPrime(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (primes.size() < n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.size() - 1];\n}",
                "int largestProductInASeries(const string& s, int k) {\n    int result = 0;\n    for (int i = 0; i < s.size() - k; i++) {\n        int product = 1;\n        for (int j = 0; j < k; j++) {\n            product *= s[i + j] - '0';\n        }\n        result = max(result, product);\n    }\n    return result;\n}",
                "int specialPythagoreanTriplet(int n) {\n    for (int a = 1; a < n; a++) {\n        for (int b = a; b < n; b++) {\n            int c = n - a - b;\n            if (a * a + b * b == c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "int summationOfPrimes(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (i <= n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    int result = 0;\n    for (int prime : primes) {\n        result += prime;\n    }\n    return result;\n}",
                "int largestProductInAGrid(const vector<vector<int>>& grid) {\n    int result = 0;\n    for (int i = 0; i < grid.size() - 3; i++) {\n        for (int j = 0; j < grid[i].size() - 3; j++) {\n            int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (int k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (int k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "int highlyDivisibleTriangularNumber(int n) {\n    for (int i = 1; i < 100000000; i++) {\n        int result = i * (i + 1) / 2;\n        int count = 0;\n        for (int j = 1; j <= sqrt(result); j++) {\n            if (result % j == 0) {\n                count += 2;\n            }\n            if (j * j == result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "string largeSum(const vector<string>& numbers) {\n    vector<int> digits(60);\n    for (int i = 0; i < 50; i++) {\n        int tmp = 0;\n        for (const string& num : numbers) {\n            tmp += num[49 - i] - '0';\n        }\n        for (int j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if (tmp == 0) {\n                break;\n            }\n        }\n    }\n    for (int i = 59; i >= 0; i--) {\n        if (digits[i] != 0) {\n            string result;\n            for (int j = i; j > i - 10; j--) {\n                result += to_string(digits[j]);\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
                "int longestCollatzSequence(int n) {\n    int longest = 0;\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        int chain = 1;\n        int num = i;\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num /= 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "int latticePaths(int m, int n) {\n    vector<vector<int>> grid(m + 1, vector<int>(n + 1, 0));\n    for (int i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (int j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "int powerDigitSum(int n) {\n    vector<int> digits = {2};\n    for (int i = 1; i < n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            int temp = digits[j]*2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry != 0) {\n            digits.push_back(carry);\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "string numberToWords(int n) {\n    vector<string> ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    vector<string> teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n    vector<string> tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        string suf = \"\";\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "int maximumPathSumI(const vector<vector<int>>& triangle) {\n    vector<int> curr(triangle[triangle.size() - 1]);\n    for (int i = triangle.size() - 2; i >= 0; i--) {\n        vector<int> next(triangle[i]);\n        for (int j = 0; j < next.size(); j++) {\n            next[j] += max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "int countingSundays(int y1, int y2) {\n    int day = 0;\n    int count = 0;\n    for (int year = 1900; year <= y2; year++) {\n        for (int month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 == 6) {\n                count++;\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30;\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "int factorialDigitSum(int n) {\n    vector<int> digits = {1};\n    for (int i = 1; i <= n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while (carry != 0) {\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "int d(int n) {\n    int result = 1;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            result += i;\n            if (i != n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nint amicableNumbers(int n) {\n    int result = 0;\n    for (int a = 2; a < n; a++) {\n        int b = d(a);\n        if (a != b && a == d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "int namesScores(const vector<string>& names, const vector<string>& queries) {\n    vector<string> sNames = names;\n    sort(sNames.begin(), sNames.end());\n    int result = 0;\n    for (int i = 0; i < sNames.size(); i++) {\n        int x = 0;\n        for (char c : sNames[i]) {\n            x += c - 64;\n        }\n        for (const string& query : queries) {\n            if (query == sNames[i]) {\n                result += x * (i + 1);\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "bool isAbundant(int n) {\n    if (n < 12) {\n        return false;\n    }\n    int sumDivisors = 1;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            sumDivisors += i;\n            if (i != n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nint nonAbundantSums(int n) {\n    vector<int> abundants;\n    for (int i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push_back(i);\n        }\n    }\n    unordered_set<int> abundantSums;\n    for (int i : abundants) {\n        for (int j : abundants) {\n            abundantSums.insert(i + j);\n        }\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (!abundantSums.count(i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "string lexicographicPermutations(int n) {\n    string result;\n    vector<int> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = n - 1;\n    for (int i = 10; i > 0; i--) {\n        int fact = 1;\n        for (int j = 1; j < i; j++) {\n            fact *= j;\n        }\n        int idx = x / fact;\n        result += to_string(digits[idx]);\n        digits.erase(digits.begin() + idx);\n        x -= idx * fact;\n    }\n    return result;\n}",
                "int nDigitFibonacciNumber(int n) {\n    vector<int> a = {1};\n    vector<int> b = {1};\n    int i = 2;\n    while (b.size() < n) {\n        int carry = 0;\n        vector<int> c(b);\n        for (int j = 0; j < b.size(); j++) {\n            if (j < a.size()) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry != 0) {\n            b.push_back(carry);\n        }\n        a = vector<int>(c);\n        i = i + 1;\n    }\n    return i;\n}",
                "int reciprocalCycles(int n) {\n    int result = 0;\n    int maxLength = 0;\n    for (int i = 1; i < n; i++) {\n        vector<int> remainders;\n        int remainder = 1;\n        while (remainder != 0 && !slices::contains(remainders, remainder)) {\n            remainders.push_back(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        int length = 0;\n        if (remainder != 0) {\n            length = remainders.size() - slices::index(remainders, remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint quadraticPrimes(int n) {\n    int maxPrimes = 0;\n    int result = 0;\n    for (int a = -n + 1; a < n; a += 2) {\n        for (int b = -n + 1; b < n; b += 2) {\n            int x = 0;\n            for (;;) {\n                if (x*x+a*x+b < 2) {\n                    break;\n                }\n                if (!isPrime(x*x+a*x+b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "int numberSpiralDiagonals(int n) {\n    int result = 1;\n    for (int i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "int distinctPowers(int n) {\n    int result = 0;\n    set<string> xs;\n    for (int i = 2; i <= n; i++) {\n        vector<int> primes = {2, 3, 5, 7};\n        vector<int> powers = {0, 0, 0, 0};\n        int num = i;\n        for (int j = 0; j < primes.size(); j++) {\n            while (num % primes[j] == 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num != 1) {\n            result += n - 1;\n            continue;\n        }\n        for (int j = 2; j <= n; j++) {\n            string pstr = to_string(powers[0] * j) + \"-\" + to_string(powers[1] * j) + \"-\" + to_string(powers[2] * j) + \"-\" + to_string(powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.size();\n    return result;\n}",
                "int digitNthPowers(int n) {\n    int result = 0;\n    for (int i = 2; i < 4 * pow(10, n); i++) {\n        int digitsSum = 0;\n        for (char digit : to_string(i)) {\n            digitsSum += pow(digit - '0', n);\n        }\n        if (i == digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int coinSums(int n) {\n    vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 200};\n    vector<int> ways(n + 1);\n    ways[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "int pandigitalProducts(int n) {\n    set<int> products;\n    string s;\n    for (int i = 1; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (int a = 1; a < 100; a++) {\n        for (int b = 1; b < 10000; b++) {\n            int c = a * b;\n            string chars = to_string(a) + to_string(b) + to_string(c);\n            sort(chars.begin(), chars.end());\n            if (chars == s) {\n                products.insert(c);\n            }\n        }\n    }\n    int result = 0;\n    for (int product : products) {\n        result += product;\n    }\n    return result;\n}",
                "int digitCancelingFractions(int m) {\n    int numer = 1;\n    int denom = 1;\n    for (int d = 10; d < m; d++) {\n        for (int n = 10; n < d; n++) {\n            int n0 = n % 10;\n            int n1 = n / 10;\n            int d0 = d % 10;\n            int d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    int a = numer;\n    int b = denom;\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return denom / a;\n}",
                "int digitFactorials(int n) {\n    int result = 0;\n    for (int i = 3; i < n; i++) {\n        int factSum = 0;\n        for (char digit : to_string(i)) {\n            int fact = 1;\n            for (int j = 1; j <= digit - '0'; j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i == factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint circularPrimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            set<int> rotations;\n            string str = to_string(i);\n            for (int j = 0; j < str.size(); j++) {\n                int x = stoi(str.substr(j) + str.substr(0, j));\n                rotations.insert(x);\n            }\n            bool flag = true;\n            for (int x : rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint doubleBasePalindromes(int n) {\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        string strI = to_string(i);\n        string binI = bitset<32>(i).to_string();\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint truncatablePrimes(int n) {\n    int result = 0;\n    for (int i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            bool flag = true;\n            for (int j = 1; j < si.size(); j++) {\n                int p1 = stoi(si.substr(j));\n                int p2 = stoi(si.substr(0, si.size() - j));\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "int pandigitalMultiples(int n) {\n    int result = -1;\n    for (int i = 2; i <= n; i++) {\n        string cprod;\n        for (int j = 1; j < 10; j++) {\n            cprod += to_string(i * j);\n            if (cprod.size() == 9) {\n                vector<string> chars = split(cprod, \"\");\n                sort(chars.begin(), chars.end());\n                if (join(chars, \"\") == \"123456789\") {\n                    result = max(result, stoi(cprod));\n                    break;\n                }\n            } else if (cprod.size() > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "int integerRightTriangles(int n) {\n    int maxSol = 0;\n    int result = 0;\n    for (int p = 3; p <= n; p++) {\n        int sol = 0;\n        for (int a = 1; a < p / 2; a++) {\n            for (int b = a; b < p / 2; b++) {\n                int c = p - a - b;\n                if (a * a + b * b == c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "int champernowneConstant(int b) {\n    string s;\n    for (int i = 1; i < pow(b, 6); i++) {\n        s += to_string(i);\n    }\n    int result = 1;\n    for (int i = 0; i < 7; i++) {\n        result *= s[pow(b, i) - 1] - '0';\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint pandigitalPrime(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            int length = si.size();\n            bool flag = true;\n            for (int j = 1; j <= length; j++) {\n                if (si.find(to_string(j)) == string::npos) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "int codedTriangleNumbers(const vector<string>& words) {\n    int result = 0;\n    for (const string& word : words) {\n        int value = 0;\n        for (char c : word) {\n            value += c - 64;\n        }\n        int n = int(sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result++;\n        }\n    }\n    return result;\n}",
                "vector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return vector<string>{s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s[0] + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nint subStringDivisibility(int n) {\n    int result = 0;\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17};\n    string s;\n    for (int i = 0; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (const string& i : genPermutations(s)) {\n        bool flag = true;\n        for (int j = 1; j < n - 1; j++) {\n            if (stoi(i.substr(j, 3)) % primes[j - 1] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += stoi(i);\n        }\n    }\n    return result;\n}",
                "int pentagonNumbers(int n) {\n    unordered_map<int, bool> pentagon;\n    for (int i = 1; i < n; i++) {\n        pentagon[i * (3 * i - 1) / 2] = true;\n    }\n    int result = -1;\n    for (const auto& [j, _] : pentagon) {\n        for (const auto& [k, _] : pentagon) {\n            if (pentagon[j + k] && pentagon[k - j]) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int triangularPentagonalAndHexagonal(int n) {\n    unordered_map<int, bool> ps;\n    int i = 1;\n    int c = int(0.5 * float(i) * (3 * float(i) - 1));\n    while (c < n) {\n        i++;\n        ps[c] = true;\n        c = int(0.5 * float(i) * (3 * float(i) - 1));\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    int result = -1;\n    while (c < n) {\n        i++;\n        if (ps[c]) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n / 2)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint goldbachsOtherConjecture(int n) {\n    int result = -1;\n    for (int i = 9999; i > n; i -= 2) {\n        int upper = int(sqrt(i / 2));\n        bool flag = false;\n        for (int j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "int primeFactors(int n) {\n    int num = n;\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= num) {\n        if (num % i != 0) {\n            i++;\n        } else {\n            num /= i;\n            factors.push_back(i);\n        }\n    }\n    if (num > 1) {\n        factors.push_back(num);\n    }\n    unordered_set<int> s;\n    for (int v : factors) {\n        s.insert(v);\n    }\n    return s.size();\n}\n\nint distinctPrimesFactors(int n) {\n    for (int i = n; i < 1000000; i++) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "string selfPowers(int n) {\n    int digits[10] = {};\n    for (int i = 1; i <= n; i++) {\n        int tempDigits[10] = {};\n        tempDigits[0] = 1;\n        for (int j = 0; j < i; j++) {\n            int carry = 0;\n            for (int k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = tempDigits[k] / 10;\n                tempDigits[k] %= 10;\n            }\n        }\n        for (int j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    string result = \"\";\n    for (int i = 9; i >= 0; i--) {\n        result += to_string(digits[i]);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return vector<string>{s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s[0] + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nstring primePermutations(int n) {\n    for (int i = n; i > 999; i--) {\n        if (isPrime(i)) {\n            vector<string> permutations = genPermutations(to_string(i));\n            unordered_map<int, bool> candidates;\n            for (const string& j : permutations) {\n                int candidate = stoi(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates[candidate] = true;\n                }\n            }\n            for (int m : candidates) {\n                if (candidates[m + (m - i)]) {\n                    return to_string(i) + to_string(m) + to_string(m + (m - i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "int consecutivePrimeSum(int limit) {\n    vector<bool> sieve(limit);\n    for (int i = 0; i < limit; i++) {\n        sieve[i] = true;\n    }\n    vector<int> primes;\n    for (int i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n            for (int j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    int maxLength = 0;\n    int maxPrime = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i + maxLength; j < primes.size(); j++) {\n            int s = 0;\n            for (int k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
            ],
            "csharp": [
                "class Global {\n    public static int MultiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int EvenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i != 0) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i] != s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int LargestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (IsPalindrome(prod.ToString()) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SmallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i != 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int NthPrime(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (primes.Count < n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes[primes.Count - 1];\n    }\n}",
                "class Global {\n    public static int LargestProductInASeries(string s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.Length - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= (s[i + j] - '0');\n            }\n            result = Math.Max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SpecialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int SummationOfPrimes(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (i <= n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        foreach (int prime in primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestProductInAGrid(IList<IList<int>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.Count - 3; i++) {\n            for (int j = 0; j < grid[i].Count - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid[i + k][j];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid[i][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid[i + k][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid[i + k][j + 3 - k];\n                }\n                result = Math.Max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int HighlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int)Math.Sqrt(result); j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string LargeSum(IList<string> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            foreach (string num in numbers) {\n                tmp += (num[49 - i] - '0');\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i] != 0) {\n                string result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += digits[j].ToString();\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int LongestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LatticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][];\n        for (int i = 0; i <= m; i++) {\n            grid[i] = new int[n + 1];\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int PowerDigitSum(int n) {\n        IList<int> digits = new List<int> { 2 };\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                int temp = digits[j]*2 + carry;\n                digits[j] = temp % 10;\n                carry = temp / 10;\n            }\n            if (carry != 0) {\n                digits.Add(carry);\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string NumberToWords(int n) {\n        string[] ones = new string[] {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        string[] teens = new string[] {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        string[] tens = new string[] {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            string suf = \"\";\n            if (n % 10 != 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int MaximumPathSumI(IList<IList<int>> triangle) {\n        IList<int> curr = new List<int>(triangle[triangle.Count - 1]);\n        for (int i = triangle.Count - 2; i >= 0; i--) {\n            IList<int> next = new List<int>(triangle[i]);\n            for (int j = 0; j < next.Count; j++) {\n                next[j] += Math.Max(curr[j], curr[j + 1]);\n            }\n            curr = next;\n        }\n        return curr[0];\n    }\n}",
                "class Global {\n    public static int CountingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count++;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int FactorialDigitSum(int n) {\n        IList<int> digits = new List<int> { 1 };\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                digits[j] = digits[j] * i + carry;\n                carry = digits[j] / 10;\n                digits[j] %= 10;\n            }\n            while (carry != 0) {\n                digits.Add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int D(int n) {\n        int result = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i != n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int AmicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = D(a);\n            if (a != b && a == D(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NamesScores(IList<string> names, IList<string> queries) {\n        IList<string> sNames = new List<string>(names);\n        sNames.Sort();\n        int result = 0;\n        for (int i = 0; i < sNames.Count; i++) {\n            int x = 0;\n            foreach (char c in sNames[i]) {\n                x += (int)c - 64;\n            }\n            foreach (string query in queries) {\n                if (query == sNames[i]) {\n                    result += x * (i + 1);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i != n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int NonAbundantSums(int n) {\n        IList<int> abundants = new List<int>();\n        for (int i = 12; i < n; i++) {\n            if (IsAbundant(i)) {\n                abundants.Add(i);\n            }\n        }\n        ISet<int> abundantSums = new HashSet<int>();\n        foreach (int i in abundants) {\n            foreach (int j in abundants) {\n                abundantSums.Add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.Contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string LexicographicPermutations(int n) {\n        string result = \"\";\n        int[] digits = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += idx.ToString();\n            digits = digits.Where((d, i) => i != idx).ToArray();\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NDigitFibonacciNumber(int n) {\n        IList<int> a = new List<int> { 1 };\n        IList<int> b = new List<int> { 1 };\n        int i = 2;\n        while (b.Count < n) {\n            int carry = 0;\n            IList<int> c = new List<int>(b);\n            for (int j = 0; j < b.Count; j++) {\n                if (j < a.Count) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry != 0) {\n                b.Add(carry);\n            }\n            a = new List<int>(c);\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int ReciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            IList<int> remainders = new List<int>();\n            int remainder = 1;\n            while (remainder != 0 && !remainders.Contains(remainder)) {\n                remainders.Add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder != 0) {\n                length = remainders.Count - remainders.IndexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int QuadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (x * x + a * x + b >= 2) {\n                    if (!IsPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x++;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NumberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DistinctPowers(int n) {\n        int result = 0;\n        Dictionary<string, bool> xs = new Dictionary<string, bool>();\n        for (int i = 2; i <= n; i++) {\n            int[] primes = new int[] { 2, 3, 5, 7 };\n            int[] powers = new int[] { 0, 0, 0, 0 };\n            int num = i;\n            for (int j = 0; j < primes.Length; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num != 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                string pstr = string.Format(\"{0}-{1}-{2}-{3}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n                xs[pstr] = true;\n            }\n        }\n        result += xs.Count;\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * (int)Math.Pow(10, n); i++) {\n            int digitsSum = 0;\n            foreach (char digit in i.ToString()) {\n                digitsSum += (int)Math.Pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int CoinSums(int n) {\n        int[] coins = new int[] { 1, 2, 5, 10, 20, 50, 100, 200 };\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        foreach (int coin in coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int PandigitalProducts(int n) {\n        Dictionary<int, bool> products = new Dictionary<int, bool>();\n        string s = \"\";\n        for (int i = 1; i <= n; i++) {\n            s += i.ToString();\n        }\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                char[] chars = (a.ToString() + b.ToString() + c.ToString()).ToCharArray();\n                Array.Sort(chars);\n                if (new string(chars) == s) {\n                    products[c] = true;\n                }\n            }\n        }\n        int result = 0;\n        foreach (int product in products.Keys) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int DigitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            foreach (char digit in i.ToString()) {\n                int fact = 1;\n                for (int j = 1; j <= digit - '0'; j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int CircularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (IsPrime(i)) {\n                Dictionary<int, object> rotations = new Dictionary<int, object>();\n                string str = i.ToString();\n                for (int j = 0; j < str.Length; j++) {\n                    int x = int.Parse(str.Substring(j) + str.Substring(0, j));\n                    rotations[x] = new object();\n                }\n                bool flag = true;\n                foreach (int x in rotations.Keys) {\n                    if (!IsPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i] != s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int DoubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            string strI = i.ToString();\n            string binI = Convert.ToString(i, 2);\n            if (IsPalindrome(strI) && IsPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int TruncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                bool flag = true;\n                for (int j = 1; j < si.Length; j++) {\n                    int p1 = int.Parse(si.Substring(j));\n                    int p2 = int.Parse(si.Substring(0, si.Length - j));\n                    if (!IsPrime(p1) || !IsPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            string cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += i * j;\n                if (cprod.Length == 9) {\n                    char[] chars = cprod.ToCharArray();\n                    Array.Sort(chars);\n                    if (new string(chars) == \"123456789\") {\n                        result = Math.Max(result, int.Parse(cprod));\n                        break;\n                    }\n                } else if (cprod.Length > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int IntegerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol++;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int ChampernowneConstant(int b) {\n        string s = \"\";\n        for (int i = 1; i < (int)Math.Pow(b, 6); i++) {\n            s += i.ToString();\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            result *= int.Parse(s[(int)Math.Pow(b, i) - 1].ToString());\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int PandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                int length = si.Length;\n                bool flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.Contains(j.ToString())) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int CodedTriangleNumbers(IList<string> words) {\n        int result = 0;\n        foreach (string word in words) {\n            int value = 0;\n            foreach (char c in word) {\n                value += (int)c - 64;\n            }\n            int n = (int)Math.Sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int SubStringDivisibility(int n) {\n        int result = 0;\n        int[] primes = new int[] { 2, 3, 5, 7, 11, 13, 17 };\n        string s = \"\";\n        for (int i = 0; i <= n; i++) {\n            s += i.ToString();\n        }\n        foreach (string i in GenPermutations(s)) {\n            bool flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (int.Parse(i.Substring(j, 3)) % primes[j - 1] != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += int.Parse(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PentagonNumbers(int n) {\n        Dictionary<int, bool> pentagon = new Dictionary<int, bool>();\n        for (int i = 1; i < n; i++) {\n            pentagon[i * (3 * i - 1) / 2] = true;\n        }\n        int result = -1;\n        foreach (int j in pentagon.Keys) {\n            foreach (int k in pentagon.Keys) {\n                if (pentagon[j + k] && pentagon[k - j]) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int TriangularPentagonalAndHexagonal(int n) {\n        Dictionary<int, bool> ps = new Dictionary<int, bool>();\n        int i = 1;\n        int c = (int)(0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i++;\n            ps[c] = true;\n            c = (int)(0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i++;\n            if (ps.ContainsKey(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int GoldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i > n; i -= 2) {\n            int upper = (int)Math.Sqrt(i / 2);\n            bool flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (IsPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PrimeFactors(int n) {\n        int num = n;\n        IList<int> factors = new List<int>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i != 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.Add(i);\n            }\n        }\n        if (num > 1) {\n            factors.Add(num);\n        }\n        Dictionary<int, bool> s = new Dictionary<int, bool>();\n        foreach (int v in factors) {\n            s[v] = true;\n        }\n        return s.Count;\n    }\n\n    public static int DistinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string SelfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        string result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += digits[i].ToString();\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static string PrimePermutations(int n) {\n        for (int i = n; i > 999; i--) {\n            if (IsPrime(i)) {\n                IList<string> permutations = GenPermutations(i.ToString());\n                Dictionary<int, bool> candidates = new Dictionary<int, bool>();\n                foreach (string j in permutations) {\n                    int candidate;\n                    if (int.TryParse(j, out candidate)) {\n                        if (candidate > i && IsPrime(candidate)) {\n                            candidates[candidate] = true;\n                        }\n                    }\n                }\n                foreach (int m in candidates.Keys) {\n                    if (candidates[m + (m - i)]) {\n                        return i.ToString() + m.ToString() + (m + (m - i)).ToString();\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int ConsecutivePrimeSum(int limit) {\n        bool[] sieve = new bool[limit];\n        for (int i = 0; i < sieve.Length; i++) {\n            sieve[i] = true;\n        }\n        IList<int> primes = new List<int>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.Add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.Count; i++) {\n            for (int j = i + maxLength; j < primes.Count; j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes[k];\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
            ],
            "java": [
                "class Global {\n    public static int multiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int evenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i != 0) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int largestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (isPalindrome(Integer.toString(prod)) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int smallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i != 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int sumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int nthPrime(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (primes.size() < n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes.get(primes.size() - 1);\n    }\n}",
                "class Global {\n    public static int largestProductInASeries(String s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.length() - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= s.charAt(i + j) - '0';\n            }\n            result = Math.max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int specialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int summationOfPrimes(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (i <= n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        for (int prime : primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestProductInAGrid(List<List<Integer>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.size() - 3; i++) {\n            for (int j = 0; j < grid.get(i).size() - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid.get(i + k).get(j);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid.get(i).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid.get(i + k).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid.get(i + k).get(j + 3 - k);\n                }\n                result = Math.max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int highlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int) Math.sqrt(result); j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String largeSum(List<String> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            for (String num : numbers) {\n                tmp += num.charAt(49 - i) - '0';\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i] != 0) {\n                String result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += Integer.toString(digits[j]);\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int longestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int latticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int powerDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(2);\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                int temp = digits.get(j)*2 + carry;\n                digits.set(j, temp % 10);\n                carry = temp / 10;\n            }\n            if (carry != 0) {\n                digits.add(carry);\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String numberToWords(int n) {\n        String[] ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        String[] teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        String[] tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            String suf = \"\";\n            if (n % 10 != 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int maximumPathSumI(List<List<Integer>> triangle) {\n        int[] curr = new int[triangle.get(triangle.size() - 1).size()];\n        System.arraycopy(triangle.get(triangle.size() - 1).toArray(), 0, curr, 0, curr.length);\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            int[] next = new int[triangle.get(i).size()];\n            System.arraycopy(triangle.get(i).toArray(), 0, next, 0, next.length);\n            for (int j = 0; j < next.length; j++) {\n                next[j] += Math.max(curr[j], curr[j + 1]);\n            }\n            curr = next;\n        }\n        return curr[0];\n    }\n}",
                "class Global {\n    public static int countingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count++;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int factorialDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(1);\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                digits.set(j, digits.get(j) * i + carry);\n                carry = digits.get(j) / 10;\n                digits.set(j, digits.get(j) % 10);\n            }\n            while (carry != 0) {\n                digits.add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int d(int n) {\n        int result = 1;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i != n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int amicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = d(a);\n            if (a != b && a == d(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int namesScores(List<String> names, List<String> queries) {\n        List<String> sNames = new ArrayList<>(names);\n        Collections.sort(sNames);\n        int result = 0;\n        for (int i = 0; i < sNames.size(); i++) {\n            String name = sNames.get(i);\n            int x = 0;\n            for (int j = 0; j < name.length(); j++) {\n                x += name.charAt(j) - 64;\n            }\n            for (String query : queries) {\n                if (query.equals(name)) {\n                    result += x * (i + 1);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i != n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int nonAbundantSums(int n) {\n        List<Integer> abundants = new ArrayList<>();\n        for (int i = 12; i < n; i++) {\n            if (isAbundant(i)) {\n                abundants.add(i);\n            }\n        }\n        Set<Integer> abundantSums = new HashSet<>();\n        for (int i : abundants) {\n            for (int j : abundants) {\n                abundantSums.add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String lexicographicPermutations(int n) {\n        String result = \"\";\n        int[] digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += Integer.toString(digits[idx]);\n            digits = Arrays.copyOf(digits, digits.length - 1);\n            System.arraycopy(digits, idx + 1, digits, idx, digits.length - idx - 1);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int nDigitFibonacciNumber(int n) {\n        int[] a = {1};\n        int[] b = {1};\n        int i = 2;\n        while (b.length < n) {\n            int carry = 0;\n            int[] c = new int[b.length];\n            System.arraycopy(b, 0, c, 0, b.length);\n            for (int j = 0; j < b.length; j++) {\n                if (j < a.length) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry != 0) {\n                b = Arrays.copyOf(b, b.length + 1);\n                b[b.length - 1] = carry;\n            }\n            a = new int[c.length];\n            System.arraycopy(c, 0, a, 0, c.length);\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int reciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            List<Integer> remainders = new ArrayList<>();\n            int remainder = 1;\n            while (remainder != 0 && !remainders.contains(remainder)) {\n                remainders.add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder != 0) {\n                length = remainders.size() - remainders.indexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int quadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (x * x + a * x + b < 2) {\n                    if (!isPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x++;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int numberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int distinctPowers(int n) {\n        int result = 0;\n        Set<String> xs = new HashSet<>();\n        for (int i = 2; i <= n; i++) {\n            int[] primes = new int[]{2, 3, 5, 7};\n            int[] powers = new int[]{0, 0, 0, 0};\n            int num = i;\n            for (int j = 0; j < primes.length; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num != 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                String pstr = String.format(\"%d-%d-%d-%d\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n                xs.add(pstr);\n            }\n        }\n        result += xs.size();\n        return result;\n    }\n}",
                "class Global {\n    public static int digitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * (int) Math.pow(10, n); i++) {\n            int digitsSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                digitsSum += (int) Math.pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int coinSums(int n) {\n        int[] coins = {1, 2, 5, 10, 20, 50, 100, 200};\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int pandigitalProducts(int n) {\n        Map<Integer, Boolean> products = new HashMap<>();\n        String s = \"\";\n        for (int i = 1; i <= n; i++) {\n            s += Integer.toString(i);\n        }\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                char[] chars = (Integer.toString(a) + Integer.toString(b) + Integer.toString(c)).toCharArray();\n                Arrays.sort(chars);\n                if (new String(chars).equals(s)) {\n                    products.put(c, true);\n                }\n            }\n        }\n        int result = 0;\n        for (int product : products.keySet()) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int digitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int digitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                int fact = 1;\n                for (int j = 1; j <= digit - '0'; j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int circularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                Map<Integer, Object> rotations = new HashMap<>();\n                String str = Integer.toString(i);\n                for (int j = 0; j < str.length(); j++) {\n                    int x = Integer.parseInt(str.substring(j) + str.substring(0, j));\n                    rotations.put(x, new Object());\n                }\n                boolean flag = true;\n                for (int x : rotations.keySet()) {\n                    if (!isPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int doubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            String strI = Integer.toString(i);\n            String binI = Integer.toBinaryString(i);\n            if (isPalindrome(strI) && isPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int truncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (isPrime(i)) {\n                String si = Integer.toString(i);\n                boolean flag = true;\n                for (int j = 1; j < si.length(); j++) {\n                    int p1 = Integer.parseInt(si.substring(j));\n                    int p2 = Integer.parseInt(si.substring(0, si.length() - j));\n                    if (!isPrime(p1) || !isPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            String cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += Integer.toString(i * j);\n                if (cprod.length() == 9) {\n                    String[] chars = cprod.split(\"\");\n                    Arrays.sort(chars);\n                    if (String.join(\"\", chars).equals(\"123456789\")) {\n                        result = Math.max(result, Integer.parseInt(cprod));\n                        break;\n                    }\n                } else if (cprod.length() > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int integerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol++;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int champernowneConstant(int b) {\n        String s = \"\";\n        for (int i = 1; i < (int) Math.pow(b, 6); i++) {\n            s += Integer.toString(i);\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            result *= Integer.parseInt(String.valueOf(s.charAt((int) Math.pow(b, i) - 1)));\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int pandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (isPrime(i)) {\n                String si = Integer.toString(i);\n                int length = si.length();\n                boolean flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.contains(Integer.toString(j))) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int codedTriangleNumbers(List<String> words) {\n        int result = 0;\n        for (String word : words) {\n            int value = 0;\n            for (char c : word.toCharArray()) {\n                value += c - 64;\n            }\n            int n = (int) Math.sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return Arrays.asList(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.charAt(0) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int subStringDivisibility(int n) {\n        int result = 0;\n        int[] primes = {2, 3, 5, 7, 11, 13, 17};\n        String s = \"\";\n        for (int i = 0; i <= n; i++) {\n            s += Integer.toString(i);\n        }\n        for (String i : genPermutations(s)) {\n            boolean flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (Integer.parseInt(i.substring(j, j + 3)) % primes[j - 1] != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += Integer.parseInt(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pentagonNumbers(int n) {\n        Map<Integer, Boolean> pentagon = new HashMap<>();\n        for (int i = 1; i < n; i++) {\n            pentagon.put(i * (3 * i - 1) / 2, true);\n        }\n        int result = -1;\n        for (int j : pentagon.keySet()) {\n            for (int k : pentagon.keySet()) {\n                if (pentagon.get(j + k) && pentagon.get(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int triangularPentagonalAndHexagonal(int n) {\n        Map<Integer, Boolean> ps = new HashMap<>();\n        int i = 1;\n        int c = (int) (0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i++;\n            ps.put(c, true);\n            c = (int) (0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i++;\n            if (ps.get(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int goldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i > n; i -= 2) {\n            int upper = (int) Math.sqrt(i / 2);\n            boolean flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (isPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int primeFactors(int n) {\n        int num = n;\n        List<Integer> factors = new ArrayList<>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i != 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.add(i);\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        Set<Integer> s = new HashSet<>();\n        for (int v : factors) {\n            s.add(v);\n        }\n        return s.size();\n    }\n\n    public static int distinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String selfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        String result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += Integer.toString(digits[i]);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return Arrays.asList(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.charAt(0) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static String primePermutations(int n) {\n        for (int i = n; i > 999; i--) {\n            if (isPrime(i)) {\n                List<String> permutations = genPermutations(Integer.toString(i));\n                Set<Integer> candidates = new HashSet<>();\n                for (String j : permutations) {\n                    int candidate = Integer.parseInt(j);\n                    if (candidate > i && isPrime(candidate)) {\n                        candidates.add(candidate);\n                    }\n                }\n                for (int m : candidates) {\n                    if (candidates.contains(m + (m - i))) {\n                        return Integer.toString(i) + Integer.toString(m) + Integer.toString(m + (m - i));\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int consecutivePrimeSum(int limit) {\n        boolean[] sieve = new boolean[limit];\n        for (int i = 0; i < sieve.length; i++) {\n            sieve[i] = true;\n        }\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + maxLength; j < primes.size(); j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes.get(k);\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
            ],
            "javascript": [
                "const multiplesOf3And5 = (n) => {\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const evenFibonacciNumbers = (n) => {\n    let result = 0;\n    let a = 1;\n    let b = 2;\n    while (a < n) {\n        if (a % 2 === 0) {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "const largestPrimeFactor = (n) => {\n    let result = n;\n    let i = 2;\n    while (i * i <= result) {\n        if (result % i !== 0) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i] !== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst largestPalindromeProduct = (n) => {\n    let result = 0;\n    for (let i = 100; i < 1000; i++) {\n        for (let j = i; j < 1000; j++) {\n            let prod = i * j;\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "const smallestMultiple = (n) => {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        if (result % i !== 0) {\n            for (let j = 1; j <= n; j++) {\n                if ((result * j) % i === 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const sumSquareDifference = (n) => {\n    let sqrSum = 0;\n    let numSum = 0;\n    for (let i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "const nthPrime = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (primes.length < n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.length - 1];\n}",
                "const largestProductInASeries = (s, k) => {\n    let result = 0;\n    for (let i = 0; i < s.length - k; i++) {\n        let product = 1;\n        for (let j = 0; j < k; j++) {\n            product *= s.charCodeAt(i + j) - '0'.charCodeAt(0);\n        }\n        result = Math.max(result, product);\n    }\n    return result;\n}",
                "const specialPythagoreanTriplet = (n) => {\n    for (let a = 1; a < n; a++) {\n        for (let b = a; b < n; b++) {\n            let c = n - a - b;\n            if (a * a + b * b === c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "const summationOfPrimes = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (i <= n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let result = 0;\n    for (let prime of primes) {\n        result += prime;\n    }\n    return result;\n}",
                "const largestProductInAGrid = (grid) => {\n    let result = 0;\n    for (let i = 0; i < grid.length - 3; i++) {\n        for (let j = 0; j < grid[i].length - 3; j++) {\n            let p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (let k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (let k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = Math.max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "const highlyDivisibleTriangularNumber = (n) => {\n    for (let i = 1; i < 100000000; i++) {\n        let result = i * (i + 1) / 2;\n        let count = 0;\n        for (let j = 1; j <= Math.sqrt(result); j++) {\n            if (result % j === 0) {\n                count += 2;\n            }\n            if (j * j === result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "const largeSum = (numbers) => {\n    let digits = new Array(60).fill(0);\n    for (let i = 0; i < 50; i++) {\n        let tmp = 0;\n        for (let num of numbers) {\n            tmp += parseInt(num[49 - i] - '0');\n        }\n        for (let j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += Math.floor(digits[j] / 10);\n                digits[j] %= 10;\n            }\n            tmp = Math.floor(tmp / 10);\n            if (tmp == 0) {\n                break;\n            }\n        }\n    }\n    for (let i = 59; i >= 0; i--) {\n        if (digits[i] != 0) {\n            let result = \"\";\n            for (let j = i; j > i - 10; j--) {\n                result += digits[j].toString();\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
                "const longestCollatzSequence = (n) => {\n    let longest = 0;\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let chain = 1;\n        let num = i;\n        while (num !== 1) {\n            if (num % 2 === 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const latticePaths = (m, n) => {\n    let grid = [];\n    for (let i = 0; i <= m; i++) {\n        grid[i] = [];\n        for (let j = 0; j <= n; j++) {\n            grid[i][j] = 0;\n        }\n    }\n    for (let i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (let j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "const powerDigitSum = (n) => {\n    let digits = [2];\n    for (let i = 1; i < n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            let temp = digits[j]*2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry != 0) {\n            digits.push(carry);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const numberToWords = (n) => {\n    let ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        let suf = \"\";\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "const maximumPathSumI = (triangle) => {\n    let curr = triangle[triangle.length - 1].slice();\n    for (let i = triangle.length - 2; i >= 0; i--) {\n        let next = triangle[i].slice();\n        for (let j = 0; j < next.length; j++) {\n            next[j] += Math.max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "const countingSundays = (y1, y2) => {\n    let day = 0;\n    let count = 0;\n    for (let year = 1900; year <= y2; year++) {\n        for (let month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 === 6) {\n                count++;\n            }\n            if (month === 4 || month === 6 || month === 9 || month === 11) {\n                day += 30;\n            } else if (month === 2) {\n                if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "const factorialDigitSum = (n) => {\n    let digits = [1];\n    for (let i = 1; i <= n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while (carry != 0) {\n            digits.push(carry % 10);\n            carry /= 10;\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const d = (n) => {\n    let result = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            result += i;\n            if (i !== n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nconst amicableNumbers = (n) => {\n    let result = 0;\n    for (let a = 2; a < n; a++) {\n        let b = d(a);\n        if (a !== b && a === d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "const namesScores = (names, queries) => {\n    let sNames = slices.clone(names);\n    slices.sort(sNames);\n    let result = 0;\n    for (let i = 0; i < sNames.length; i++) {\n        let name = sNames[i];\n        let x = 0;\n        for (let c of name) {\n            x += c.charCodeAt(0) - 64;\n        }\n        for (let query of queries) {\n            if (query === name) {\n                result += x * (i + 1);\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "const isAbundant = (n) => {\n    if (n < 12) {\n        return false;\n    }\n    let sumDivisors = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            sumDivisors += i;\n            if (i !== n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nconst nonAbundantSums = (n) => {\n    let abundants = [];\n    for (let i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push(i);\n        }\n    }\n    let abundantSums = {};\n    for (let i of abundants) {\n        for (let j of abundants) {\n            abundantSums[i + j] = true;\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!abundantSums[i]) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const lexicographicPermutations = (n) => {\n    let result = \"\";\n    let digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let x = n - 1;\n    for (let i = 10; i > 0; i--) {\n        let fact = 1;\n        for (let j = 1; j < i; j++) {\n            fact *= j;\n        }\n        let idx = Math.floor(x / fact);\n        result += idx.toString();\n        digits = digits.slice(0, idx).concat(digits.slice(idx + 1));\n        x -= idx * fact;\n    }\n    return result;\n}",
                "const nDigitFibonacciNumber = (n) => {\n    let a = [1];\n    let b = [1];\n    let i = 2;\n    while (b.length < n) {\n        let carry = 0;\n        let c = b.slice();\n        for (let j = 0; j < b.length; j++) {\n            if (j < a.length) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry != 0) {\n            b.push(carry);\n        }\n        a = c.slice();\n        i = i + 1;\n    }\n    return i;\n}",
                "const reciprocalCycles = (n) => {\n    let result = 0;\n    let maxLength = 0;\n    for (let i = 1; i < n; i++) {\n        let remainders = [];\n        let remainder = 1;\n        while (remainder !== 0 && !remainders.includes(remainder)) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = 0;\n        if (remainder !== 0) {\n            length = remainders.length - remainders.indexOf(remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst quadraticPrimes = (n) => {\n    let maxPrimes = 0;\n    let result = 0;\n    for (let a = -n + 1; a < n; a += 2) {\n        for (let b = -n + 1; b < n; b += 2) {\n            let x = 0;\n            while (x * x + a * x + b >= 2) {\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "const numberSpiralDiagonals = (n) => {\n    let result = 1;\n    for (let i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "const distinctPowers = (n) => {\n    let result = 0;\n    let xs = {};\n    for (let i = 2; i <= n; i++) {\n        let primes = [2, 3, 5, 7];\n        let powers = [0, 0, 0, 0];\n        let num = i;\n        for (let j = 0; j < primes.length; j++) {\n            while (num % primes[j] === 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num !== 1) {\n            result += n - 1;\n            continue;\n        }\n        for (let j = 2; j <= n; j++) {\n            let pstr = `${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}`;\n            xs[pstr] = true;\n        }\n    }\n    result += Object.keys(xs).length;\n    return result;\n}",
                "const digitNthPowers = (n) => {\n    let result = 0;\n    for (let i = 2; i < 4 * Math.pow(10, n); i++) {\n        let digitsSum = 0;\n        for (let digit of i.toString()) {\n            digitsSum += Math.pow(parseInt(digit), n);\n        }\n        if (i === digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const coinSums = (n) => {\n    let coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    let ways = new Array(n + 1);\n    ways[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "const pandigitalProducts = (n) => {\n    let products = {};\n    let s = \"\";\n    for (let i = 1; i <= n; i++) {\n        s += i.toString();\n    }\n    for (let a = 1; a < 100; a++) {\n        for (let b = 1; b < 10000; b++) {\n            let c = a * b;\n            let chars = a.toString() + b.toString() + c.toString();\n            chars.split(\"\").sort();\n            if (chars === s) {\n                products[c] = true;\n            }\n        }\n    }\n    let result = 0;\n    for (let product of Object.keys(products)) {\n        result += parseInt(product);\n    }\n    return result;\n}",
                "const digitCancelingFractions = (m) => {\n    let numer = 1;\n    let denom = 1;\n    for (let d = 10; d < m; d++) {\n        for (let n = 10; n < d; n++) {\n            let n0 = n % 10;\n            let n1 = Math.floor(n / 10);\n            let d0 = d % 10;\n            let d1 = Math.floor(d / 10);\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let a = numer;\n    let b = denom;\n    while (b != 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return denom / a;\n}",
                "const digitFactorials = (n) => {\n    let result = 0;\n    for (let i = 3; i < n; i++) {\n        let factSum = 0;\n        for (let digit of i.toString()) {\n            let fact = 1;\n            for (let j = 1; j <= parseInt(digit); j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i == factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst circularPrimes = (n) => {\n    let count = 0;\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            const rotations = {};\n            const str = i.toString();\n            for (let j = 0; j < str.length; j++) {\n                const x = parseInt(str.substring(j) + str.substring(0, j));\n                rotations[x] = {};\n            }\n            let flag = true;\n            for (let x in rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i] !== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst doubleBasePalindromes = (n) => {\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let strI = i.toString();\n        let binI = i.toString(2);\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst truncatablePrimes = (n) => {\n    let result = 0;\n    for (let i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            let si = i.toString();\n            let flag = true;\n            for (let j = 1; j < si.length; j++) {\n                let p1 = parseInt(si.substring(j));\n                let p2 = parseInt(si.substring(0, si.length - j));\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "const pandigitalMultiples = (n) => {\n    let result = -1;\n    for (let i = 2; i <= n; i++) {\n        let cprod = \"\";\n        for (let j = 1; j < 10; j++) {\n            cprod += i * j;\n            if (cprod.length === 9) {\n                let chars = cprod.split(\"\");\n                chars.sort();\n                if (chars.join(\"\") === \"123456789\") {\n                    result = Math.max(result, parseInt(cprod));\n                    break;\n                }\n            } else if (cprod.length > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "const integerRightTriangles = (n) => {\n    let maxSol = 0;\n    let result = 0;\n    for (let p = 3; p <= n; p++) {\n        let sol = 0;\n        for (let a = 1; a < p / 2; a++) {\n            for (let b = a; b < p / 2; b++) {\n                let c = p - a - b;\n                if (a * a + b * b === c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "const champernowneConstant = (b) => {\n    let s = \"\";\n    for (let i = 1; i < Math.pow(b, 6); i++) {\n        s += i.toString();\n    }\n    let result = 1;\n    for (let i = 0; i < 7; i++) {\n        result *= parseInt(s[Math.pow(b, i) - 1]);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst pandigitalPrime = (n) => {\n    for (let i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            let si = i.toString();\n            let length = si.length;\n            let flag = true;\n            for (let j = 1; j <= length; j++) {\n                if (!si.includes(j.toString())) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "const codedTriangleNumbers = (words) => {\n    let result = 0;\n    for (let word of words) {\n        let value = 0;\n        for (let c of word) {\n            value += c.charCodeAt(0) - 64;\n        }\n        let n = Math.floor(Math.sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result++;\n        }\n    }\n    return result;\n}",
                "const genPermutations = (s) => {\n    if (s.length <= 1) {\n        return [s];\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s[0] + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst subStringDivisibility = (n) => {\n    let result = 0;\n    let primes = [2, 3, 5, 7, 11, 13, 17];\n    let s = \"\";\n    for (let i = 0; i <= n; i++) {\n        s += i.toString();\n    }\n    for (let i of genPermutations(s)) {\n        let flag = true;\n        for (let j = 1; j < n - 1; j++) {\n            if (parseInt(i.substring(j, j + 3)) % primes[j - 1] !== 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += parseInt(i);\n        }\n    }\n    return result;\n}",
                "const pentagonNumbers = (n) => {\n    let pentagon = {};\n    for (let i = 1; i < n; i++) {\n        pentagon[i * (3 * i - 1) / 2] = true;\n    }\n    let result = -1;\n    for (let j in pentagon) {\n        for (let k in pentagon) {\n            if (pentagon[j + k] && pentagon[k - j]) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const triangularPentagonalAndHexagonal = (n) => {\n    let ps = {};\n    let i = 1;\n    let c = Math.floor(0.5 * i * (3 * i - 1));\n    while (c < n) {\n        i++;\n        ps[c] = true;\n        c = Math.floor(0.5 * i * (3 * i - 1));\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let result = -1;\n    while (c < n) {\n        i++;\n        if (ps[c]) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n / 2); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst goldbachsOtherConjecture = (n) => {\n    let result = -1;\n    for (let i = 9999; i > n; i -= 2) {\n        upper := Math.sqrt(i / 2);\n        flag := false;\n        for (let j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "const primeFactors = (n) => {\n    let num = n;\n    let factors = [];\n    let i = 2;\n    while (i * i <= num) {\n        if (num % i !== 0) {\n            i++;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if (num > 1) {\n        factors.push(num);\n    }\n    let s = {};\n    for (let v of factors) {\n        s[v] = true;\n    }\n    return Object.keys(s).length;\n}\n\nconst distinctPrimesFactors = (n) => {\n    for (let i = n; i < 1000000; i++) {\n        if (primeFactors(i) === 4 && primeFactors(i + 1) === 4 && primeFactors(i + 2) === 4 && primeFactors(i + 3) === 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "const selfPowers = (n) => {\n    let digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let i = 1; i <= n; i++) {\n        let tempDigits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        tempDigits[0] = 1;\n        for (let j = 0; j < i; j++) {\n            let carry = 0;\n            for (let k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = tempDigits[k] / 10;\n                tempDigits[k] %= 10;\n            }\n        }\n        for (let j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let result = \"\";\n    for (let i = 9; i >= 0; i--) {\n        result += i.toString();\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst genPermutations = (s) => {\n    if (s.length <= 1) {\n        return [s];\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s[0] + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst primePermutations = (n) => {\n    for (let i = n; i > 999; i--) {\n        if (isPrime(i)) {\n            let permutations = genPermutations(i.toString());\n            let candidates = {};\n            for (let j of permutations) {\n                let candidate = parseInt(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates[candidate] = true;\n                }\n            }\n            for (let m in candidates) {\n                if (candidates[m] && candidates[m + (m - i)]) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString();\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "const consecutivePrimeSum = (limit) => {\n    let sieve = [];\n    for (let i = 0; i < limit; i++) {\n        sieve[i] = true;\n    }\n    let primes = [];\n    for (let i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push(i);\n            for (let j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    let maxLength = 0;\n    let maxPrime = 0;\n    for (let i = 0; i < primes.length; i++) {\n        for (let j = i + maxLength; j < primes.length; j++) {\n            let s = 0;\n            for (let k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
            ],
            "kotlin": [
                "fun multiplesOf3And5(n: Int): Int {\n    var result = 0\n    for (i in 0 until n) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun evenFibonacciNumbers(n: Int): Int {\n    var result = 0\n    var a = 1\n    var b = 2\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a\n        }\n        val tmp = a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
                "fun largestPrimeFactor(n: Int): Int {\n    var result = n\n    var i = 2\n    while (i * i <= result) {\n        if (result % i != 0) {\n            i += 1\n        } else {\n            result /= i\n        }\n    }\n    return result\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i] != s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun largestPalindromeProduct(n: Int): Int {\n    var result = 0\n    for (i in 100 until 1000) {\n        for (j in i until 1000) {\n            val prod = i * j\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
                "fun smallestMultiple(n: Int): Int {\n    var result = 1\n    for (i in 1..n) {\n        if (result % i != 0) {\n            for (j in 1..n) {\n                if ((result * j) % i == 0) {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun sumSquareDifference(n: Int): Int {\n    var sqrSum = 0\n    var numSum = 0\n    for (i in 1..n) {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
                "fun nthPrime(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (primes.size < n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes[primes.size - 1]\n}",
                "fun largestProductInASeries(s: String, k: Int): Int {\n    var result = 0\n    for (i in 0 until s.length - k) {\n        var product = 1\n        for (j in 0 until k) {\n            product *= s[i + j].toInt() - '0'.toInt()\n        }\n        result = maxOf(result, product)\n    }\n    return result\n}",
                "fun specialPythagoreanTriplet(n: Int): Int {\n    for (a in 1 until n) {\n        for (b in a until n) {\n            val c = n - a - b\n            if (a * a + b * b == c * c) {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
                "fun summationOfPrimes(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (i <= n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    var result = 0\n    for (prime in primes) {\n        result += prime\n    }\n    return result\n}",
                "fun largestProductInAGrid(grid: List<List<Int>>): Int {\n    var result = 0\n    for (i in 0 until grid.size - 3) {\n        for (j in 0 until grid[i].size - 3) {\n            var p1 = 1\n            var p2 = 1\n            var p3 = 1\n            var p4 = 1\n            for (k in 0 until 4) {\n                p1 *= grid[i + k][j]\n            }\n            for (k in 0 until 4) {\n                p2 *= grid[i][j + k]\n            }\n            for (k in 0 until 4) {\n                p3 *= grid[i + k][j + k]\n            }\n            for (k in 0 until 4) {\n                p4 *= grid[i + k][j + 3 - k]\n            }\n            result = max(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
                "fun highlyDivisibleTriangularNumber(n: Int): Int {\n    for (i in 1..100000000) {\n        val result = i * (i + 1) / 2\n        var count = 0\n        for (j in 1..Math.sqrt(result.toDouble()).toInt()) {\n            if (result % j == 0) {\n                count += 2\n            }\n            if (j * j == result) {\n                count -= 1\n            }\n        }\n        if (count > n) {\n            return result\n        }\n    }\n    return -1\n}",
                "fun largeSum(numbers: List<String>): String {\n    val digits = IntArray(60)\n    for (i in 0 until 50) {\n        var tmp = 0\n        for (num in numbers) {\n            tmp += num[49 - i] - '0'.toInt()\n        }\n        for (j in i until 60) {\n            digits[j] += tmp % 10\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if (tmp == 0) {\n                break\n            }\n        }\n    }\n    for (i in 59 downTo 0) {\n        if (digits[i] != 0) {\n            var result = \"\"\n            for (j in i downTo i - 10) {\n                result += digits[j].toString()\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
                "fun longestCollatzSequence(n: Int): Int {\n    var longest = 0\n    var result = 0\n    for (i in 1 until n) {\n        var chain = 1\n        var num = i\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num /= 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain++\n        }\n        if (chain > longest) {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
                "fun latticePaths(m: Int, n: Int): Int {\n    val grid = Array(m + 1) { IntArray(n + 1) }\n    for (i in 0..m) {\n        grid[i][0] = 1\n    }\n    for (j in 0..n) {\n        grid[0][j] = 1\n    }\n    for (i in 1..m) {\n        for (j in 1..n) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
                "fun powerDigitSum(n: Int): Int {\n    var digits = mutableListOf(2)\n    for (i in 1 until n) {\n        var carry = 0\n        for (j in 0 until digits.size) {\n            val temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if (carry != 0) {\n            digits.add(carry)\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun numberToWords(n: Int): String {\n    val ones = arrayOf(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val teens = arrayOf(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n    val tens = arrayOf(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n    if (n == 1000) {\n        return \"one thousand\"\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\"\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100)\n        }\n    } else if (n >= 20) {\n        var suf = \"\"\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10]\n        }\n        return tens[n / 10] + suf\n    } else if (n >= 10) {\n        return teens[n - 10]\n    } else {\n        return ones[n]\n    }\n}",
                "fun maximumPathSumI(triangle: List<List<Int>>): Int {\n    var curr = triangle[triangle.size - 1].toMutableList()\n    for (i in triangle.size - 2 downTo 0) {\n        val next = triangle[i].toMutableList()\n        for (j in 0 until next.size) {\n            next[j] += maxOf(curr[j], curr[j + 1])\n        }\n        curr = next\n    }\n    return curr[0]\n}",
                "fun countingSundays(y1: Int, y2: Int): Int {\n    var day = 0\n    var count = 0\n    for (year in 1900..y2) {\n        for (month in 1..12) {\n            if (year >= y1 && day % 7 == 6) {\n                count++\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
                "fun factorialDigitSum(n: Int): Int {\n    var digits = mutableListOf(1)\n    for (i in 1..n) {\n        var carry = 0\n        for (j in 0 until digits.size) {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        while (carry != 0) {\n            digits.add(carry % 10)\n            carry /= 10\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun d(n: Int): Int {\n    var result = 1\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            result += i\n            if (i != n / i) {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfun amicableNumbers(n: Int): Int {\n    var result = 0\n    for (a in 2 until n) {\n        val b = d(a)\n        if (a != b && a == d(b)) {\n            result += a\n        }\n    }\n    return result\n}",
                "fun namesScores(names: List<String>, queries: List<String>): Int {\n    val sNames = names.toMutableList()\n    sNames.sort()\n    var result = 0\n    for (i in sNames.indices) {\n        var x = 0\n        for (c in sNames[i]) {\n            x += c.toInt() - 64\n        }\n        for (query in queries) {\n            if (query == sNames[i]) {\n                result += x * (i + 1)\n                break\n            }\n        }\n    }\n    return result\n}",
                "fun isAbundant(n: Int): Boolean {\n    if (n < 12) {\n        return false\n    }\n    var sumDivisors = 1\n    for (i in 2..n.toDouble().sqrt().toInt()) {\n        if (n % i == 0) {\n            sumDivisors += i\n            if (i != n / i) {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfun nonAbundantSums(n: Int): Int {\n    val abundants = mutableListOf<Int>()\n    for (i in 12 until n) {\n        if (isAbundant(i)) {\n            abundants.add(i)\n        }\n    }\n    val abundantSums = mutableMapOf<Int, Boolean>()\n    for (i in abundants) {\n        for (j in abundants) {\n            abundantSums[i + j] = true\n        }\n    }\n    var result = 0\n    for (i in 0 until n) {\n        if (!abundantSums.containsKey(i)) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun lexicographicPermutations(n: Int): String {\n    val result = StringBuilder()\n    var digits = listOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n    var x = n - 1\n    for (i in 10 downTo 1) {\n        var fact = 1\n        for (j in 1 until i) {\n            fact *= j\n        }\n        val idx = x / fact\n        result.append(digits[idx].toString())\n        digits = digits.subList(0, idx) + digits.subList(idx + 1, digits.size)\n        x -= idx * fact\n    }\n    return result.toString()\n}",
                "fun nDigitFibonacciNumber(n: Int): Int {\n    var a = listOf(1)\n    var b = listOf(1)\n    var i = 2\n    while (b.size < n) {\n        var carry = 0\n        var c = b.toMutableList()\n        for (j in 0 until b.size) {\n            if (j < a.size) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if (carry != 0) {\n            b = b.toMutableList().apply { add(carry) }\n        }\n        a = c.toList()\n        i = i + 1\n    }\n    return i\n}",
                "fun reciprocalCycles(n: Int): Int {\n    var result = 0\n    var maxLength = 0\n    for (i in 1 until n) {\n        val remainders = mutableListOf<Int>()\n        var remainder = 1\n        while (remainder != 0 && !remainders.contains(remainder)) {\n            remainders.add(remainder)\n            remainder = (remainder * 10) % i\n        }\n        var length = 0\n        if (remainder != 0) {\n            length = remainders.size - remainders.indexOf(remainder)\n        }\n        if (length > maxLength) {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun quadraticPrimes(n: Int): Int {\n    var maxPrimes = 0\n    var result = 0\n    for (a in -n + 1..n - 2 step 2) {\n        for (b in -n + 1..n - 2 step 2) {\n            var x = 0\n            while (x * x + a * x + b >= 2) {\n                if (!isPrime(x * x + a * x + b)) {\n                    break\n                }\n                x++\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
                "fun numberSpiralDiagonals(n: Int): Int {\n    var result = 1\n    for (i in 3..n step 2) {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
                "fun distinctPowers(n: Int): Int {\n    var result = 0\n    val xs = mutableMapOf<String, Boolean>()\n    for (i in 2..n) {\n        val primes = listOf(2, 3, 5, 7)\n        val powers = listOf(0, 0, 0, 0)\n        var num = i\n        for (j in 0 until primes.size) {\n            while (num % primes[j] == 0) {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if (num != 1) {\n            result += n - 1\n            continue\n        }\n        for (j in 2..n) {\n            val pstr = \"${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}\"\n            xs[pstr] = true\n        }\n    }\n    result += xs.size\n    return result\n}",
                "fun digitNthPowers(n: Int): Int {\n    var result = 0\n    for (i in 2 until 4 * 10.0.pow(n).toInt()) {\n        var digitsSum = 0\n        for (digit in i.toString()) {\n            digitsSum += digit.toString().toInt().pow(n)\n        }\n        if (i == digitsSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun coinSums(n: Int): Int {\n    val coins = listOf(1, 2, 5, 10, 20, 50, 100, 200)\n    val ways = IntArray(n + 1)\n    ways[0] = 1\n    for (coin in coins) {\n        for (i in coin..n) {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
                "fun pandigitalProducts(n: Int): Int {\n    val products = mutableMapOf<Int, Boolean>()\n    var s = \"\"\n    for (i in 1..n) {\n        s += i.toString()\n    }\n    for (a in 1 until 100) {\n        for (b in 1 until 10000) {\n            val c = a * b\n            val chars = s.toCharArray()\n            chars.sort()\n            if (String(chars) == s) {\n                products[c] = true\n            }\n        }\n    }\n    var result = 0\n    for (product in products.keys) {\n        result += product\n    }\n    return result\n}",
                "fun digitCancelingFractions(m: Int): Int {\n    var numer = 1\n    var denom = 1\n    for (d in 10 until m) {\n        for (n in 10 until d) {\n            val n0 = n % 10\n            val n1 = n / 10\n            val d0 = d % 10\n            val d1 = d / 10\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    var a = numer\n    var b = denom\n    while (b != 0) {\n        val temp = b\n        b = a % b\n        a = temp\n    }\n    return denom / a\n}",
                "fun digitFactorials(n: Int): Int {\n    var result = 0\n    for (i in 3 until n) {\n        var factSum = 0\n        for (digit in i.toString()) {\n            var fact = 1\n            for (j in 1..digit.toInt() - '0'.toInt()) {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if (i == factSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun circularPrimes(n: Int): Int {\n    var count = 0\n    for (i in 2 until n) {\n        if (isPrime(i)) {\n            val rotations = mutableSetOf<Int>()\n            val str = i.toString()\n            for (j in 0 until str.length) {\n                val x = str.substring(j) + str.substring(0, j).toInt()\n                rotations.add(x)\n            }\n            var flag = true\n            for (x in rotations) {\n                if (!isPrime(x)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                count++\n            }\n        }\n    }\n    return count\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i] != s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun doubleBasePalindromes(n: Int): Int {\n    var result = 0\n    for (i in 1 until n) {\n        val strI = i.toString()\n        val binI = i.toString(2)\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun truncatablePrimes(n: Int): Int {\n    var result = 0\n    for (i in 10 until n) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            var flag = true\n            for (j in 1 until si.length) {\n                val p1 = si.substring(j).toInt()\n                val p2 = si.substring(0, si.length - j).toInt()\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                result += i\n            }\n        }\n    }\n    return result\n}",
                "fun pandigitalMultiples(n: Int): Int {\n    var result = -1\n    for (i in 2..n) {\n        var cprod = \"\"\n        for (j in 1..9) {\n            cprod += i * j\n            if (cprod.length == 9) {\n                val chars = cprod.toCharArray()\n                chars.sort()\n                if (chars.joinToString(\"\") == \"123456789\") {\n                    result = max(result, cprod.toInt())\n                    break\n                }\n            } else if (cprod.length > 9) {\n                break\n            }\n        }\n    }\n    return result\n}",
                "fun integerRightTriangles(n: Int): Int {\n    var maxSol = 0\n    var result = 0\n    for (p in 3..n) {\n        var sol = 0\n        for (a in 1 until p / 2) {\n            for (b in a until p / 2) {\n                val c = p - a - b\n                if (a * a + b * b == c * c) {\n                    sol++\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
                "fun champernowneConstant(b: Int): Int {\n    val s = StringBuilder()\n    for (i in 1 until Math.pow(b.toDouble(), 6.0).toInt()) {\n        s.append(i.toString())\n    }\n    var result = 1\n    for (i in 0 until 7) {\n        result *= s[Math.pow(b.toDouble(), i.toDouble()).toInt() - 1].toString().toInt()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun pandigitalPrime(n: Int): Int {\n    for (i in n - 1 downTo 1) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            val length = si.length\n            var flag = true\n            for (j in 1..length) {\n                if (!si.contains(j.toString())) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                return i\n            }\n        }\n    }\n    return -1\n}",
                "fun codedTriangleNumbers(words: List<String>): Int {\n    var result = 0\n    for (word in words) {\n        var value = 0\n        for (c in word) {\n            value += c.toInt() - 64\n        }\n        val n = (Math.sqrt(value * 2.0)).toInt()\n        if (n * (n + 1) == value * 2) {\n            result++\n        }\n    }\n    return result\n}",
                "fun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun subStringDivisibility(n: Int): Int {\n    var result = 0\n    val primes = listOf(2, 3, 5, 7, 11, 13, 17)\n    var s = \"\"\n    for (i in 0..n) {\n        s += i.toString()\n    }\n    for (i in genPermutations(s)) {\n        var flag = true\n        for (j in 1 until n - 1) {\n            if (i.substring(j, j + 3).toInt() % primes[j - 1] != 0) {\n                flag = false\n                break\n            }\n        }\n        if (flag) {\n            result += i.toInt()\n        }\n    }\n    return result\n}",
                "fun pentagonNumbers(n: Int): Int {\n    val pentagon = mutableMapOf<Int, Boolean>()\n    for (i in 1 until n) {\n        pentagon[i * (3 * i - 1) / 2] = true\n    }\n    var result = -1\n    for (j in pentagon.keys) {\n        for (k in pentagon.keys) {\n            if pentagon[j + k] && pentagon[k - j] {\n                if result == -1 || k - j < result {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun triangularPentagonalAndHexagonal(n: Int): Int {\n    val ps = mutableMapOf<Int, Boolean>()\n    var i = 1\n    var c = (0.5 * i * (3 * i - 1)).toInt()\n    while (c < n) {\n        i++\n        ps[c] = true\n        c = (0.5 * i * (3 * i - 1)).toInt()\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    var result = -1\n    while (c < n) {\n        i++\n        if (ps[c]!!) {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun goldbachsOtherConjecture(n: Int): Int {\n    var result = -1\n    for (i in 9999 downTo n) {\n        val upper = Math.sqrt(i / 2.0).toInt()\n        var flag = false\n        for (j in 0..upper) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true\n                break\n            }\n        }\n        if (!flag) {\n            result = i\n        }\n    }\n    return result\n}",
                "fun primeFactors(n: Int): Int {\n    var num = n\n    val factors = mutableListOf<Int>()\n    var i = 2\n    while (i * i <= num) {\n        if (num % i != 0) {\n            i++\n        } else {\n            num /= i\n            factors.add(i)\n        }\n    }\n    if (num > 1) {\n        factors.add(num)\n    }\n    val s = mutableMapOf<Int, Boolean>()\n    for (v in factors) {\n        s[v] = true\n    }\n    return s.size\n}\n\nfun distinctPrimesFactors(n: Int): Int {\n    for (i in n until 1000000) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i\n        }\n    }\n    return -1\n}",
                "fun selfPowers(n: Int): String {\n    val digits = IntArray(10)\n    for (i in 1..n) {\n        val tempDigits = IntArray(10)\n        tempDigits[0] = 1\n        for (j in 0 until i) {\n            var carry = 0\n            for (k in 0 until 10) {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for (j in 0 until 10) {\n            digits[j] += tempDigits[j]\n            if (digits[j] >= 10) {\n                digits[j] -= 10\n                if (j < 9) {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    var result = \"\"\n    for (i in 9 downTo 0) {\n        result += digits[i].toString()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun primePermutations(n: Int): String {\n    for (i in n downTo 999) {\n        if (isPrime(i)) {\n            val permutations = genPermutations(i.toString())\n            val candidates = mutableMapOf<Int, Boolean>()\n            for (j in permutations) {\n                val candidate = j.toInt()\n                if (candidate > i && isPrime(candidate)) {\n                    candidates[candidate] = true\n                }\n            }\n            for (m in candidates.keys) {\n                if (candidates[m + (m - i)]!!) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString()\n                }\n            }\n        }\n    }\n    return \"\"\n}",
                "fun consecutivePrimeSum(limit: Int): Int {\n    val sieve = BooleanArray(limit) { true }\n    val primes = mutableListOf<Int>()\n    for (i in 2 until limit) {\n        if (sieve[i]) {\n            primes.add(i)\n            for (j in i * 2 until limit step i) {\n                sieve[j] = false\n            }\n        }\n    }\n    var maxLength = 0\n    var maxPrime = 0\n    for (i in 0 until primes.size) {\n        for (j in i + maxLength until primes.size) {\n            var s = 0\n            for (k in i until j) {\n                s += primes[k]\n            }\n            if (s >= limit) {\n                break\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
            ],
            "php": [
                "function multiplesOf3And5($n) {\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 3 === 0 || $i % 5 === 0) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function evenFibonacciNumbers($n) {\n    $result = 0;\n    $a = 1;\n    $b = 2;\n    while ($a < $n) {\n        if ($a % 2 === 0) {\n            $result += $a;\n        }\n        $tmp = $a;\n        $a = $b;\n        $b = $tmp + $b;\n    }\n    return $result;\n}",
                "function largestPrimeFactor($n) {\n    $result = $n;\n    $i = 2;\n    while ($i * $i <= $result) {\n        if ($result % $i != 0) {\n            $i += 1;\n        } else {\n            $result /= $i;\n        }\n    }\n    return $result;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i] != $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction largestPalindromeProduct($n) {\n    $result = 0;\n    for ($i = 100; $i < 1000; $i++) {\n        for ($j = $i; $j < 1000; $j++) {\n            $prod = $i * $j;\n            if (isPalindrome(strval($prod)) && $prod > $result && $prod < $n) {\n                $result = $prod;\n            }\n        }\n    }\n    return $result;\n}",
                "function smallestMultiple($n) {\n    $result = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($result % $i != 0) {\n            for ($j = 1; $j <= $n; $j++) {\n                if (($result * $j) % $i == 0) {\n                    $result *= $j;\n                    break;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function sumSquareDifference($n) {\n    $sqrSum = 0;\n    $numSum = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $sqrSum += $i * $i;\n        $numSum += $i;\n    }\n    return $numSum * $numSum - $sqrSum;\n}",
                "function nthPrime($n) {\n    $primes = [2];\n    $i = 3;\n    while (count($primes) < $n) {\n        foreach ($primes as $p) {\n            if ($i % $p == 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    return $primes[count($primes) - 1];\n}",
                "function largestProductInASeries($s, $k) {\n    $result = 0;\n    for ($i = 0; $i < strlen($s) - $k; $i++) {\n        $product = 1;\n        for ($j = 0; $j < $k; $j++) {\n            $product *= intval($s[$i + $j]);\n        }\n        $result = max($result, $product);\n    }\n    return $result;\n}",
                "function specialPythagoreanTriplet($n) {\n    for ($a = 1; $a < $n; $a++) {\n        for ($b = $a; $b < $n; $b++) {\n            $c = $n - $a - $b;\n            if ($a * $a + $b * $b == $c * $c) {\n                return $a * $b * $c;\n            }\n        }\n    }\n    return -1;\n}",
                "function summationOfPrimes($n) {\n    $primes = [2];\n    $i = 3;\n    while ($i <= $n) {\n        foreach ($primes as $p) {\n            if ($i % $p == 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    $result = 0;\n    foreach ($primes as $prime) {\n        $result += $prime;\n    }\n    return $result;\n}",
                "function largestProductInAGrid($grid) {\n    $result = 0;\n    for ($i = 0; $i < count($grid) - 3; $i++) {\n        for ($j = 0; $j < count($grid[$i]) - 3; $j++) {\n            $p1 = 1;\n            $p2 = 1;\n            $p3 = 1;\n            $p4 = 1;\n            for ($k = 0; $k < 4; $k++) {\n                $p1 *= $grid[$i + $k][$j];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p2 *= $grid[$i][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p3 *= $grid[$i + $k][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p4 *= $grid[$i + $k][$j + 3 - $k];\n            }\n            $result = max($result, $p1, $p2, $p3, $p4);\n        }\n    }\n    return $result;\n}",
                "function highlyDivisibleTriangularNumber($n) {\n    for ($i = 1; $i < 100000000; $i++) {\n        $result = $i * ($i + 1) / 2;\n        $count = 0;\n        for ($j = 1; $j <= intval(sqrt($result)); $j++) {\n            if ($result % $j == 0) {\n                $count += 2;\n            }\n            if ($j * $j == $result) {\n                $count -= 1;\n            }\n        }\n        if ($count > $n) {\n            return $result;\n        }\n    }\n    return -1;\n}",
                "function largeSum($numbers) {\n    $digits = array_fill(0, 60, 0);\n    for ($i = 0; $i < 50; $i++) {\n        $tmp = 0;\n        foreach ($numbers as $num) {\n            $tmp += intval($num[49 - $i] - '0');\n        }\n        for ($j = $i; $j < 60; $j++) {\n            $digits[$j] += $tmp % 10;\n            if ($digits[$j] >= 10) {\n                $digits[$j + 1] += $digits[$j] / 10;\n                $digits[$j] %= 10;\n            }\n            $tmp /= 10;\n            if ($tmp == 0) {\n                break;\n            }\n        }\n    }\n    for ($i = 59; $i >= 0; $i--) {\n        if ($digits[$i] != 0) {\n            $result = \"\";\n            for ($j = $i; $j > $i - 10; $j--) {\n                $result .= strval($digits[$j]);\n            }\n            return $result;\n        }\n    }\n    return \"\";\n}",
                "function longestCollatzSequence($n) {\n    $longest = 0;\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $chain = 1;\n        $num = $i;\n        while ($num != 1) {\n            if ($num % 2 == 0) {\n                $num = $num / 2;\n            } else {\n                $num = 3 * $num + 1;\n            }\n            $chain++;\n        }\n        if ($chain > $longest) {\n            $longest = $chain;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function latticePaths($m, $n) {\n    $grid = [];\n    for ($i = 0; $i <= $m; $i++) {\n        $grid[$i] = [];\n        for ($j = 0; $j <= $n; $j++) {\n            $grid[$i][$j] = 0;\n        }\n    }\n    for ($i = 0; $i <= $m; $i++) {\n        $grid[$i][0] = 1;\n    }\n    for ($j = 0; $j <= $n; $j++) {\n        $grid[0][$j] = 1;\n    }\n    for ($i = 1; $i <= $m; $i++) {\n        for ($j = 1; $j <= $n; $j++) {\n            $grid[$i][$j] = $grid[$i - 1][$j] + $grid[$i][$j - 1];\n        }\n    }\n    return $grid[$m][$n];\n}",
                "function powerDigitSum($n) {\n    $digits = [2];\n    for ($i = 1; $i < $n; $i++) {\n        $carry = 0;\n        for ($j = 0; $j < count($digits); $j++) {\n            $temp = $digits[$j] * 2 + $carry;\n            $digits[$j] = $temp % 10;\n            $carry = $temp / 10;\n        }\n        if ($carry != 0) {\n            array_push($digits, $carry);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function numberToWords($n) {\n    $ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    $teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    $tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if ($n == 1000) {\n        return \"one thousand\";\n    } else if ($n >= 100) {\n        if ($n % 100 == 0) {\n            return $ones[$n / 100] . \" hundred\";\n        } else {\n            return $ones[$n / 100] . \" hundred and \" . numberToWords($n % 100);\n        }\n    } else if ($n >= 20) {\n        $suf = \"\";\n        if ($n % 10 != 0) {\n            $suf = \" \" . $ones[$n % 10];\n        }\n        return $tens[$n / 10] . $suf;\n    } else if ($n >= 10) {\n        return $teens[$n - 10];\n    } else {\n        return $ones[$n];\n    }\n}",
                "function maximumPathSumI($triangle) {\n    $curr = array_slice($triangle[count($triangle) - 1], 0);\n    for ($i = count($triangle) - 2; $i >= 0; $i--) {\n        $next = array_slice($triangle[$i], 0);\n        for ($j = 0; $j < count($next); $j++) {\n            $next[$j] += max($curr[$j], $curr[$j + 1]);\n        }\n        $curr = $next;\n    }\n    return $curr[0];\n}",
                "function countingSundays($y1, $y2) {\n    $day = 0;\n    $count = 0;\n    for ($year = 1900; $year <= $y2; $year++) {\n        for ($month = 1; $month <= 12; $month++) {\n            if ($year >= $y1 && $day % 7 == 6) {\n                $count++;\n            }\n            if ($month == 4 || $month == 6 || $month == 9 || $month == 11) {\n                $day += 30;\n            } else if ($month == 2) {\n                if ($year % 4 == 0 && ($year % 100 != 0 || $year % 400 == 0)) {\n                    $day += 29;\n                } else {\n                    $day += 28;\n                }\n            } else {\n                $day += 31;\n            }\n        }\n    }\n    return $count;\n}",
                "function factorialDigitSum($n) {\n    $digits = [1];\n    for ($i = 1; $i <= $n; $i++) {\n        $carry = 0;\n        for ($j = 0; $j < count($digits); $j++) {\n            $digits[$j] = $digits[$j] * $i + $carry;\n            $carry = $digits[$j] / 10;\n            $digits[$j] %= 10;\n        }\n        while ($carry != 0) {\n            array_push($digits, $carry % 10);\n            $carry /= 10;\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function d($n) {\n    $result = 1;\n    for ($i = 2; $i <= intval(sqrt($n)); $i++) {\n        if ($n % $i == 0) {\n            $result += $i;\n            if ($i != $n / $i) {\n                $result += $n / $i;\n            }\n        }\n    }\n    return $result;\n}\n\nfunction amicableNumbers($n) {\n    $result = 0;\n    for ($a = 2; $a < $n; $a++) {\n        $b = d($a);\n        if ($a != $b && $a == d($b)) {\n            $result += $a;\n        }\n    }\n    return $result;\n}",
                "function namesScores($names, $queries) {\n    $sNames = clone($names);\n    sort($sNames);\n    $result = 0;\n    for ($i = 0; $i < count($sNames); $i++) {\n        $name = $sNames[$i];\n        $x = 0;\n        for ($j = 0; $j < strlen($name); $j++) {\n            $c = $name[$j];\n            $x += ord($c) - 64;\n        }\n        for ($j = 0; $j < count($queries); $j++) {\n            $query = $queries[$j];\n            if ($query == $name) {\n                $result += $x * ($i + 1);\n                break;\n            }\n        }\n    }\n    return $result;\n}",
                "function isAbundant($n) {\n    if ($n < 12) {\n        return false;\n    }\n    $sumDivisors = 1;\n    for ($i = 2; $i <= intval(sqrt($n)); $i++) {\n        if ($n % $i == 0) {\n            $sumDivisors += $i;\n            if ($i != $n / $i) {\n                $sumDivisors += $n / $i;\n            }\n        }\n    }\n    return $sumDivisors > $n;\n}\n\nfunction nonAbundantSums($n) {\n    $abundants = [];\n    for ($i = 12; $i < $n; $i++) {\n        if (isAbundant($i)) {\n            array_push($abundants, $i);\n        }\n    }\n    $abundantSums = [];\n    foreach ($abundants as $i) {\n        foreach ($abundants as $j) {\n            $abundantSums[$i + $j] = true;\n        }\n    }\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!isset($abundantSums[$i])) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function lexicographicPermutations($n) {\n    $result = \"\";\n    $digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    $x = $n - 1;\n    for ($i = 10; $i > 0; $i--) {\n        $fact = 1;\n        for ($j = 1; $j < $i; $j++) {\n            $fact *= $j;\n        }\n        $idx = $x / $fact;\n        $result .= strval($digits[$idx]);\n        $digits = array_merge(array_slice($digits, 0, $idx), array_slice($digits, $idx + 1));\n        $x -= $idx * $fact;\n    }\n    return $result;\n}",
                "function nDigitFibonacciNumber($n) {\n    $a = [1];\n    $b = [1];\n    $i = 2;\n    while (count($b) < $n) {\n        $carry = 0;\n        $c = [];\n        for ($j = 0; $j < count($b); $j++) {\n            if ($j < count($a)) {\n                $b[$j] = $a[$j] + $b[$j] + $carry;\n            } else {\n                $b[$j] = $b[$j] + $carry;\n            }\n            $carry = $b[$j] / 10;\n            $b[$j] = $b[$j] % 10;\n        }\n        if ($carry != 0) {\n            $b = array_merge($b, [$carry]);\n        }\n        $a = [];\n        for ($j = 0; $j < count($c); $j++) {\n            array_push($a, $c[$j]);\n        }\n        $i = $i + 1;\n    }\n    return $i;\n}",
                "function reciprocalCycles($n) {\n    $result = 0;\n    $maxLength = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $remainders = [];\n        $remainder = 1;\n        while ($remainder != 0 && !in_array($remainder, $remainders)) {\n            array_push($remainders, $remainder);\n            $remainder = ($remainder * 10) % $i;\n        }\n        $length = 0;\n        if ($remainder != 0) {\n            $length = count($remainders) - array_search($remainder, $remainders);\n        }\n        if ($length > $maxLength) {\n            $maxLength = $length;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction quadraticPrimes($n) {\n    $maxPrimes = 0;\n    $result = 0;\n    for ($a = -$n + 1; $a < $n; $a += 2) {\n        for ($b = -$n + 1; $b < $n; $b += 2) {\n            $x = 0;\n            while (true) {\n                if ($x * $x + $a * $x + $b < 2) {\n                    break;\n                }\n                if (!isPrime($x * $x + $a * $x + $b)) {\n                    break;\n                }\n                $x++;\n            }\n            if ($x > $maxPrimes) {\n                $maxPrimes = $x;\n                $result = $a * $b;\n            }\n        }\n    }\n    return $result;\n}",
                "function numberSpiralDiagonals($n) {\n    $result = 1;\n    for ($i = 3; $i <= $n; $i += 2) {\n        $result += 4 * $i * $i - 6 * $i + 6;\n    }\n    return $result;\n}",
                "function distinctPowers($n) {\n    $result = 0;\n    $xs = [];\n    for ($i = 2; $i <= $n; $i++) {\n        $primes = [2, 3, 5, 7];\n        $powers = [0, 0, 0, 0];\n        $num = $i;\n        for ($j = 0; $j < count($primes); $j++) {\n            while ($num % $primes[$j] == 0) {\n                $num /= $primes[$j];\n                $powers[$j] += 1;\n            }\n        }\n        if ($num != 1) {\n            $result += $n - 1;\n            continue;\n        }\n        for ($j = 2; $j <= $n; $j++) {\n            $pstr = sprintf(\"%d-%d-%d-%d\", $powers[0] * $j, $powers[1] * $j, $powers[2] * $j, $powers[3] * $j);\n            $xs[$pstr] = true;\n        }\n    }\n    $result += count($xs);\n    return $result;\n}",
                "function digitNthPowers($n) {\n    $result = 0;\n    for ($i = 2; $i < 4 * pow(10, $n); $i++) {\n        $digitsSum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $digitsSum += pow(intval($digit), $n);\n        }\n        if ($i == $digitsSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function coinSums($n) {\n    $coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    $ways = array_fill(0, $n + 1, 0);\n    $ways[0] = 1;\n    foreach ($coins as $coin) {\n        for ($i = $coin; $i <= $n; $i++) {\n            $ways[$i] += $ways[$i - $coin];\n        }\n    }\n    return $ways[$n];\n}",
                "function pandigitalProducts($n) {\n    $products = [];\n    $s = \"\";\n    for ($i = 1; $i <= $n; $i++) {\n        $s .= strval($i);\n    }\n    for ($a = 1; $a < 100; $a++) {\n        for ($b = 1; $b < 10000; $b++) {\n            $c = $a * $b;\n            $chars = str_split(strval($a) . strval($b) . strval($c));\n            sort($chars);\n            if (implode($chars) == $s) {\n                $products[$c] = true;\n            }\n        }\n    }\n    $result = 0;\n    foreach ($products as $product) {\n        $result += $product;\n    }\n    return $result;\n}",
                "function digitCancelingFractions($m) {\n    $numer = 1;\n    $denom = 1;\n    for ($d = 10; $d < $m; $d++) {\n        for ($n = 10; $n < $d; $n++) {\n            $n0 = $n % 10;\n            $n1 = $n / 10;\n            $d0 = $d % 10;\n            $d1 = $d / 10;\n            if (($n1 == $d0 && $n0 * $d == $n * $d1) || ($n0 == $d1 && $n1 * $d == $n * $d0)) {\n                $numer *= $n;\n                $denom *= $d;\n            }\n        }\n    }\n    $a = $numer;\n    $b = $denom;\n    while ($b != 0) {\n        $temp = $b;\n        $b = $a % $b;\n        $a = $temp;\n    }\n    return $denom / $a;\n}",
                "function digitFactorials($n) {\n    $result = 0;\n    for ($i = 3; $i < $n; $i++) {\n        $factSum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $fact = 1;\n            for ($j = 1; $j <= intval($digit); $j++) {\n                $fact *= $j;\n            }\n            $factSum += $fact;\n        }\n        if ($i == $factSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction circularPrimes($n) {\n    $count = 0;\n    for ($i = 2; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $rotations = [];\n            $str = strval($i);\n            for ($j = 0; $j < strlen($str); $j++) {\n                $x = intval(substr($str, $j) . substr($str, 0, $j));\n                $rotations[$x] = true;\n            }\n            $flag = true;\n            foreach ($rotations as $x) {\n                if (!isPrime($x)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i] != $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction doubleBasePalindromes($n) {\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $strI = strval($i);\n        $binI = strval(decbin($i));\n        if (isPalindrome($strI) && isPalindrome($binI)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction truncatablePrimes($n) {\n    $result = 0;\n    for ($i = 10; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $flag = true;\n            for ($j = 1; $j < strlen($si); $j++) {\n                $p1 = intval(substr($si, $j));\n                $p2 = intval(substr($si, 0, strlen($si) - $j));\n                if (!isPrime($p1) || !isPrime($p2)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $result += $i;\n            }\n        }\n    }\n    return $result;\n}",
                "function pandigitalMultiples($n) {\n    $result = -1;\n    for ($i = 2; $i <= $n; $i++) {\n        $cprod = \"\";\n        for ($j = 1; $j < 10; $j++) {\n            $cprod .= strval($i * $j);\n            if (strlen($cprod) == 9) {\n                $chars = str_split($cprod);\n                sort($chars);\n                if (implode($chars, \"\") == \"123456789\") {\n                    $cprodInt = intval($cprod);\n                    $result = max($result, $cprodInt);\n                    break;\n                }\n            } else if (strlen($cprod) > 9) {\n                break;\n            }\n        }\n    }\n    return $result;\n}",
                "function integerRightTriangles($n) {\n    $maxSol = 0;\n    $result = 0;\n    for ($p = 3; $p <= $n; $p++) {\n        $sol = 0;\n        for ($a = 1; $a < $p / 2; $a++) {\n            for ($b = $a; $b < $p / 2; $b++) {\n                $c = $p - $a - $b;\n                if ($a * $a + $b * $b == $c * $c) {\n                    $sol++;\n                }\n            }\n        }\n        if ($sol > $maxSol) {\n            $maxSol = $sol;\n            $result = $p;\n        }\n    }\n    return $result;\n}",
                "function champernowneConstant($b) {\n    $s = \"\";\n    for ($i = 1; $i < intval(pow($b, 6)); $i++) {\n        $s .= strval($i);\n    }\n    $result = 1;\n    for ($i = 0; $i < 7; $i++) {\n        $n = intval(substr($s, intval(pow($b, $i)) - 1, 1));\n        $result *= $n;\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction pandigitalPrime($n) {\n    for ($i = $n - 1; $i > 0; $i--) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $length = strlen($si);\n            $flag = true;\n            for ($j = 1; $j <= $length; $j++) {\n                if (!str_contains($si, strval($j))) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                return $i;\n            }\n        }\n    }\n    return -1;\n}",
                "function codedTriangleNumbers($words) {\n    $result = 0;\n    foreach ($words as $word) {\n        $value = 0;\n        for ($i = 0; $i < strlen($word); $i++) {\n            $value += ord($word[$i]) - 64;\n        }\n        $n = intval(sqrt($value * 2));\n        if ($n * ($n + 1) == $value * 2) {\n            $result++;\n        }\n    }\n    return $result;\n}",
                "function genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return [$s];\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, substr($perm, 0, $i) . $s[0] . substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction subStringDivisibility($n) {\n    $result = 0;\n    $primes = [2, 3, 5, 7, 11, 13, 17];\n    $s = \"\";\n    for ($i = 0; $i <= $n; $i++) {\n        $s .= strval($i);\n    }\n    foreach (genPermutations($s) as $i) {\n        $flag = true;\n        for ($j = 1; $j < $n - 1; $j++) {\n            if ($n, _ = strval(substr($i, $j, 3)); $n % $primes[$j - 1] != 0) {\n                $flag = false;\n                break;\n            }\n        }\n        if ($flag) {\n            $s0, _ = strval($i);\n            $result += $s0;\n        }\n    }\n    return $result;\n}",
                "function pentagonNumbers($n) {\n    $pentagon = [];\n    for ($i = 1; $i < $n; $i++) {\n        $pentagon[intval($i * (3 * $i - 1) / 2)] = true;\n    }\n    $result = -1;\n    foreach ($pentagon as $j => $v) {\n        foreach ($pentagon as $k => $v) {\n            if ($pentagon[$j + $k] && $pentagon[$k - $j]) {\n                if ($result == -1 || $k - $j < $result) {\n                    $result = $k - $j;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function triangularPentagonalAndHexagonal($n) {\n    $ps = [];\n    $i = 1;\n    $c = intval(0.5 * floatval($i) * (3 * floatval($i) - 1));\n    while ($c < $n) {\n        $i++;\n        $ps[$c] = true;\n        $c = intval(0.5 * floatval($i) * (3 * floatval($i) - 1));\n    }\n    $i = 1;\n    $c = $i * (2 * $i - 1);\n    $result = -1;\n    while ($c < $n) {\n        $i++;\n        if (isset($ps[$c])) {\n            $result = $c;\n        }\n        $c = $i * (2 * $i - 1);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n / 2)); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction goldbachsOtherConjecture($n) {\n    $result = -1;\n    for ($i = 9999; $i > $n; $i -= 2) {\n        $upper = intval(sqrt($i / 2));\n        $flag = false;\n        for ($j = 0; $j <= $upper; $j++) {\n            if (isPrime($i - 2 * $j * $j)) {\n                $flag = true;\n                break;\n            }\n        }\n        if (!$flag) {\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function primeFactors($n) {\n    $num = $n;\n    $factors = [];\n    $i = 2;\n    while ($i * $i <= $num) {\n        if ($num % $i != 0) {\n            $i++;\n        } else {\n            $num /= $i;\n            array_push($factors, $i);\n        }\n    }\n    if ($num > 1) {\n        array_push($factors, $num);\n    }\n    $s = [];\n    foreach ($factors as $v) {\n        $s[$v] = true;\n    }\n    return count($s);\n}\n\nfunction distinctPrimesFactors($n) {\n    for ($i = $n; $i < 1000000; $i++) {\n        if (primeFactors($i) == 4 && primeFactors($i + 1) == 4 && primeFactors($i + 2) == 4 && primeFactors($i + 3) == 4) {\n            return $i;\n        }\n    }\n    return -1;\n}",
                "function selfPowers($n) {\n    $digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for ($i = 1; $i <= $n; $i++) {\n        $tempDigits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        $tempDigits[0] = 1;\n        for ($j = 0; $j < $i; $j++) {\n            $carry = 0;\n            for ($k = 0; $k < 10; $k++) {\n                $tempDigits[$k] = $tempDigits[$k] * $i + $carry;\n                $carry = $tempDigits[$k] / 10;\n                $tempDigits[$k] %= 10;\n            }\n        }\n        for ($j = 0; $j < 10; $j++) {\n            $digits[$j] += $tempDigits[$j];\n            if ($digits[$j] >= 10) {\n                $digits[$j] -= 10;\n                if ($j < 9) {\n                    $digits[$j + 1] += 1;\n                }\n            }\n        }\n    }\n    $result = \"\";\n    for ($i = 9; $i >= 0; $i--) {\n        $result .= strval($digits[$i]);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return [$s];\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, substr($perm, 0, $i) . $s[0] . substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction primePermutations($n) {\n    for ($i = $n; $i > 999; $i--) {\n        if (isPrime($i)) {\n            $permutations = genPermutations(strval($i));\n            $candidates = [];\n            foreach ($permutations as $j) {\n                $candidate = intval($j);\n                if ($candidate > $i && isPrime($candidate)) {\n                    $candidates[$candidate] = true;\n                }\n            }\n            foreach ($candidates as $m) {\n                if ($candidates[$m + ($m - $i)]) {\n                    return strval($i) . strval($m) . strval($m + ($m - $i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "function consecutivePrimeSum($limit) {\n    $sieve = array_fill(0, $limit, true);\n    $primes = [];\n    for ($i = 2; $i < $limit; $i++) {\n        if ($sieve[$i]) {\n            array_push($primes, $i);\n            for ($j = $i * 2; $j < $limit; $j += $i) {\n                $sieve[$j] = false;\n            }\n        }\n    }\n    $maxLength = 0;\n    $maxPrime = 0;\n    for ($i = 0; $i < count($primes); $i++) {\n        for ($j = $i + $maxLength; $j < count($primes); $j++) {\n            $s = 0;\n            for ($k = $i; $k < $j; $k++) {\n                $s += $primes[$k];\n            }\n            if ($s >= $limit) {\n                break;\n            }\n            if ($sieve[$s] && $j - $i > $maxLength) {\n                $maxLength = $j - $i;\n                $maxPrime = $s;\n            }\n        }\n    }\n    return $maxPrime;\n}"
            ],
            "python": [
                "def multiples_of_3_and_5(n: int) -> int:\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result",
                "def even_fibonacci_numbers(n: int) -> int:\n    result = 0\n    a = 1\n    b = 2\n    while a < n:\n        if a % 2 == 0:\n            result += a\n        tmp = a\n        a = b\n        b = tmp + b\n    return result",
                "def largest_prime_factor(n: int) -> int:\n    result = n\n    i = 2\n    while i * i <= result:\n        if result % i != 0:\n            i += 1\n        else:\n            result //= i\n    return result",
                "def is_palindrome(s: str) -> bool:\n    for i in range(0, len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True\n\ndef largest_palindrome_product(n: int) -> int:\n    result = 0\n    for i in range(100, 1000):\n        for j in range(i, 1000):\n            prod = i * j\n            if is_palindrome(str(prod)) and prod > result and prod < n:\n                result = prod\n    return result",
                "def smallest_multiple(n: int) -> int:\n    result = 1\n    for i in range(1, n + 1):\n        if result % i != 0:\n            for j in range(1, n + 1):\n                if (result * j) % i == 0:\n                    result *= j\n                    break\n    return result",
                "def sum_square_difference(n: int) -> int:\n    sqr_sum = 0\n    num_sum = 0\n    for i in range(1, n + 1):\n        sqr_sum += i * i\n        num_sum += i\n    return num_sum * num_sum - sqr_sum",
                "def nth_prime(n: int) -> int:\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for p in primes:\n            if i % p == 0:\n                break\n            if p * p > i:\n                primes.append(i)\n                break\n        i += 2\n    return primes[len(primes) - 1]",
                "def largest_product_in_a_series(s: str, k: int) -> int:\n    result = 0\n    for i in range(0, len(s) - k):\n        product = 1\n        for j in range(0, k):\n            product *= int(s[i + j] - '0')\n        result = max(result, product)\n    return result",
                "def special_pythagorean_triplet(n: int) -> int:\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - a - b\n            if a * a + b * b == c * c:\n                return a * b * c\n    return -1",
                "def summation_of_primes(n: int) -> int:\n    primes = [2]\n    i = 3\n    while i <= n:\n        for p in primes:\n            if i % p == 0:\n                break\n            if p * p > i:\n                primes.append(i)\n                break\n        i += 2\n    result = 0\n    for prime in primes:\n        result += prime\n    return result",
                "def largest_product_in_a_grid(grid: list[list[int]]) -> int:\n    result = 0\n    for i in range(0, len(grid) - 3):\n        for j in range(0, len(grid[i]) - 3):\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            for k in range(0, 4):\n                p1 *= grid[i + k][j]\n            for k in range(0, 4):\n                p2 *= grid[i][j + k]\n            for k in range(0, 4):\n                p3 *= grid[i + k][j + k]\n            for k in range(0, 4):\n                p4 *= grid[i + k][j + 3 - k]\n            result = max(result, p1, p2, p3, p4)\n    return result",
                "def highly_divisible_triangular_number(n: int) -> int:\n    for i in range(1, 100000000):\n        result = i * (i + 1) // 2\n        count = 0\n        for j in range(1, int(math.sqrt(result)) + 1):\n            if result % j == 0:\n                count += 2\n            if j * j == result:\n                count -= 1\n        if count > n:\n            return result\n    return -1",
                "def large_sum(numbers: list[str]) -> str:\n    digits = [0] * 60\n    for i in range(0, 50):\n        tmp = 0\n        for num in numbers:\n            tmp += int(num[49 - i] - '0')\n        for j in range(i, 60):\n            digits[j] += tmp % 10\n            if digits[j] >= 10:\n                digits[j + 1] += digits[j] // 10\n                digits[j] %= 10\n            tmp //= 10\n            if tmp == 0:\n                break\n    for i in range(59, 0, -1):\n        if digits[i] != 0:\n            result = \"\"\n            for j in range(i, i - 10, -1):\n                result += str(digits[j])\n            return result\n    return \"\"",
                "def longest_collatz_sequence(n: int) -> int:\n    longest = 0\n    result = 0\n    for i in range(1, n):\n        chain = 1\n        num = i\n        while num != 1:\n            if num % 2 == 0:\n                num = num / 2\n            else:\n                num = 3 * num + 1\n            chain += 1\n        if chain > longest:\n            longest = chain\n            result = i\n    return result",
                "def lattice_paths(m: int, n: int) -> int:\n    grid = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        grid[i][0] = 1\n    for j in range(1, n + 1):\n        grid[0][j] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n    return grid[m][n]",
                "def power_digit_sum(n: int) -> int:\n    digits = [2]\n    for i in range(1, n):\n        carry = 0\n        for j in range(len(digits)):\n            temp = digits[j]*2 + carry\n            digits[j] = temp % 10\n            carry = temp // 10\n        if carry != 0:\n            digits.append(carry)\n    result = 0\n    for digit in digits:\n        result += digit\n    return result",
                "def number_to_words(n: int) -> str:\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000:\n        return \"one thousand\"\n    elif n >= 100:\n        if n % 100 == 0:\n            return ones[n // 100] + \" hundred\"\n        else:\n            return ones[n // 100] + \" hundred and \" + number_to_words(n % 100)\n    elif n >= 20:\n        suf = \"\"\n        if n % 10 != 0:\n            suf = \" \" + ones[n % 10]\n        return tens[n // 10] + suf\n    elif n >= 10:\n        return teens[n - 10]\n    else:\n        return ones[n]",
                "def maximum_path_sum_i(triangle: list[list[int]]) -> int:\n    curr = triangle[len(triangle) - 1].copy()\n    for i in range(len(triangle) - 2, -1, -1):\n        next = triangle[i].copy()\n        for j in range(len(next)):\n            next[j] += max(curr[j], curr[j + 1])\n        curr = next\n    return curr[0]",
                "def counting_sundays(y1: int, y2: int) -> int:\n    day = 0\n    count = 0\n    for year in range(1900, y2 + 1):\n        for month in range(1, 13):\n            if year >= y1 and day % 7 == 6:\n                count += 1\n            if month == 4 or month == 6 or month == 9 or month == 11:\n                day += 30\n            elif month == 2:\n                if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n                    day += 29\n                else:\n                    day += 28\n            else:\n                day += 31\n    return count",
                "def factorial_digit_sum(n: int) -> int:\n    digits = [1]\n    for i in range(1, n + 1):\n        carry = 0\n        for j in range(len(digits)):\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] // 10\n            digits[j] %= 10\n        while carry != 0:\n            digits.append(carry % 10)\n            carry //= 10\n    result = 0\n    for digit in digits:\n        result += digit\n    return result",
                "def d(n: int) -> int:\n    result = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef amicable_numbers(n: int) -> int:\n    result = 0\n    for a in range(2, n):\n        b = d(a)\n        if a != b and a == d(b):\n            result += a\n    return result",
                "def names_scores(names: list[str], queries: list[str]) -> int:\n    sNames = slices.clone(names)\n    slices.sort(sNames)\n    result = 0\n    for i, name in enumerate(sNames):\n        x = 0\n        for c in name:\n            x += ord(c) - 64\n        for query in queries:\n            if query == name:\n                result += x * (i + 1)\n                break\n    return result",
                "def is_abundant(n: int) -> bool:\n    if n < 12:\n        return False\n    sumDivisors = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            sumDivisors += i\n            if i != n // i:\n                sumDivisors += n // i\n    return sumDivisors > n\n\ndef non_abundant_sums(n: int) -> int:\n    abundants = []\n    for i in range(12, n):\n        if is_abundant(i):\n            abundants.append(i)\n    abundantSums = {i + j for i in abundants for j in abundants}\n    result = 0\n    for i in range(n):\n        if i not in abundantSums:\n            result += i\n    return result",
                "def lexicographic_permutations(n: int) -> str:\n    result = \"\"\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    for i in range(10, 0, -1):\n        fact = 1\n        for j in range(1, i):\n            fact *= j\n        idx = x // fact\n        result += str(digits[idx])\n        digits = digits[:idx] + digits[idx+1:]\n        x -= idx * fact\n    return result",
                "def n_digit_fibonacci_number(n: int) -> int:\n    a = [1]\n    b = [1]\n    i = 2\n    while len(b) < n:\n        carry = 0\n        c = b.copy()\n        for j in range(len(b)):\n            if j < len(a):\n                b[j] = a[j] + b[j] + carry\n            else:\n                b[j] = b[j] + carry\n            carry = b[j] // 10\n            b[j] = b[j] % 10\n        if carry != 0:\n            b.append(carry)\n        a = c.copy()\n        i = i + 1\n    return i",
                "def reciprocal_cycles(n: int) -> int:\n    result = 0\n    max_length = 0\n    for i in range(1, n):\n        remainders = []\n        remainder = 1\n        while remainder != 0 and remainder not in remainders:\n            remainders.append(remainder)\n            remainder = (remainder * 10) % i\n        length = 0\n        if remainder != 0:\n            length = len(remainders) - remainders.index(remainder)\n        if length > max_length:\n            max_length = length\n            result = i\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef quadratic_primes(n: int) -> int:\n    max_primes = 0\n    result = 0\n    for a in range(-n + 1, n, 2):\n        for b in range(-n + 1, n, 2):\n            x = 0\n            while x*x+a*x+b < 2:\n                if not is_prime(x*x+a*x+b):\n                    break\n                x += 1\n            if x > max_primes:\n                max_primes = x\n                result = a * b\n    return result",
                "def number_spiral_diagonals(n: int) -> int:\n    result = 1\n    for i in range(3, n + 1, 2):\n        result += 4 * i * i - 6 * i + 6\n    return result",
                "def distinct_powers(n: int) -> int:\n    result = 0\n    xs = {}\n    for i in range(2, n + 1):\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        for j in range(len(primes)):\n            while num % primes[j] == 0:\n                num //= primes[j]\n                powers[j] += 1\n        if num != 1:\n            result += n - 1\n            continue\n        for j in range(2, n + 1):\n            pstr = f\"{powers[0] * j}-{powers[1] * j}-{powers[2] * j}-{powers[3] * j}\"\n            xs[pstr] = True\n    result += len(xs)\n    return result",
                "def digit_nth_powers(n: int) -> int:\n    result = 0\n    for i in range(2, 4 * int(math.pow(10, float(n)))):\n        digitsSum = 0\n        for digit in str(i):\n            digitInt = int(digit)\n            digitsSum += int(math.pow(float(digitInt), float(n)))\n        if i == digitsSum:\n            result += i\n    return result",
                "def coin_sums(n: int) -> int:\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    for coin in coins:\n        for i in range(coin, n + 1):\n            ways[i] += ways[i - coin]\n    return ways[n]",
                "def pandigital_products(n: int) -> int:\n    products = {}\n    s = \"\"\n    for i in range(1, n + 1):\n        s += str(i)\n    for a in range(1, 100):\n        for b in range(1, 10000):\n            c = a * b\n            chars = list(str(a) + str(b) + str(c))\n            chars.sort()\n            if \"\".join(chars) == s:\n                products[c] = True\n    result = 0\n    for product in products:\n        result += product\n    return result",
                "def digit_canceling_fractions(m: int) -> int:\n    numer = 1\n    denom = 1\n    for d in range(10, m):\n        for n in range(10, d):\n            n0 = n % 10\n            n1 = n // 10\n            d0 = d % 10\n            d1 = d // 10\n            if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0):\n                numer *= n\n                denom *= d\n    a = numer\n    b = denom\n    while b != 0:\n        temp = b\n        b = a % b\n        a = temp\n    return denom // a",
                "def digit_factorials(n: int) -> int:\n    result = 0\n    for i in range(3, n):\n        factSum = 0\n        for digit in str(i):\n            fact = 1\n            for j in range(1, int(digit) - 48):\n                fact *= j\n            factSum += fact\n        if i == factSum:\n            result += i\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef circular_primes(n: int) -> int:\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            rotations = set()\n            str = str(i)\n            for j in range(len(str)):\n                x = int(str[j:] + str[:j])\n                rotations.add(x)\n            flag = True\n            for x in rotations:\n                if not is_prime(x):\n                    flag = False\n                    break\n            if flag:\n                count += 1\n    return count",
                "def is_palindrome(s: str) -> bool:\n    for i in range(0, len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True\n\ndef double_base_palindromes(n: int) -> int:\n    result = 0\n    for i in range(1, n):\n        strI = str(i)\n        binI = bin(i)[2:]\n        if is_palindrome(strI) and is_palindrome(binI):\n            result += i\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef truncatable_primes(n: int) -> int:\n    result = 0\n    for i in range(10, n):\n        if is_prime(i):\n            si = str(i)\n            flag = True\n            for j in range(1, len(si)):\n                p1 = int(si[j:])\n                p2 = int(si[:len(si) - j])\n                if not is_prime(p1) or not is_prime(p2):\n                    flag = False\n                    break\n            if flag:\n                result += i\n    return result",
                "def pandigital_multiples(n: int) -> int:\n    result = -1\n    for i in range(2, n + 1):\n        cprod = \"\"\n        for j in range(1, 10):\n            cprod += str(i * j)\n            if len(cprod) == 9:\n                chars = cprod.split(\"\")\n                chars.sort()\n                if \"\".join(chars) == \"123456789\":\n                    cprod_int = int(cprod)\n                    result = max(result, cprod_int)\n                    break\n            elif len(cprod) > 9:\n                break\n    return result",
                "def integer_right_triangles(n: int) -> int:\n    max_sol = 0\n    result = 0\n    for p in range(3, n + 1):\n        sol = 0\n        for a in range(1, p // 2):\n            for b in range(a, p // 2):\n                c = p - a - b\n                if a * a + b * b == c * c:\n                    sol += 1\n        if sol > max_sol:\n            max_sol = sol\n            result = p\n    return result",
                "def champernowne_constant(b: int) -> int:\n    s = \"\"\n    for i in range(1, int(math.pow(float(b), 6))):\n        s += str(i)\n    result = 1\n    for i in range(0, 7):\n        n = int(s[int(math.pow(float(b), float(i))) - 1])\n        result *= n\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef pandigital_prime(n: int) -> int:\n    for i in range(n - 1, 1, -1):\n        if is_prime(i):\n            si = str(i)\n            length = len(si)\n            flag = True\n            for j in range(1, length + 1):\n                if str(j) not in si:\n                    flag = False\n                    break\n            if flag:\n                return i\n    return -1",
                "def coded_triangle_numbers(words: list[str]) -> int:\n    result = 0\n    for word in words:\n        value = 0\n        for c in word:\n            value += ord(c) - 64\n        n = int(math.sqrt(value * 2))\n        if n * (n + 1) == value * 2:\n            result += 1\n    return result",
                "def gen_permutations(s: str) -> list[str]:\n    if len(s) <= 1:\n        return [s]\n    result = []\n    for perm in gen_permutations(s[1:]):\n        for i in range(len(s)):\n            result.append(perm[:i] + s[0] + perm[i:])\n    return result\n\ndef sub_string_divisibility(n: int) -> int:\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = \"\"\n    for i in range(n + 1):\n        s += str(i)\n    for i in gen_permutations(s):\n        flag = True\n        for j in range(1, n - 1):\n            if int(i[j:j + 3]) % primes[j - 1] != 0:\n                flag = False\n                break\n        if flag:\n            s0 = int(i)\n            result += s0\n    return result",
                "def pentagon_numbers(n: int) -> int:\n    pentagon = {}\n    for i in range(1, n):\n        pentagon[i * (3 * i - 1) // 2] = True\n    result = -1\n    for j in pentagon:\n        for k in pentagon:\n            if pentagon[j + k] and pentagon[k - j]:\n                if result == -1 or k - j < result:\n                    result = k - j\n    return result",
                "def triangular_pentagonal_and_hexagonal(n: int) -> int:\n    ps = {}\n    i = 1\n    c = int(0.5 * float(i) * (3 * float(i) - 1))\n    while c < n:\n        i += 1\n        ps[c] = True\n        c = int(0.5 * float(i) * (3 * float(i) - 1))\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n:\n        i += 1\n        if ps[c]:\n            result = c\n        c = i * (2 * i - 1)\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef goldbachs_other_conjecture(n: int) -> int:\n    result = -1\n    for i in range(9999, n - 1, -2):\n        upper = int(math.sqrt(i / 2))\n        flag = False\n        for j in range(upper + 1):\n            if is_prime(i - 2 * j * j):\n                flag = True\n                break\n        if not flag:\n            result = i\n    return result",
                "def prime_factors(n: int) -> int:\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num:\n        if num % i != 0:\n            i += 1\n        else:\n            num //= i\n            factors.append(i)\n    if num > 1:\n        factors.append(num)\n    s = {v: True for v in factors}\n    return len(s)\n\ndef distinct_primes_factors(n: int) -> int:\n    for i in range(n, 1000000):\n        if prime_factors(i) == 4 and prime_factors(i + 1) == 4 and prime_factors(i + 2) == 4 and prime_factors(i + 3) == 4:\n            return i\n    return -1",
                "def self_powers(n: int) -> str:\n    digits = [0] * 10\n    for i in range(1, n + 1):\n        temp_digits = [0] * 10\n        temp_digits[0] = 1\n        for j in range(0, i):\n            carry = 0\n            for k in range(0, 10):\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] // 10\n                temp_digits[k] %= 10\n        for j in range(0, 10):\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10:\n                digits[j] -= 10\n                if j < 9:\n                    digits[j + 1] += 1\n    result = \"\"\n    for i in range(9, -1, -1):\n        result += str(digits[i])\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef gen_permutations(s: str) -> list[str]:\n    if len(s) <= 1:\n        return [s]\n    result = []\n    for perm in gen_permutations(s[1:]):\n        for i in range(len(s)):\n            result.append(perm[:i] + s[0] + perm[i:])\n    return result\n\ndef prime_permutations(n: int) -> str:\n    for i in range(n, 999, -1):\n        if is_prime(i):\n            permutations = gen_permutations(str(i))\n            candidates = {}\n            for j in permutations:\n                candidate = int(j)\n                if candidate > i and is_prime(candidate):\n                    candidates[candidate] = True\n            for m in candidates:\n                if candidates[m + (m - i)]:\n                    return str(i) + str(m) + str(m + (m - i))\n    return \"\"",
                "def consecutive_prime_sum(limit: int) -> int:\n    sieve = [True] * limit\n    primes = []\n    for i in range(2, limit):\n        if sieve[i]:\n            primes.append(i)\n            for j in range(i * 2, limit, i):\n                sieve[j] = False\n    max_length = 0\n    max_prime = 0\n    for i in range(len(primes)):\n        for j in range(i + max_length, len(primes)):\n            s = sum(primes[i:j])\n            if s >= limit:\n                break\n            if sieve[s] and j - i > max_length:\n                max_length = j - i\n                max_prime = s\n    return max_prime"
            ],
            "ruby": [
                "def multiples_of_3_and_5(n)\n    result = 0\n    (0...n).each do |i|\n        if i % 3 == 0 || i % 5 == 0\n            result += i\n        end\n    end\n    result\nend",
                "def even_fibonacci_numbers(n)\n    result = 0\n    a = 1\n    b = 2\n    while a < n\n        if a % 2 == 0\n            result += a\n        end\n        tmp = a\n        a = b\n        b = tmp + b\n    end\n    result\nend",
                "def largest_prime_factor(n)\n    result = n\n    i = 2\n    while i * i <= result\n        if result % i != 0\n            i += 1\n        else\n            result /= i\n        end\n    end\n    result\nend",
                "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        return false if s[i] != s[-i - 1]\n    end\n    true\nend\n\ndef largest_palindrome_product(n)\n    result = 0\n    (100...1000).each do |i|\n        (i...1000).each do |j|\n            prod = i * j\n            if is_palindrome(prod.to_s) && prod > result && prod < n\n                result = prod\n            end\n        end\n    end\n    result\nend",
                "def smallest_multiple(n)\n    result = 1\n    (1..n).each do |i|\n        if result % i != 0\n            (1..n).each do |j|\n                if (result * j) % i == 0\n                    result *= j\n                    break\n                end\n            end\n        end\n    end\n    result\nend",
                "def sum_square_difference(n)\n    sqrSum = 0\n    numSum = 0\n    (1..n).each do |i|\n        sqrSum += i * i\n        numSum += i\n    end\n    numSum * numSum - sqrSum\nend",
                "def nth_prime(n)\n    primes = [2]\n    i = 3\n    while primes.length < n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    primes[primes.length - 1]\nend",
                "def largest_product_in_a_series(s, k)\n    result = 0\n    (0...s.length - k).each do |i|\n        product = 1\n        (0...k).each do |j|\n            product *= s[i + j].to_i\n        end\n        result = [result, product].max\n    end\n    result\nend",
                "def special_pythagorean_triplet(n)\n    (1...n).each do |a|\n        (a...n).each do |b|\n            c = n - a - b\n            return a * b * c if a * a + b * b == c * c\n        end\n    end\n    -1\nend",
                "def summation_of_primes(n)\n    primes = [2]\n    i = 3\n    while i <= n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    result = 0\n    primes.each do |prime|\n        result += prime\n    end\n    result\nend",
                "def largest_product_in_a_grid(grid)\n    result = 0\n    (0...grid.length - 3).each do |i|\n        (0...grid[i].length - 3).each do |j|\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            (0...4).each do |k|\n                p1 *= grid[i + k][j]\n            end\n            (0...4).each do |k|\n                p2 *= grid[i][j + k]\n            end\n            (0...4).each do |k|\n                p3 *= grid[i + k][j + k]\n            end\n            (0...4).each do |k|\n                p4 *= grid[i + k][j + 3 - k]\n            end\n            result = [result, p1, p2, p3, p4].max\n        end\n    end\n    result\nend",
                "def highly_divisible_triangular_number(n)\n    for i in 1..100000000\n        result = i * (i + 1) / 2\n        count = 0\n        for j in 1..Math.sqrt(result).to_i\n            if result % j == 0\n                count += 2\n            end\n            if j * j == result\n                count -= 1\n            end\n        end\n        if count > n\n            return result\n        end\n    end\n    return -1\nend",
                "def large_sum(numbers)\n    digits = Array.new(60, 0)\n    (0...50).each do |i|\n        tmp = 0\n        numbers.each do |num|\n            tmp += num[49 - i].ord - '0'.ord\n        end\n        (i...60).each do |j|\n            digits[j] += tmp % 10\n            if digits[j] >= 10\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            end\n            tmp /= 10\n            if tmp == 0\n                break\n            end\n        end\n    end\n    (59...0).each do |i|\n        if digits[i] != 0\n            result = \"\"\n            (i...i - 10).each do |j|\n                result += digits[j].to_s\n            end\n            return result\n        end\n    end\n    \"\"\nend",
                "def longest_collatz_sequence(n)\n    longest = 0\n    result = 0\n    (1...n).each do |i|\n        chain = 1\n        num = i\n        while num != 1\n            if num % 2 == 0\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end\n            chain += 1\n        end\n        if chain > longest\n            longest = chain\n            result = i\n        end\n    end\n    result\nend",
                "def lattice_paths(m, n)\n    grid = Array.new(m + 1) { Array.new(n + 1, 0) }\n    (0...m + 1).each do |i|\n        grid[i][0] = 1\n    end\n    (0...n + 1).each do |j|\n        grid[0][j] = 1\n    end\n    (1...m + 1).each do |i|\n        (1...n + 1).each do |j|\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        end\n    end\n    grid[m][n]\nend",
                "def power_digit_sum(n)\n    digits = [2]\n    (1...n).each do |i|\n        carry = 0\n        (0...digits.length).each do |j|\n            temp = digits[j]*2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        end\n        if carry != 0\n            digits.push(carry)\n        end\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def number_to_words(n)\n    ones = %w( \"\" one two three four five six seven eight nine )\n    teens = %w( ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen )\n    tens = %w( \"\" \"\" twenty thirty forty fifty sixty seventy eighty ninety )\n    if n == 1000\n        return \"one thousand\"\n    elsif n >= 100\n        if n % 100 == 0\n            return ones[n / 100] + \" hundred\"\n        else\n            return ones[n / 100] + \" hundred and \" + number_to_words(n % 100)\n        end\n    elsif n >= 20\n        suf = \"\"\n        if n % 10 != 0\n            suf = \" \" + ones[n % 10]\n        end\n        return tens[n / 10] + suf\n    elsif n >= 10\n        return teens[n - 10]\n    else\n        return ones[n]\n    end\nend",
                "def maximum_path_sum_i(triangle)\n    curr = triangle.last.dup\n    (triangle.length - 2).downto(0).each do |i|\n        next = triangle[i].dup\n        (0...next.length).each do |j|\n            next[j] += [curr[j], curr[j + 1]].max\n        end\n        curr = next\n    end\n    curr[0]\nend",
                "def counting_sundays(y1, y2)\n    day = 0\n    count = 0\n    (1900..y2).each do |year|\n        (1..12).each do |month|\n            if year >= y1 && day % 7 == 6\n                count += 1\n            end\n            if month == 4 || month == 6 || month == 9 || month == 11\n                day += 30\n            elsif month == 2\n                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)\n                    day += 29\n                else\n                    day += 28\n                end\n            else\n                day += 31\n            end\n        end\n    end\n    count\nend",
                "def factorial_digit_sum(n)\n    digits = [1]\n    (1...n).each do |i|\n        carry = 0\n        (0...digits.length).each do |j|\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        end\n        while carry != 0\n            digits.push(carry % 10)\n            carry /= 10\n        end\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def d(n)\n    result = 1\n    (2...Math.sqrt(n).to_i).each do |i|\n        if n % i == 0\n            result += i\n            if i != n / i\n                result += n / i\n            end\n        end\n    end\n    result\nend\n\ndef amicable_numbers(n)\n    result = 0\n    (2...n).each do |a|\n        b = d(a)\n        if a != b && a == d(b)\n            result += a\n        end\n    end\n    result\nend",
                "def names_scores(names, queries)\n    sNames = names.clone\n    sNames.sort!\n    result = 0\n    sNames.each_with_index do |name, i|\n        x = 0\n        name.each_char do |c|\n            x += c.ord - 64\n        end\n        queries.each do |query|\n            if query == name\n                result += x * (i + 1)\n                break\n            end\n        end\n    end\n    result\nend",
                "def is_abundant(n)\n    return false if n < 12\n    sumDivisors = 1\n    (2...(n**0.5)).each do |i|\n        if n % i == 0\n            sumDivisors += i\n            sumDivisors += n / i if i != n / i\n        end\n    end\n    sumDivisors > n\nend\n\ndef non_abundant_sums(n)\n    abundants = []\n    (12...n).each do |i|\n        abundants.push(i) if is_abundant(i)\n    end\n    abundantSums = {}\n    abundants.each do |i|\n        abundants.each do |j|\n            abundantSums[i + j] = true\n        end\n    end\n    result = 0\n    (0...n).each do |i|\n        result += i unless abundantSums[i]\n    end\n    result\nend",
                "def lexicographic_permutations(n)\n    result = \"\"\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    (10...1).each do |i|\n        fact = 1\n        (1...i).each do |j|\n            fact *= j\n        end\n        idx = x / fact\n        result += idx.to_s\n        digits = digits[0...idx] + digits[idx+1..-1]\n        x -= idx * fact\n    end\n    result\nend",
                "def n_digit_fibonacci_number(n)\n    a = [1]\n    b = [1]\n    i = 2\n    while b.length < n\n        carry = 0\n        c = b.dup\n        b.length.times do |j|\n            if j < a.length\n                b[j] = a[j] + b[j] + carry\n            else\n                b[j] = b[j] + carry\n            end\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        end\n        if carry != 0\n            b.push(carry)\n        end\n        a = c.dup\n        i = i + 1\n    end\n    i\nend",
                "def reciprocal_cycles(n)\n    result = 0\n    max_length = 0\n    (1...n).each do |i|\n        remainders = []\n        remainder = 1\n        while remainder != 0 && !remainders.include?(remainder)\n            remainders.push(remainder)\n            remainder = (remainder * 10) % i\n        end\n        length = 0\n        if remainder != 0\n            length = remainders.length - remainders.index(remainder)\n        end\n        if length > max_length\n            max_length = length\n            result = i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef quadratic_primes(n)\n    maxPrimes = 0\n    result = 0\n    (-n+1..n-1).step(2).each do |a|\n        (-n+1..n-1).step(2).each do |b|\n            x = 0\n            loop do\n                break if x*x+a*x+b < 2\n                break if !is_prime(x*x+a*x+b)\n                x += 1\n            end\n            if x > maxPrimes\n                maxPrimes = x\n                result = a * b\n            end\n        end\n    end\n    result\nend",
                "def number_spiral_diagonals(n)\n    result = 1\n    (3...n).step(2).each do |i|\n        result += 4 * i * i - 6 * i + 6\n    end\n    result\nend",
                "def distinct_powers(n)\n    result = 0\n    xs = {}\n    (2..n).each do |i|\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        (0...primes.length).each do |j|\n            while num % primes[j] == 0\n                num /= primes[j]\n                powers[j] += 1\n            end\n        end\n        if num != 1\n            result += n - 1\n            next\n        end\n        (2..n).each do |j|\n            pstr = \"#{powers[0] * j}-#{powers[1] * j}-#{powers[2] * j}-#{powers[3] * j}\"\n            xs[pstr] = true\n        end\n    end\n    result += xs.length\n    result\nend",
                "def digit_nth_powers(n)\n    result = 0\n    (2...(4 * 10**n)).each do |i|\n        digitsSum = 0\n        i.to_s.each_char do |digit|\n            digitsSum += digit.to_i**n\n        end\n        if i == digitsSum\n            result += i\n        end\n    end\n    result\nend",
                "def coin_sums(n)\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = Array.new(n + 1, 0)\n    ways[0] = 1\n    coins.each do |coin|\n        (coin...n + 1).each do |i|\n            ways[i] += ways[i - coin]\n        end\n    end\n    ways[n]\nend",
                "def pandigital_products(n)\n    products = {}\n    s = \"\"\n    (1..n).each do |i|\n        s += i.to_s\n    end\n    (1..99).each do |a|\n        (1..9999).each do |b|\n            c = a * b\n            chars = (a.to_s + b.to_s + c.to_s).chars.sort\n            if chars.join == s\n                products[c] = true\n            end\n        end\n    end\n    result = 0\n    products.each do |product|\n        result += product\n    end\n    result\nend",
                "def digit_canceling_fractions(m)\n    numer = 1\n    denom = 1\n    for d in 10...m do\n        for n in 10...d do\n            n0 = n % 10\n            n1 = n / 10\n            d0 = d % 10\n            d1 = d / 10\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)\n                numer *= n\n                denom *= d\n            end\n        end\n    end\n    a = numer\n    b = denom\n    while b != 0 do\n        temp = b\n        b = a % b\n        a = temp\n    end\n    denom / a\nend",
                "def digit_factorials(n)\n    result = 0\n    (3...n).each do |i|\n        factSum = 0\n        i.to_s.each_char do |digit|\n            fact = 1\n            (1...digit.to_i).each do |j|\n                fact *= j\n            end\n            factSum += fact\n        end\n        if i == factSum\n            result += i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef circular_primes(n)\n    count = 0\n    (2...n).each do |i|\n        if is_prime(i)\n            rotations = {}\n            str = i.to_s\n            (0...str.length).each do |j|\n                x = str[j..-1] + str[0...j]\n                rotations[x.to_i] = true\n            end\n            flag = true\n            rotations.each do |x|\n                flag = false if !is_prime(x)\n                break if !flag\n            end\n            count += 1 if flag\n        end\n    end\n    count\nend",
                "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        return false if s[i] != s[-i - 1]\n    end\n    true\nend\n\ndef double_base_palindromes(n)\n    result = 0\n    (1...n).each do |i|\n        strI = i.to_s\n        binI = i.to_s(2)\n        result += i if is_palindrome(strI) && is_palindrome(binI)\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef truncatable_primes(n)\n    result = 0\n    (10...n).each do |i|\n        if is_prime(i)\n            si = i.to_s\n            flag = true\n            (1...si.length).each do |j|\n                p1 = si[j..-1].to_i\n                p2 = si[0...si.length - j].to_i\n                if !is_prime(p1) || !is_prime(p2)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                result += i\n            end\n        end\n    end\n    result\nend",
                "def pandigital_multiples(n)\n    result = -1\n    (2..n).each do |i|\n        cprod = \"\"\n        (1..9).each do |j|\n            cprod += i * j\n            if cprod.length == 9\n                chars = cprod.split(\"\")\n                chars.sort!\n                if chars.join(\"\") == \"123456789\"\n                    result = [result, cprod.to_i].max\n                    break\n                end\n            elsif cprod.length > 9\n                break\n            end\n        end\n    end\n    result\nend",
                "def integer_right_triangles(n)\n    max_sol = 0\n    result = 0\n    (3..n).each do |p|\n        sol = 0\n        (1...(p / 2)).each do |a|\n            (a...(p / 2)).each do |b|\n                c = p - a - b\n                if a * a + b * b == c * c\n                    sol += 1\n                end\n            end\n        end\n        if sol > max_sol\n            max_sol = sol\n            result = p\n        end\n    end\n    result\nend",
                "def champernowne_constant(b)\n    s = \"\"\n    (1...(b**6)).each do |i|\n        s += i.to_s\n    end\n    result = 1\n    (0...7).each do |i|\n        n = s[b**i - 1].to_i\n        result *= n\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    for i in 3..Math.sqrt(n).to_i\n        return false if n % i == 0\n    end\n    true\nend\n\ndef pandigital_prime(n)\n    for i in n - 1..1\n        if is_prime(i)\n            si = i.to_s\n            length = si.length\n            flag = true\n            for j in 1..length\n                flag = false if !si.include?(j.to_s)\n                break if !flag\n            end\n            return i if flag\n        end\n    end\n    -1\nend",
                "def coded_triangle_numbers(words)\n    result = 0\n    words.each do |word|\n        value = 0\n        word.each_char do |c|\n            value += c.ord - 64\n        end\n        n = Math.sqrt(value * 2).to_i\n        if n * (n + 1) == value * 2\n            result += 1\n        end\n    end\n    result\nend",
                "def gen_permutations(s)\n    if s.length <= 1\n        return [s]\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef sub_string_divisibility(n)\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = \"\"\n    (0...n + 1).each do |i|\n        s += i.to_s\n    end\n    gen_permutations(s).each do |i|\n        flag = true\n        (1...n - 1).each do |j|\n            if i[j, 3].to_i % primes[j - 1] != 0\n                flag = false\n                break\n            end\n        end\n        if flag\n            result += i.to_i\n        end\n    end\n    result\nend",
                "def pentagon_numbers(n)\n    pentagon = {}\n    (1...n).each do |i|\n        pentagon[i * (3 * i - 1) / 2] = true\n    end\n    result = -1\n    pentagon.each do |j, _|\n        pentagon.each do |k, _|\n            if pentagon[j + k] && pentagon[k - j]\n                if result == -1 || k - j < result\n                    result = k - j\n                end\n            end\n        end\n    end\n    result\nend",
                "def triangular_pentagonal_and_hexagonal(n)\n    ps = {}\n    i = 1\n    c = (0.5 * i * (3 * i - 1)).to_i\n    while c < n\n        i += 1\n        ps[c] = true\n        c = (0.5 * i * (3 * i - 1)).to_i\n    end\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n\n        i += 1\n        if ps[c]\n            result = c\n        end\n        c = i * (2 * i - 1)\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef goldbachs_other_conjecture(n)\n    result = -1\n    (9999...n).step(-2).each do |i|\n        upper = Math.sqrt(i / 2).to_i\n        flag = false\n        (0...upper).each do |j|\n            if is_prime(i - 2 * j * j)\n                flag = true\n                break\n            end\n        end\n        result = i if !flag\n    end\n    result\nend",
                "def prime_factors(n)\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num\n        if num % i != 0\n            i += 1\n        else\n            num /= i\n            factors.push(i)\n        end\n    end\n    if num > 1\n        factors.push(num)\n    end\n    s = {}\n    factors.each do |v|\n        s[v] = true\n    end\n    s.length\nend\n\ndef distinct_primes_factors(n)\n    for i in n..1_000_000\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4\n            return i\n        end\n    end\n    -1\nend",
                "def self_powers(n)\n    digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    (1..n).each do |i|\n        temp_digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        temp_digits[0] = 1\n        (0...i).each do |j|\n            carry = 0\n            (0...10).each do |k|\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] / 10\n                temp_digits[k] %= 10\n            end\n        end\n        (0...10).each do |j|\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10\n                digits[j] -= 10\n                if j < 9\n                    digits[j + 1] += 1\n                end\n            end\n        end\n    end\n    result = \"\"\n    (9...0).each do |i|\n        result += i.to_s\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    for i in 3..Math.sqrt(n).to_i\n        return false if n % i == 0\n    end\n    true\nend\n\ndef gen_permutations(s)\n    return [s] if s.length <= 1\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef prime_permutations(n)\n    for i in n..999\n        if is_prime(i)\n            permutations = gen_permutations(i.to_s)\n            candidates = {}\n            permutations.each do |j|\n                candidate = j.to_i\n                if candidate > i && is_prime(candidate)\n                    candidates[candidate] = true\n                end\n            end\n            candidates.each do |m, _|\n                if candidates[m + (m - i)]\n                    return i.to_s + m.to_s + (m + (m - i)).to_s\n                end\n            end\n        end\n    end\n    \"\"\nend",
                "def consecutive_prime_sum(limit)\n    sieve = []\n    limit.times do |i|\n        sieve.push(true)\n    end\n    primes = []\n    (2...limit).each do |i|\n        if sieve[i]\n            primes.push(i)\n            (i * 2).step(limit, i).each do |j|\n                sieve[j] = false\n            end\n        end\n    end\n    maxLength = 0\n    maxPrime = 0\n    (0...primes.length).each do |i|\n        (i + maxLength).step(primes.length, 1).each do |j|\n            s = 0\n            (i...j).each do |k|\n                s += primes[k]\n            end\n            if s >= limit\n                break\n            end\n            if sieve[s] && j - i > maxLength\n                maxLength = j - i\n                maxPrime = s\n            end\n        end\n    end\n    maxPrime\nend"
            ],
            "rust": [
                "fn multiples_of_3_and_5(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..n {\n        if i % 3 == 0 || i % 5 == 0 {\n            result += i;\n        }\n    }\n    result\n}",
                "fn even_fibonacci_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut a = 1;\n    let mut b = 2;\n    while a < n {\n        if a % 2 == 0 {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    result\n}",
                "fn largest_prime_factor(n: i32) -> i32 {\n    let mut result = n;\n    let mut i = 2;\n    while i * i <= result {\n        if result % i != 0 {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    result\n}",
                "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s.chars().nth(i).unwrap() != s.chars().nth(s.len() - i - 1).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n\nfn largest_palindrome_product(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 100..1000 {\n        for j in i..1000 {\n            let prod = i * j;\n            if is_palindrome(&prod.to_string()) && prod > result && prod < n {\n                result = prod;\n            }\n        }\n    }\n    result\n}",
                "fn smallest_multiple(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 1..=n {\n        if result % i != 0 {\n            for j in 1..=n {\n                if (result * j) % i == 0 {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn sum_square_difference(n: i32) -> i32 {\n    let mut sqr_sum = 0;\n    let mut num_sum = 0;\n    for i in 1..=n {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    num_sum * num_sum - sqr_sum\n}",
                "fn nth_prime(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while primes.len() < n as usize {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    primes[primes.len() - 1]\n}",
                "fn largest_product_in_a_series(s: &String, k: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..s.len() - k as usize {\n        let mut product = 1;\n        for j in 0..k as usize {\n            product *= (s.chars().nth(i + j).unwrap() as u8 - '0' as u8) as i32;\n        }\n        result = std::cmp::max(result, product);\n    }\n    result\n}",
                "fn special_pythagorean_triplet(n: i32) -> i32 {\n    for a in 1..n {\n        for b in a..n {\n            let c = n - a - b;\n            if a * a + b * b == c * c {\n                return a * b * c;\n            }\n        }\n    }\n    -1\n}",
                "fn summation_of_primes(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while i <= n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let mut result = 0;\n    for prime in &primes {\n        result += prime;\n    }\n    result\n}",
                "fn largest_product_in_a_grid(grid: &Vec<Vec<i32>>) -> i32 {\n    let mut result = 0;\n    for i in 0..grid.len() - 3 {\n        for j in 0..grid[i].len() - 3 {\n            let mut p1 = 1;\n            let mut p2 = 1;\n            let mut p3 = 1;\n            let mut p4 = 1;\n            for k in 0..4 {\n                p1 *= grid[i + k][j];\n            }\n            for k in 0..4 {\n                p2 *= grid[i][j + k];\n            }\n            for k in 0..4 {\n                p3 *= grid[i + k][j + k];\n            }\n            for k in 0..4 {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = std::cmp::max(result, p1, p2, p3, p4);\n        }\n    }\n    result\n}",
                "fn highly_divisible_triangular_number(n: i32) -> i32 {\n    for i in 1..100000000 {\n        let result = i * (i + 1) / 2;\n        let mut count = 0;\n        for j in 1..(result as f64).sqrt() as i32 {\n            if result % j == 0 {\n                count += 2;\n            }\n            if j * j == result {\n                count -= 1;\n            }\n        }\n        if count > n {\n            return result;\n        }\n    }\n    -1\n}",
                "fn large_sum(numbers: &Vec<String>) -> String {\n    let mut digits = vec![0; 60];\n    for i in 0..50 {\n        let mut tmp = 0;\n        for num in numbers {\n            tmp += (num.chars().nth(49 - i).unwrap() as u8 - '0' as u8) as i32;\n        }\n        for j in i..60 {\n            digits[j] += tmp % 10;\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if tmp == 0 {\n                break;\n            }\n        }\n    }\n    for i in (0..60).rev() {\n        if digits[i] != 0 {\n            let mut result = String::new();\n            for j in i..(i - 10).max(0) {\n                result.push_str(&(digits[j] as u8 + '0' as u8).to_string());\n            }\n            return result;\n        }\n    }\n    \"\".to_string()\n}",
                "fn longest_collatz_sequence(n: i32) -> i32 {\n    let mut longest = 0;\n    let mut result = 0;\n    for i in 1..n {\n        let mut chain = 1;\n        let mut num = i;\n        while num != 1 {\n            if num % 2 == 0 {\n                num /= 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if chain > longest {\n            longest = chain;\n            result = i;\n        }\n    }\n    result\n}",
                "fn lattice_paths(m: i32, n: i32) -> i32 {\n    let mut grid = vec![vec![0; n as usize + 1]; m as usize + 1];\n    for i in 0..=m {\n        grid[i][0] = 1;\n    }\n    for j in 0..=n {\n        grid[0][j] = 1;\n    }\n    for i in 1..=m {\n        for j in 1..=n {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    grid[m as usize][n as usize]\n}",
                "fn power_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![2];\n    for i in 1..n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if carry != 0 {\n            digits.push(carry);\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
                "fn number_to_words(n: i32) -> String {\n    let ones = vec![\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = vec![\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = vec![\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if n == 1000 {\n        return \"one thousand\".to_string();\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n / 100].to_string() + \" hundred\";\n        } else {\n            return ones[n / 100].to_string() + \" hundred and \" + number_to_words(n % 100);\n        }\n    } else if n >= 20 {\n        let suf = if n % 10 != 0 {\n            \" \" + &ones[n % 10]\n        } else {\n            \"\".to_string()\n        };\n        return tens[n / 10].to_string() + suf;\n    } else if n >= 10 {\n        return teens[n - 10].to_string();\n    } else {\n        return ones[n].to_string();\n    }\n}",
                "fn maximum_path_sum_i(triangle: &Vec<Vec<i32>>) -> i32 {\n    let mut curr = triangle[triangle.len() - 1].clone();\n    for i in (0..triangle.len() - 1).rev() {\n        let mut next = triangle[i].clone();\n        for j in 0..next.len() {\n            next[j] += std::cmp::max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    curr[0]\n}",
                "fn counting_sundays(y1: i32, y2: i32) -> i32 {\n    let mut day = 0;\n    let mut count = 0;\n    for year in 1900..=y2 {\n        for month in 1..=12 {\n            if year >= y1 && day % 7 == 6 {\n                count += 1;\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30;\n            } else if month == 2 {\n                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    count\n}",
                "fn factorial_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![1];\n    for i in 1..=n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while carry != 0 {\n            digits.push(carry % 10);\n            carry /= 10;\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
                "fn d(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 2..=n.sqrt() as i32 {\n        if n % i == 0 {\n            result += i;\n            if i != n / i {\n                result += n / i;\n            }\n        }\n    }\n    result\n}\n\nfn amicable_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    for a in 2..n {\n        let b = d(a);\n        if a != b && a == d(b) {\n            result += a;\n        }\n    }\n    result\n}",
                "fn names_scores(names: &Vec<String>, queries: &Vec<String>) -> i32 {\n    let mut s_names = names.clone();\n    s_names.sort();\n    let mut result = 0;\n    for i in 0..s_names.len() {\n        let mut x = 0;\n        for c in s_names[i].chars() {\n            x += c as i32 - 64;\n        }\n        for query in queries {\n            if query == &s_names[i] {\n                result += x * (i + 1);\n                break;\n            }\n        }\n    }\n    result\n}",
                "fn is_abundant(n: i32) -> bool {\n    if n < 12 {\n        return false;\n    }\n    let mut sum_divisors = 1;\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            sum_divisors += i;\n            if i != n / i {\n                sum_divisors += n / i;\n            }\n        }\n    }\n    sum_divisors > n\n}\n\nfn non_abundant_sums(n: i32) -> i32 {\n    let mut abundants = Vec::new();\n    for i in 12..n {\n        if is_abundant(i) {\n            abundants.push(i);\n        }\n    }\n    let mut abundant_sums = HashMap::new();\n    for i in abundants {\n        for j in abundants {\n            abundant_sums.insert(i + j, true);\n        }\n    }\n    let mut result = 0;\n    for i in 0..n {\n        if !abundant_sums.contains_key(&i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn lexicographic_permutations(n: i32) -> String {\n    let mut result = String::new();\n    let mut digits = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut x = n - 1;\n    for i in (1..10).rev() {\n        let mut fact = 1;\n        for j in 1..i {\n            fact *= j;\n        }\n        let idx = x / fact;\n        result.push_str(&idx.to_string());\n        digits = digits[..idx].to_vec().append(&mut digits[idx+1..].to_vec()).to_vec();\n        x -= idx * fact;\n    }\n    result\n}",
                "fn n_digit_fibonacci_number(n: i32) -> i32 {\n    let mut a = vec![1];\n    let mut b = vec![1];\n    let mut i = 2;\n    while b.len() < n as usize {\n        let mut carry = 0;\n        let mut c = Vec::new();\n        for j in 0..b.len() {\n            if j < a.len() {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if carry != 0 {\n            b.push(carry);\n        }\n        a = Vec::new();\n        for j in 0..c.len() {\n            a.push(c[j]);\n        }\n        i = i + 1;\n    }\n    i\n}",
                "fn reciprocal_cycles(n: i32) -> i32 {\n    let mut result = 0;\n    let mut max_length = 0;\n    for i in 1..n {\n        let mut remainders = Vec::new();\n        let mut remainder = 1;\n        while remainder != 0 && !remainders.contains(&remainder) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = if remainder != 0 {\n            remainders.len() - remainders.iter().position(|&x| x == remainder).unwrap()\n        } else {\n            0\n        };\n        if length > max_length {\n            max_length = length;\n            result = i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn quadratic_primes(n: i32) -> i32 {\n    let mut max_primes = 0;\n    let mut result = 0;\n    for a in (-n + 1)..n {\n        for b in (-n + 1)..n {\n            let mut x = 0;\n            loop {\n                if x * x + a * x + b < 2 {\n                    break;\n                }\n                if !is_prime(x * x + a * x + b) {\n                    break;\n                }\n                x += 1;\n            }\n            if x > max_primes {\n                max_primes = x;\n                result = a * b;\n            }\n        }\n    }\n    result\n}",
                "fn number_spiral_diagonals(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 3..=n {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    result\n}",
                "fn distinct_powers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut xs = std::collections::HashMap::new();\n    for i in 2..=n {\n        let mut primes = vec![2, 3, 5, 7];\n        let mut powers = vec![0, 0, 0, 0];\n        let mut num = i;\n        for j in 0..primes.len() {\n            while num % primes[j] == 0 {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if num != 1 {\n            result += n - 1;\n            continue;\n        }\n        for j in 2..=n {\n            let pstr = format!(\"{}-{}-{}-{}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n            xs.insert(pstr, true);\n        }\n    }\n    result += xs.len() as i32;\n    result\n}",
                "fn digit_nth_powers(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 2..4 * (10 as i32).pow(n) {\n        let mut digits_sum = 0;\n        for digit in i.to_string().chars() {\n            let digit_int = digit.to_string().parse::<i32>().unwrap();\n            digits_sum += digit_int.pow(n as u32);\n        }\n        if i == digits_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn coin_sums(n: i32) -> i32 {\n    let coins = vec![1, 2, 5, 10, 20, 50, 100, 200];\n    let mut ways = vec![0; n as usize + 1];\n    ways[0] = 1;\n    for coin in coins {\n        for i in coin..=n {\n            ways[i as usize] += ways[(i - coin) as usize];\n        }\n    }\n    ways[n as usize]\n}",
                "fn pandigital_products(n: i32) -> i32 {\n    let mut products = HashMap::new();\n    let mut s = String::new();\n    for i in 1..n {\n        s.push_str(&i.to_string());\n    }\n    for a in 1..100 {\n        for b in 1..10000 {\n            let c = a * b;\n            let mut chars: Vec<char> = s.chars().collect();\n            chars.sort();\n            if chars.iter().collect::<String>() == s {\n                products.insert(c, true);\n            }\n        }\n    }\n    let mut result = 0;\n    for product in products.keys() {\n        result += product;\n    }\n    result\n}",
                "fn digit_canceling_fractions(m: i32) -> i32 {\n    let mut numer = 1;\n    let mut denom = 1;\n    for d in 10..m {\n        for n in 10..d {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let mut a = numer;\n    let mut b = denom;\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    denom / a\n}",
                "fn digit_factorials(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 3..n {\n        let mut fact_sum = 0;\n        for digit in i.to_string().chars() {\n            let mut fact = 1;\n            for j in 1..(digit as i32 - '0' as i32) {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if i == fact_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn circular_primes(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 2..n {\n        if is_prime(i) {\n            let mut rotations = std::collections::HashSet::new();\n            let str = i.to_string();\n            for j in 0..str.len() {\n                let x = str[j..].parse::<i32>().unwrap() + str[..j].parse::<i32>().unwrap();\n                rotations.insert(x);\n            }\n            let mut flag = true;\n            for x in rotations {\n                if !is_prime(x) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
                "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s.chars().nth(i).unwrap() != s.chars().nth(s.len() - i - 1).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n\nfn double_base_palindromes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 1..n {\n        let str_i = i.to_string();\n        let bin_i = format!(\"{:b}\", i);\n        if is_palindrome(&str_i) && is_palindrome(&bin_i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn truncatable_primes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 10..n {\n        if is_prime(i) {\n            si := i.to_string();\n            flag := true;\n            for j in 1..si.len() {\n                p1 := si[j..].parse::<i32>().unwrap();\n                p2 := si[..si.len() - j].parse::<i32>().unwrap();\n                if !is_prime(p1) || !is_prime(p2) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                result += i;\n            }\n        }\n    }\n    result\n}",
                "fn pandigital_multiples(n: i32) -> i32 {\n    let mut result = -1;\n    for i in 2..n {\n        let mut cprod = String::new();\n        for j in 1..10 {\n            cprod.push_str(&(i * j).to_string());\n            if cprod.len() == 9 {\n                let mut chars: Vec<&str> = cprod.split(\"\").collect();\n                chars.sort();\n                if chars.join(\"\") == \"123456789\" {\n                    result = max(result, cprod.parse::<i32>().unwrap());\n                    break;\n                }\n            } else if cprod.len() > 9 {\n                break;\n            }\n        }\n    }\n    result\n}",
                "fn integer_right_triangles(n: i32) -> i32 {\n    let mut max_sol = 0;\n    let mut result = 0;\n    for p in 3..=n {\n        let mut sol = 0;\n        for a in 1..(p / 2) {\n            for b in a..(p / 2) {\n                let c = p - a - b;\n                if a * a + b * b == c * c {\n                    sol += 1;\n                }\n            }\n        }\n        if sol > max_sol {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    result\n}",
                "fn champernowne_constant(b: i32) -> i32 {\n    let mut s = String::new();\n    for i in 1..(b as f64).powi(6) {\n        s.push_str(&i.to_string());\n    }\n    let mut result = 1;\n    for i in 0..7 {\n        result *= s[((b as f64).powi(i) - 1) as usize].to_digit(b as u32).unwrap() as i32;\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn pandigital_prime(n: i32) -> i32 {\n    for i in (n - 1)..1 {\n        if is_prime(i) {\n            si := i.to_string();\n            length := si.len();\n            flag := true;\n            for j in 1..=length {\n                if !si.contains(j.to_string().as_str()) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                return i;\n            }\n        }\n    }\n    -1\n}",
                "fn coded_triangle_numbers(words: &Vec<String>) -> i32 {\n    let mut result = 0;\n    for word in words {\n        let mut value = 0;\n        for c in word.chars() {\n            value += c as i32 - 64;\n        }\n        let n = (value as f64).sqrt() as i32;\n        if n * (n + 1) == value * 2 {\n            result += 1;\n        }\n    }\n    result\n}",
                "fn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.to_string()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn sub_string_divisibility(n: i32) -> i32 {\n    let mut result = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut s = String::new();\n    for i in 0..=n {\n        s.push_str(&i.to_string());\n    }\n    for i in gen_permutations(&s) {\n        let mut flag = true;\n        for j in 1..n - 1 {\n            if i[j..j + 3].parse::<i32>().unwrap() % primes[j - 1] != 0 {\n                flag = false;\n                break;\n            }\n        }\n        if flag {\n            result += i.parse::<i32>().unwrap();\n        }\n    }\n    result\n}",
                "fn pentagon_numbers(n: i32) -> i32 {\n    let mut pentagon = HashMap::new();\n    for i in 1..n {\n        pentagon.insert(i * (3 * i - 1) / 2, true);\n    }\n    let mut result = -1;\n    for j in pentagon.keys() {\n        for k in pentagon.keys() {\n            if pentagon.contains_key(&(j + k)) && pentagon.contains_key(&(k - j)) {\n                if result == -1 || k - j < result {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn triangular_pentagonal_and_hexagonal(n: i32) -> i32 {\n    let mut ps = HashMap::new();\n    let mut i = 1;\n    let mut c = (i as f64 / 2.0) * (3.0 * (i as f64) - 1.0) as i32;\n    while c < n {\n        i += 1;\n        ps.insert(c, true);\n        c = (i as f64 / 2.0) * (3.0 * (i as f64) - 1.0) as i32;\n    }\n    let mut i = 1;\n    let mut c = i * (2 * i - 1);\n    let mut result = -1;\n    while c < n {\n        i += 1;\n        if ps.contains_key(&c) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn goldbachs_other_conjecture(n: i32) -> i32 {\n    let mut result = -1;\n    for i in (9999..=n).step_by(2) {\n        let upper = ((i as f64).sqrt() as i32);\n        let mut flag = false;\n        for j in 0..=upper {\n            if is_prime(i - 2 * j * j) {\n                flag = true;\n                break;\n            }\n        }\n        if !flag {\n            result = i;\n        }\n    }\n    result\n}",
                "fn prime_factors(n: i32) -> i32 {\n    let mut num = n;\n    let mut factors = Vec::new();\n    let mut i = 2;\n    while i * i <= num {\n        if num % i != 0 {\n            i += 1;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if num > 1 {\n        factors.push(num);\n    }\n    let mut s = HashMap::new();\n    for v in factors {\n        s.insert(v, true);\n    }\n    s.len() as i32\n}\n\nfn distinct_primes_factors(n: i32) -> i32 {\n    for i in n..1000000 {\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4 {\n            return i;\n        }\n    }\n    -1\n}",
                "fn self_powers(n: i32) -> String {\n    let mut digits = [0; 10];\n    digits[0] = 1;\n    for i in 1..=n {\n        let mut temp_digits = [0; 10];\n        temp_digits[0] = 1;\n        for j in 0..i {\n            let mut carry = 0;\n            for k in 0..10 {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for j in 0..10 {\n            digits[j] += temp_digits[j];\n            if digits[j] >= 10 {\n                digits[j] -= 10;\n                if j < 9 {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let mut result = String::new();\n    for i in (0..10).rev() {\n        result.push_str(&i.to_string());\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.to_string()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn prime_permutations(n: i32) -> String {\n    for i in (n..=999).rev() {\n        if is_prime(i) {\n            let permutations = gen_permutations(&i.to_string());\n            let mut candidates = HashMap::new();\n            for j in permutations {\n                let candidate = j.parse::<i32>().unwrap();\n                if candidate > i && is_prime(candidate) {\n                    candidates.insert(candidate, true);\n                }\n            }\n            for m in candidates.keys() {\n                if candidates[&(m + (m - i))] {\n                    return i.to_string() + &m.to_string() + &(m + (m - i)).to_string();\n                }\n            }\n        }\n    }\n    \"\".to_string()\n}",
                "fn consecutive_prime_sum(limit: i32) -> i32 {\n    let mut sieve = vec![true; limit as usize];\n    let mut primes = Vec::new();\n    for i in 2..limit {\n        if sieve[i as usize] {\n            primes.push(i);\n            for j in i * 2..limit {\n                sieve[j as usize] = false;\n            }\n        }\n    }\n    let mut max_length = 0;\n    let mut max_prime = 0;\n    for i in 0..primes.len() {\n        for j in i + max_length..primes.len() {\n            let mut s = 0;\n            for k in i..j {\n                s += primes[k];\n            }\n            if s >= limit {\n                break;\n            }\n            if sieve[s as usize] && j - i > max_length {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    max_prime\n}"
            ],
            "scala": [
                "def multiplesOf3And5(n: Int): Int = {\n  var result = 0\n  for (i <- 0 until n) {\n    if (i % 3 == 0 || i % 5 == 0) {\n      result += i\n    }\n  }\n  result\n}",
                "def evenFibonacciNumbers(n: Int): Int = {\n  var result = 0\n  var a = 1\n  var b = 2\n  while (a < n) {\n    if (a % 2 == 0) {\n      result += a\n    }\n    val tmp = a\n    a = b\n    b = tmp + b\n  }\n  result\n}",
                "def largestPrimeFactor(n: Int): Int = {\n  var result = n\n  var i = 2\n  while (i * i <= result) {\n    if (result % i != 0) {\n      i += 1\n    } else {\n      result /= i\n    }\n  }\n  result\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i) != s(s.length - i - 1)) {\n      return false\n    }\n  }\n  true\n}\n\ndef largestPalindromeProduct(n: Int): Int = {\n  var result = 0\n  for (i <- 100 until 1000) {\n    for (j <- i until 1000) {\n      val prod = i * j\n      if (isPalindrome(prod.toString) && prod > result && prod < n) {\n        result = prod\n      }\n    }\n  }\n  result\n}",
                "def smallestMultiple(n: Int): Int = {\n  var result = 1\n  for (i <- 1 to n) {\n    if (result % i != 0) {\n      for (j <- 1 to n) {\n        if ((result * j) % i == 0) {\n          result *= j\n          break\n        }\n      }\n    }\n  }\n  result\n}",
                "def sumSquareDifference(n: Int): Int = {\n  var sqrSum = 0\n  var numSum = 0\n  for (i <- 1 to n) {\n    sqrSum += i * i\n    numSum += i\n  }\n  numSum * numSum - sqrSum\n}",
                "def nthPrime(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (primes.length < n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  primes(primes.length - 1)\n}",
                "def largestProductInASeries(s: String, k: Int): Int = {\n  var result = 0\n  for (i <- 0 until s.length - k) {\n    var product = 1\n    for (j <- 0 until k) {\n      product *= (s(i + j) - '0')\n    }\n    result = math.max(result, product)\n  }\n  result\n}",
                "def specialPythagoreanTriplet(n: Int): Int = {\n  for (a <- 1 until n) {\n    for (b <- a until n) {\n      val c = n - a - b\n      if (a * a + b * b == c * c) {\n        return a * b * c\n      }\n    }\n  }\n  -1\n}",
                "def summationOfPrimes(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (i <= n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  var result = 0\n  for (prime <- primes) {\n    result += prime\n  }\n  result\n}",
                "def largestProductInAGrid(grid: collection.Seq[collection.Seq[Int]]): Int = {\n  var result = 0\n  for (i <- 0 until grid.length - 3) {\n    for (j <- 0 until grid(i).length - 3) {\n      var p1, p2, p3, p4 = 1, 1, 1, 1\n      for (k <- 0 until 4) {\n        p1 *= grid(i + k)(j)\n      }\n      for (k <- 0 until 4) {\n        p2 *= grid(i)(j + k)\n      }\n      for (k <- 0 until 4) {\n        p3 *= grid(i + k)(j + k)\n      }\n      for (k <- 0 until 4) {\n        p4 *= grid(i + k)(j + 3 - k)\n      }\n      result = math.max(result, p1, p2, p3, p4)\n    }\n  }\n  result\n}",
                "def highlyDivisibleTriangularNumber(n: Int): Int = {\n  for (i <- 1 until 100000000) {\n    val result = i * (i + 1) / 2\n    var count = 0\n    for (j <- 1 to math.sqrt(result).toInt) {\n      if (result % j == 0) {\n        count += 2\n      }\n      if (j * j == result) {\n        count -= 1\n      }\n    }\n    if (count > n) {\n      return result\n    }\n  }\n  -1\n}",
                "def largeSum(numbers: collection.Seq[String]): String = {\n  val digits = Array.fill(60)(0)\n  for (i <- 0 until 50) {\n    var tmp = 0\n    for (num <- numbers) {\n      tmp += num(49 - i) - '0'\n    }\n    for (j <- i until 60) {\n      digits(j) += tmp % 10\n      if (digits(j) >= 10) {\n        digits(j + 1) += digits(j) / 10\n        digits(j) %= 10\n      }\n      tmp /= 10\n      if (tmp == 0) {\n        break\n      }\n    }\n  }\n  for (i <- 59 to 0 by -1) {\n    if (digits(i) != 0) {\n      var result = \"\"\n      for (j <- i until i - 10 by -1) {\n        result += digits(j).toString\n      }\n      return result\n    }\n  }\n  \"\"\n}",
                "def longestCollatzSequence(n: Int): Int = {\n  var longest = 0\n  var result = 0\n  for (i <- 1 until n) {\n    var chain = 1\n    var num = i\n    while (num != 1) {\n      if (num % 2 == 0) {\n        num = num / 2\n      } else {\n        num = 3 * num + 1\n      }\n      chain += 1\n    }\n    if (chain > longest) {\n      longest = chain\n      result = i\n    }\n  }\n  result\n}",
                "def latticePaths(m: Int, n: Int): Int = {\n  val grid = Array.ofDim[Int](m + 1, n + 1)\n  for (i <- 0 to m) {\n    grid(i)(0) = 1\n  }\n  for (j <- 0 to n) {\n    grid(0)(j) = 1\n  }\n  for (i <- 1 to m) {\n    for (j <- 1 to n) {\n      grid(i)(j) = grid(i - 1)(j) + grid(i)(j - 1)\n    }\n  }\n  grid(m)(n)\n}",
                "def powerDigitSum(n: Int): Int = {\n  var digits = collection.mutable.ArrayBuffer[Int](2)\n  for (i <- 1 until n) {\n    var carry = 0\n    for (j <- 0 until digits.length) {\n      val temp = digits(j)*2 + carry\n      digits(j) = temp % 10\n      carry = temp / 10\n    }\n    if (carry != 0) {\n      digits += carry\n    }\n  }\n  var result = 0\n  for (digit <- digits) {\n    result += digit\n  }\n  result\n}",
                "def numberToWords(n: Int): String = {\n  val ones = Array(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n  val teens = Array(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n  val tens = Array(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n  if (n == 1000) {\n    return \"one thousand\"\n  } else if (n >= 100) {\n    if (n % 100 == 0) {\n      return ones(n / 100) + \" hundred\"\n    } else {\n      return ones(n / 100) + \" hundred and \" + numberToWords(n % 100)\n    }\n  } else if (n >= 20) {\n    var suf = \"\"\n    if (n % 10 != 0) {\n      suf = \" \" + ones(n % 10)\n    }\n    return tens(n / 10) + suf\n  } else if (n >= 10) {\n    return teens(n - 10)\n  } else {\n    return ones(n)\n  }\n}",
                "def maximumPathSumI(triangle: collection.Seq[collection.Seq[Int]]): Int = {\n  val curr = triangle.last.toArray\n  for (i <- triangle.length - 2 to 0 by -1) {\n    val next = triangle(i).toArray\n    for (j <- 0 until next.length) {\n      next(j) += math.max(curr(j), curr(j + 1))\n    }\n    curr.copyToArray(next)\n  }\n  curr(0)\n}",
                "def countingSundays(y1: Int, y2: Int): Int = {\n  var day = 0\n  var count = 0\n  for (year <- 1900 to y2) {\n    for (month <- 1 to 12) {\n      if (year >= y1 && day % 7 == 6) {\n        count += 1\n      }\n      if (month == 4 || month == 6 || month == 9 || month == 11) {\n        day += 30\n      } else if (month == 2) {\n        if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n          day += 29\n        } else {\n          day += 28\n        }\n      } else {\n        day += 31\n      }\n    }\n  }\n  count\n}",
                "def factorialDigitSum(n: Int): Int = {\n  var digits = collection.mutable.ArrayBuffer[Int](1)\n  for (i <- 1 to n) {\n    var carry = 0\n    for (j <- 0 until digits.length) {\n      digits(j) = digits(j) * i + carry\n      carry = digits(j) / 10\n      digits(j) %= 10\n    }\n    while (carry != 0) {\n      digits += carry % 10\n      carry /= 10\n    }\n  }\n  var result = 0\n  for (digit <- digits) {\n    result += digit\n  }\n  result\n}",
                "def d(n: Int): Int = {\n  var result = 1\n  for (i <- 2 to math.sqrt(n).toInt) {\n    if (n % i == 0) {\n      result += i\n      if (i != n / i) {\n        result += n / i\n      }\n    }\n  }\n  result\n}\n\ndef amicableNumbers(n: Int): Int = {\n  var result = 0\n  for (a <- 2 until n) {\n    val b = d(a)\n    if (a != b && a == d(b)) {\n      result += a\n    }\n  }\n  result\n}",
                "def namesScores(names: collection.Seq[String], queries: collection.Seq[String]): Int = {\n  val sNames = names.clone\n  sNames.sortWith((a, b) => a < b)\n  var result = 0\n  for (i <- 0 until sNames.length) {\n    var x = 0\n    for (c <- sNames(i)) {\n      x += c - 64\n    }\n    for (query <- queries) {\n      if (query == sNames(i)) {\n        result += x * (i + 1)\n        break\n      }\n    }\n  }\n  result\n}",
                "def isAbundant(n: Int): Boolean = {\n  if (n < 12) {\n    false\n  } else {\n    var sumDivisors = 1\n    for (i <- 2 until math.sqrt(n.toDouble).toInt) {\n      if (n % i == 0) {\n        sumDivisors += i\n        if (i != n / i) {\n          sumDivisors += n / i\n        }\n      }\n    }\n    sumDivisors > n\n  }\n}\n\ndef nonAbundantSums(n: Int): Int = {\n  val abundants = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 12 until n) {\n    if (isAbundant(i)) {\n      abundants += i\n    }\n  }\n  val abundantSums = collection.mutable.Map[Int, Boolean]()\n  for (i <- abundants) {\n    for (j <- abundants) {\n      abundantSums(i + j) = true\n    }\n  }\n  var result = 0\n  for (i <- 0 until n) {\n    if (!abundantSums.contains(i)) {\n      result += i\n    }\n  }\n  result\n}",
                "def lexicographicPermutations(n: Int): String = {\n  val result = new StringBuilder()\n  val digits = ArrayBuffer(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n  var x = n - 1\n  for (i <- 10 to 1 by -1) {\n    var fact = 1\n    for (j <- 1 to i - 1) {\n      fact *= j\n    }\n    val idx = x / fact\n    result.append(digits(idx).toString)\n    digits.remove(idx)\n    x -= idx * fact\n  }\n  result.toString\n}",
                "def nDigitFibonacciNumber(n: Int): Int = {\n  var a = ArrayBuffer(1)\n  var b = ArrayBuffer(1)\n  var i = 2\n  while (b.length < n) {\n    var carry = 0\n    val c = ArrayBuffer[Int]()\n    c ++= b\n    for (j <- 0 until b.length) {\n      if (j < a.length) {\n        b(j) = a(j) + b(j) + carry\n      } else {\n        b(j) = b(j) + carry\n      }\n      carry = b(j) / 10\n      b(j) = b(j) % 10\n    }\n    if (carry != 0) {\n      b += carry\n    }\n    a = ArrayBuffer[Int]()\n    a ++= c\n    i = i + 1\n  }\n  i\n}",
                "def reciprocalCycles(n: Int): Int = {\n  var result = 0\n  var maxLength = 0\n  for (i <- 1 until n) {\n    val remainders = collection.mutable.ArrayBuffer[Int]()\n    var remainder = 1\n    while (remainder != 0 && !remainders.contains(remainder)) {\n      remainders += remainder\n      remainder = (remainder * 10) % i\n    }\n    var length = 0\n    if (remainder != 0) {\n      length = remainders.length - remainders.indexOf(remainder)\n    }\n    if (length > maxLength) {\n      maxLength = length\n      result = i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef quadraticPrimes(n: Int): Int = {\n  var maxPrimes = 0\n  var result = 0\n  for (a <- -n + 1 to n - 1 by 2) {\n    for (b <- -n + 1 to n - 1 by 2) {\n      var x = 0\n      while ({\n        if (x * x + a * x + b < 2) {\n          return false\n        }\n        if (!isPrime(x * x + a * x + b)) {\n          return false\n        }\n        x += 1\n        x <= maxPrimes\n      }) {}\n      if (x > maxPrimes) {\n        maxPrimes = x\n        result = a * b\n      }\n    }\n  }\n  result\n}",
                "def numberSpiralDiagonals(n: Int): Int = {\n  var result = 1\n  for (i <- 3 to n by 2) {\n    result += 4 * i * i - 6 * i + 6\n  }\n  result\n}",
                "def distinctPowers(n: Int): Int = {\n  var result = 0\n  val xs = collection.mutable.Map[String, Boolean]()\n  for (i <- 2 to n) {\n    val primes = Array(2, 3, 5, 7)\n    val powers = Array(0, 0, 0, 0)\n    var num = i\n    for (j <- 0 until primes.length) {\n      while (num % primes(j) == 0) {\n        num /= primes(j)\n        powers(j) += 1\n      }\n    }\n    if (num != 1) {\n      result += n - 1\n      continue\n    }\n    for (j <- 2 to n) {\n      val pstr = s\"${powers(0) * j}-${powers(1) * j}-${powers(2) * j}-${powers(3) * j}\"\n      xs(pstr) = true\n    }\n  }\n  result += xs.size\n  result\n}",
                "def digitNthPowers(n: Int): Int = {\n  var result = 0\n  for (i <- 2 until 4 * math.pow(10, n).toInt) {\n    var digitsSum = 0\n    for (digit <- i.toString) {\n      digitsSum += math.pow(digit.toInt, n).toInt\n    }\n    if (i == digitsSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def coinSums(n: Int): Int = {\n  val coins = Array(1, 2, 5, 10, 20, 50, 100, 200)\n  val ways = Array.fill(n + 1)(0)\n  ways(0) = 1\n  for (coin <- coins) {\n    for (i <- coin to n) {\n      ways(i) += ways(i - coin)\n    }\n  }\n  ways(n)\n}",
                "def pandigitalProducts(n: Int): Int = {\n  val products = collection.mutable.Map[Int, Boolean]()\n  var s = \"\"\n  for (i <- 1 to n) {\n    s += i.toString\n  }\n  for (a <- 1 until 100) {\n    for (b <- 1 until 10000) {\n      val c = a * b\n      val chars = s\"$a$b$c\".toCharArray\n      scala.util.Sorting.quickSort(chars)\n      if (s.toCharArray.sameElements(chars)) {\n        products(c) = true\n      }\n    }\n  }\n  var result = 0\n  for (product <- products.keys) {\n    result += product\n  }\n  result\n}",
                "def digitCancelingFractions(m: Int): Int = {\n  var numer = 1\n  var denom = 1\n  for (d <- 10 until m) {\n    for (n <- 10 until d) {\n      val n0 = n % 10\n      val n1 = n / 10\n      val d0 = d % 10\n      val d1 = d / 10\n      if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n        numer *= n\n        denom *= d\n      }\n    }\n  }\n  var a = numer\n  var b = denom\n  while (b != 0) {\n    val temp = b\n    b = a % b\n    a = temp\n  }\n  denom / a\n}",
                "def digitFactorials(n: Int): Int = {\n  var result = 0\n  for (i <- 3 until n) {\n    var factSum = 0\n    for (digit <- i.toString) {\n      var fact = 1\n      for (j <- 1 until digit.asDigit) {\n        fact *= j\n      }\n      factSum += fact\n    }\n    if (i == factSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef circularPrimes(n: Int): Int = {\n  var count = 0\n  for (i <- 2 until n) {\n    if (isPrime(i)) {\n      val rotations = collection.mutable.Map[Int, Unit]()\n      val str = i.toString\n      for (j <- 0 until str.length) {\n        val x = str.substring(j).toInt + str.substring(0, j).toInt\n        rotations(x) = ()\n      }\n      var flag = true\n      for (x <- rotations.keys) {\n        if (!isPrime(x)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        count += 1\n      }\n    }\n  }\n  count\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i) != s(s.length - i - 1)) {\n      return false\n    }\n  }\n  true\n}\n\ndef doubleBasePalindromes(n: Int): Int = {\n  var result = 0\n  for (i <- 1 until n) {\n    val strI = i.toString\n    val binI = i.toBinaryString\n    if (isPalindrome(strI) && isPalindrome(binI)) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef truncatablePrimes(n: Int): Int = {\n  var result = 0\n  for (i <- 10 until n) {\n    if (isPrime(i)) {\n      si = i.toString\n      flag = true\n      for (j <- 1 until si.length) {\n        p1 = si.substring(j).toInt\n        p2 = si.substring(0, si.length - j).toInt\n        if (!isPrime(p1) || !isPrime(p2)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        result += i\n      }\n    }\n  }\n  result\n}",
                "def pandigitalMultiples(n: Int): Int = {\n  var result = -1\n  for (i <- 2 to n) {\n    var cprod = \"\"\n    for (j <- 1 until 10) {\n      cprod += i * j\n      if (cprod.length == 9) {\n        val chars = cprod.split(\"\")\n        val sortedChars = chars.sorted\n        if (sortedChars.mkString == \"123456789\") {\n          result = math.max(result, cprod.toInt)\n          break\n        }\n      } else if (cprod.length > 9) {\n        break\n      }\n    }\n  }\n  result\n}",
                "def integerRightTriangles(n: Int): Int = {\n  var maxSol = 0\n  var result = 0\n  for (p <- 3 to n) {\n    var sol = 0\n    for (a <- 1 until p / 2) {\n      for (b <- a until p / 2) {\n        val c = p - a - b\n        if (a * a + b * b == c * c) {\n          sol += 1\n        }\n      }\n    }\n    if (sol > maxSol) {\n      maxSol = sol\n      result = p\n    }\n  }\n  result\n}",
                "def champernowneConstant(b: Int): Int = {\n  var s = \"\"\n  for (i <- 1 until math.pow(b, 6).toInt) {\n    s += i.toString\n  }\n  var result = 1\n  for (i <- 0 until 7) {\n    result *= s(math.pow(b, i).toInt - 1).toString.toInt\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef pandigitalPrime(n: Int): Int = {\n  for (i <- n - 1 to 1 by -1) {\n    if (isPrime(i)) {\n      val si = i.toString\n      val length = si.length\n      var flag = true\n      for (j <- 1 to length) {\n        if (!si.contains(j.toString)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        return i\n      }\n    }\n  }\n  -1\n}",
                "def codedTriangleNumbers(words: collection.Seq[String]): Int = {\n  var result = 0\n  for (word <- words) {\n    var value = 0\n    for (c <- word) {\n      value += c.toInt - 64\n    }\n    val n = math.sqrt(value * 2).toInt\n    if (n * (n + 1) == value * 2) {\n      result += 1\n    }\n  }\n  result\n}",
                "def genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    return collection.Seq(s)\n  }\n  val result = collection.mutable.ArrayBuffer[String]()\n  for (perm <- genPermutations(s.substring(1))) {\n    for (i <- 0 until s.length) {\n      result += perm.substring(0, i) + s.charAt(0) + perm.substring(i)\n    }\n  }\n  result\n}\n\ndef subStringDivisibility(n: Int): Int = {\n  val result = 0\n  val primes = collection.Seq(2, 3, 5, 7, 11, 13, 17)\n  var s = \"\"\n  for (i <- 0 to n) {\n    s += i.toString\n  }\n  for (i <- genPermutations(s)) {\n    var flag = true\n    for (j <- 1 until n - 1) {\n      if (i.substring(j, j + 3).toInt % primes(j - 1) != 0) {\n        flag = false\n        break\n      }\n    }\n    if (flag) {\n      val s0 = i.toInt\n      result += s0\n    }\n  }\n  result\n}",
                "def pentagonNumbers(n: Int): Int = {\n  val pentagon = collection.mutable.Map[Int, Boolean]()\n  for (i <- 1 until n) {\n    pentagon += (i * (3 * i - 1) / 2) -> true\n  }\n  var result = -1\n  for (j <- pentagon.keys) {\n    for (k <- pentagon.keys) {\n      if pentagon(j + k) && pentagon(k - j) {\n        if result == -1 || k - j < result {\n          result = k - j\n        }\n      }\n    }\n  }\n  result\n}",
                "def triangularPentagonalAndHexagonal(n: Int): Int = {\n  val ps = collection.mutable.Map[Int, Boolean]()\n  var i = 1\n  var c = (0.5 * i * (3 * i - 1)).toInt\n  while (c < n) {\n    i += 1\n    ps(c) = true\n    c = (0.5 * i * (3 * i - 1)).toInt\n  }\n  i = 1\n  c = i * (2 * i - 1)\n  var result = -1\n  while (c < n) {\n    i += 1\n    if (ps(c)) {\n      result = c\n    }\n    c = i * (2 * i - 1)\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef goldbachsOtherConjecture(n: Int): Int = {\n  var result = -1\n  for (i <- 9999 to n by -2) {\n    val upper = math.sqrt(i / 2).toInt\n    var flag = false\n    for (j <- 0 to upper) {\n      if (isPrime(i - 2 * j * j)) {\n        flag = true\n        break\n      }\n    }\n    if (!flag) {\n      result = i\n    }\n  }\n  result\n}",
                "def primeFactors(n: Int): Int = {\n  var num = n\n  val factors = collection.mutable.ArrayBuffer[Int]()\n  var i = 2\n  while (i * i <= num) {\n    if (num % i != 0) {\n      i += 1\n    } else {\n      num /= i\n      factors += i\n    }\n  }\n  if (num > 1) {\n    factors += num\n  }\n  val s = collection.mutable.Map[Int, Boolean]()\n  for (v <- factors) {\n    s(v) = true\n  }\n  s.size\n}\n\ndef distinctPrimesFactors(n: Int): Int = {\n  for (i <- n until 1000000) {\n    if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n      return i\n    }\n  }\n  -1\n}",
                "def selfPowers(n: Int): String = {\n  val digits = Array.fill(10)(0)\n  digits(0) = 1\n  for (i <- 1 to n) {\n    val tempDigits = Array.fill(10)(0)\n    tempDigits(0) = 1\n    for (j <- 0 until i) {\n      var carry = 0\n      for (k <- 0 until 10) {\n        tempDigits(k) = tempDigits(k) * i + carry\n        carry = tempDigits(k) / 10\n        tempDigits(k) %= 10\n      }\n    }\n    for (j <- 0 until 10) {\n      digits(j) += tempDigits(j)\n      if (digits(j) >= 10) {\n        digits(j) -= 10\n        if (j < 9) {\n          digits(j + 1) += 1\n        }\n      }\n    }\n  }\n  var result = \"\"\n  for (i <- 9 to 0 by -1) {\n    result += digits(i).toString\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    return collection.Seq(s)\n  }\n  val result = collection.mutable.ArrayBuffer[String]()\n  for (perm <- genPermutations(s.substring(1))) {\n    for (i <- 0 until s.length) {\n      result += perm.substring(0, i) + s.charAt(0) + perm.substring(i)\n    }\n  }\n  result\n}\n\ndef primePermutations(n: Int): String = {\n  for (i <- n to 999 by -1) {\n    if (isPrime(i)) {\n      val permutations = genPermutations(i.toString)\n      val candidates = collection.mutable.Map[Int, Boolean]()\n      for (j <- permutations) {\n        val candidate = j.toInt\n        if (candidate > i && isPrime(candidate)) {\n          candidates(candidate) = true\n        }\n      }\n      for (m <- candidates.keys) {\n        if (candidates(m + (m - i))) {\n          return i.toString + m.toString + (m + (m - i)).toString\n        }\n      }\n    }\n  }\n  \"\"\n}",
                "def consecutivePrimeSum(limit: Int): Int = {\n  val sieve = Array.fill(limit)(true)\n  val primes = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 2 until limit) {\n    if (sieve(i)) {\n      primes += i\n      for (j <- i * 2 until limit by i) {\n        sieve(j) = false\n      }\n    }\n  }\n  var maxLength = 0\n  var maxPrime = 0\n  for (i <- 0 until primes.length) {\n    for (j <- i + maxLength until primes.length) {\n      var s = 0\n      for (k <- i until j) {\n        s += primes(k)\n      }\n      if (s >= limit) {\n        break\n      }\n      if (sieve(s) && j - i > maxLength) {\n        maxLength = j - i\n        maxPrime = s\n      }\n    }\n  }\n  maxPrime\n}"
            ]
        },
        "python": {
            "cpp": [
                "int multiplesOf3And5(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int evenFibonacciNumbers(int n) {\n    int result = 0;\n    int a = 1;\n    int b = 2;\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a;\n        }\n        int tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "int largestPrimeFactor(int n) {\n    int result = n;\n    int i = 2;\n    while (i * i <= result) {\n        if (result % i) {\n            i++;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint largestPalindromeProduct(int n) {\n    int result = 0;\n    for (int i = 100; i < 1000; i++) {\n        for (int j = i; j < 1000; j++) {\n            int prod = i * j;\n            if (isPalindrome(to_string(prod)) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "int smallestMultiple(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        if (result % i != 0) {\n            for (int j = 1; j <= n; j++) {\n                if ((result * j) % i == 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int sumSquareDifference(int n) {\n    int sqr_sum = 0;\n    int num_sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    return num_sum * num_sum - sqr_sum;\n}",
                "int nthPrime(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (primes.size() < n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes.back();\n}",
                "int largestProductInASeries(const string& s, int k) {\n    int result = 0;\n    for (int i = 0; i < s.size() - k; i++) {\n        int product = 1;\n        for (int j = 0; j < k; j++) {\n            product *= s[i + j] - '0';\n        }\n        result = max(result, product);\n    }\n    return result;\n}",
                "int specialPythagoreanTriplet(int n) {\n    for (int a = 1; a < n; a++) {\n        for (int b = a; b < n; b++) {\n            int c = n - a - b;\n            if (a * a + b * b == c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "int summationOfPrimes(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (i <= n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    int result = 0;\n    for (int prime : primes) {\n        result += prime;\n    }\n    return result;\n}",
                "int largestProductInAGrid(const vector<vector<int>>& grid) {\n    int result = 0;\n    for (int i = 0; i < grid.size() - 3; i++) {\n        for (int j = 0; j < grid[i].size() - 3; j++) {\n            int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (int k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (int k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "int highlyDivisibleTriangularNumber(int n) {\n    for (int i = 1; i < 100000000; i++) {\n        int result = i * (i + 1) / 2;\n        int count = 0;\n        for (int j = 1; j <= sqrt(result); j++) {\n            if (result % j == 0) {\n                count += 2;\n            }\n            if (j * j == result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "string largeSum(const vector<string>& numbers) {\n    vector<int> digits(60, 0);\n    for (int i = 1; i < 50; i++) {\n        int tmp = 0;\n        for (const string& num : numbers) {\n            tmp += num[49 - i] - '0';\n        }\n        for (int j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if (tmp == 0) {\n                break;\n            }\n        }\n    }\n    for (int i = 59; i >= 0; i--) {\n        if (digits[i] != 0) {\n            string result;\n            for (int j = i; j > i - 10; j--) {\n                result += to_string(digits[j]);\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
                "int longestCollatzSequence(int n) {\n    int longest = 0;\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        int chain = 1;\n        int num = i;\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num /= 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "int latticePaths(int m, int n) {\n    vector<vector<int>> grid(m + 1, vector<int>(n + 1, 0));\n    for (int i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (int j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "int powerDigitSum(int n) {\n    vector<int> digits = {2};\n    for (int i = 1; i < n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            int temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry) {\n            digits.push_back(carry);\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "string numberToWords(int n) {\n    string ones[] = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    string teens[] = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n    string tens[] = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        string suf = \"\";\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "int maximumPathSumI(const vector<vector<int>>& triangle) {\n    vector<int> curr = triangle.back();\n    for (int i = triangle.size() - 2; i >= 0; i--) {\n        vector<int> next = triangle[i];\n        for (int j = 0; j < next.size(); j++) {\n            next[j] += max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "int countingSundays(int y1, int y2) {\n    int day = 0;\n    int count = 0;\n    for (int year = 1900; year <= y2; year++) {\n        for (int month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 == 6) {\n                count++;\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30;\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "int factorialDigitSum(int n) {\n    vector<int> digits = {1};\n    for (int i = 1; i <= n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            digits[j] *= i;\n            digits[j] += carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while (carry) {\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "int d(int n) {\n    int result = 1;\n    for (int i = 2; i <= n / i; i++) {\n        if (n % i == 0) {\n            result += i;\n            if (i != n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nint amicableNumbers(int n) {\n    int result = 0;\n    for (int a = 2; a < n; a++) {\n        int b = d(a);\n        if (a != b && a == d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "int namesScores(const vector<string>& names, const vector<string>& queries) {\n    vector<string> s_names = names;\n    sort(s_names.begin(), s_names.end());\n    int result = 0;\n    for (int i = 0; i < s_names.size(); i++) {\n        int x = 0;\n        for (char c : s_names[i]) {\n            x += c - 'A' + 1;\n        }\n        if (find(queries.begin(), queries.end(), s_names[i]) != queries.end()) {\n            result += x * (i + 1);\n        }\n    }\n    return result;\n}",
                "bool isAbundant(int n) {\n    if (n < 12) {\n        return false;\n    }\n    int sum_divisors = 1;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            sum_divisors += i;\n            if (i != n / i) {\n                sum_divisors += n / i;\n            }\n        }\n    }\n    return sum_divisors > n;\n}\n\nint nonAbundantSums(int n) {\n    vector<int> abundants;\n    for (int i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push_back(i);\n        }\n    }\n    set<int> abundant_sums;\n    for (int i : abundants) {\n        for (int j : abundants) {\n            abundant_sums.insert(i + j);\n        }\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (abundant_sums.find(i) == abundant_sums.end()) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "string lexicographicPermutations(int n) {\n    string result;\n    vector<int> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = n - 1;\n    for (int i = 10; i > 0; i--) {\n        int fact = 1;\n        for (int j = 1; j < i; j++) {\n            fact *= j;\n        }\n        int idx = x / fact;\n        result += to_string(digits[idx]);\n        digits.erase(digits.begin() + idx);\n        x -= idx * fact;\n    }\n    return result;\n}",
                "int nDigitFibonacciNumber(int n) {\n    vector<int> a = {1};\n    vector<int> b = {1};\n    int i = 2;\n    while (b.size() < n) {\n        int carry = 0;\n        vector<int> c = b;\n        for (int j = 0; j < b.size(); j++) {\n            if (j < a.size()) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry) {\n            b.push_back(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
                "int reciprocalCycles(int n) {\n    int result = 0;\n    int max_length = 0;\n    for (int i = 1; i < n; i++) {\n        vector<int> remainders;\n        int remainder = 1;\n        while (remainder != 0 && find(remainders.begin(), remainders.end(), remainder) == remainders.end()) {\n            remainders.push_back(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        int length = 0;\n        if (remainder != 0) {\n            length = remainders.size() - remainders.end() - remainders.begin();\n        }\n        if (length > max_length) {\n            max_length = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint quadraticPrimes(int n) {\n    int maxPrimes = 0;\n    int result = 0;\n    for (int a = -n + 1; a < n; a += 2) {\n        for (int b = -n + 1; b < n; b += 2) {\n            int x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "int numberSpiralDiagonals(int n) {\n    int result = 1;\n    for (int i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "int distinctPowers(int n) {\n    int result = 0;\n    set<string> xs;\n    for (int i = 2; i <= n; i++) {\n        vector<int> primes = {2, 3, 5, 7};\n        vector<int> powers = {0, 0, 0, 0};\n        int num = i;\n        for (int j = 0; j < primes.size(); j++) {\n            while (num % primes[j] == 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num != 1) {\n            result += n - 1;\n            continue;\n        }\n        for (int j = 2; j <= n; j++) {\n            string pstr = to_string(powers[0] * j) + \"-\" + to_string(powers[1] * j) + \"-\" + to_string(powers[2] * j) + \"-\" + to_string(powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.size();\n    return result;\n}",
                "int digitNthPowers(int n) {\n    int result = 0;\n    for (int i = 2; i < 4 * pow(10, n); i++) {\n        int digits_sum = 0;\n        for (char digit : to_string(i)) {\n            digits_sum += pow(digit - '0', n);\n        }\n        if (i == digits_sum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int coinSums(int n) {\n    vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 200};\n    vector<int> ways(n + 1, 0);\n    ways[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "int pandigitalProducts(int n) {\n    set<int> products;\n    string s = \"\";\n    for (int i = 1; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (int a = 1; a < 100; a++) {\n        for (int b = 1; b < 10000; b++) {\n            int c = a * b;\n            string chars = to_string(a) + to_string(b) + to_string(c);\n            sort(chars.begin(), chars.end());\n            if (chars == s) {\n                products.insert(c);\n            }\n        }\n    }\n    int result = 0;\n    for (int product : products) {\n        result += product;\n    }\n    return result;\n}",
                "int digitCancelingFractions(int m) {\n    int numer = 1;\n    int denom = 1;\n    for (int d = 10; d < m; d++) {\n        for (int n = 10; n < d; n++) {\n            int n0 = n % 10;\n            int n1 = n / 10;\n            int d0 = d % 10;\n            int d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    int a = numer;\n    int b = denom;\n    while (b) {\n        a = b;\n        b = a % b;\n    }\n    return denom / a;\n}",
                "int digitFactorials(int n) {\n    int result = 0;\n    for (int i = 3; i < n; i++) {\n        int fact_sum = 0;\n        for (char digit : to_string(i)) {\n            int fact = 1;\n            for (int j = 1; j <= digit - '0'; j++) {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if (i == fact_sum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint circularPrimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            set<int> rotations;\n            for (int j = 0; j < to_string(i).size(); j++) {\n                rotations.insert(stoi(to_string(i).substr(j) + to_string(i).substr(0, j)));\n            }\n            bool flag = true;\n            for (int x : rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint doubleBasePalindromes(int n) {\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        string str_i = to_string(i);\n        string bin_i = bitset<32>(i).to_string();\n        if (isPalindrome(str_i) && isPalindrome(bin_i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint truncatablePrimes(int n) {\n    int result = 0;\n    for (int i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            bool flag = true;\n            for (int j = 1; j < si.size(); j++) {\n                int p1 = stoi(si.substr(j));\n                int p2 = stoi(si.substr(0, si.size() - j));\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "int pandigitalMultiples(int n) {\n    int result = -1;\n    for (int i = 2; i <= n; i++) {\n        string cprod;\n        for (int j = 1; j <= 9; j++) {\n            cprod += to_string(i * j);\n            if (cprod.size() == 9) {\n                if (cprod == \"123456789\") {\n                    result = max(result, stoi(cprod));\n                    break;\n                }\n            } else if (cprod.size() > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "int integerRightTriangles(int n) {\n    int max_sol = 0;\n    int result = 0;\n    for (int p = 3; p <= n; p++) {\n        int sol = 0;\n        for (int a = 1; a < p / 2; a++) {\n            for (int b = a; b < p / 2; b++) {\n                int c = p - a - b;\n                if (a * a + b * b == c * c) {\n                    sol += 1;\n                }\n            }\n        }\n        if (sol > max_sol) {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "int champernowneConstant(int b) {\n    string s;\n    for (int i = 1; i < pow(b, 6); i++) {\n        s += to_string(i);\n    }\n    int result = 1;\n    for (int i = 0; i < 7; i++) {\n        result *= s[pow(b, i) - 1] - '0';\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint pandigitalPrime(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            int length = si.size();\n            bool flag = true;\n            for (int j = 1; j <= length; j++) {\n                if (si.find(to_string(j)) == string::npos) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "int codedTriangleNumbers(const vector<string>& words) {\n    int result = 0;\n    for (const string& word : words) {\n        int value = 0;\n        for (char c : word) {\n            value += c - 'A' + 1;\n        }\n        int n = int(sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result += 1;\n        }\n    }\n    return result;\n}",
                "vector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s[0] + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nint subStringDivisibility(int n) {\n    int result = 0;\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17};\n    string s = \"\";\n    for (int i = 0; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (const string& i : genPermutations(s)) {\n        bool flag = true;\n        for (int j = 1; j < n - 1; j++) {\n            if (stoi(i.substr(j, 3)) % primes[j - 1] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += stoi(i);\n        }\n    }\n    return result;\n}",
                "int pentagonNumbers(int n) {\n    set<int> pentagon;\n    for (int i = 1; i < n; i++) {\n        pentagon.insert(i * (3 * i - 1) / 2);\n    }\n    int result = -1;\n    for (int j : pentagon) {\n        for (int k : pentagon) {\n            if (pentagon.count(j + k) && pentagon.count(k - j)) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int triangularPentagonalAndHexagonal(int n) {\n    set<int> ps;\n    int i = 1;\n    int c = 0.5 * i * (3 * i - 1);\n    while (c < n) {\n        i += 1;\n        ps.insert(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    int result = -1;\n    while (c < n) {\n        i += 1;\n        if (ps.find(c) != ps.end()) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint goldbachsOtherConjecture(int n) {\n    int result = -1;\n    for (int i = 9999; i >= n; i -= 2) {\n        int upper = sqrt(i / 2);\n        bool flag = false;\n        for (int j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "int primeFactors(int n) {\n    int num = n;\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= num) {\n        if (num % i) {\n            i++;\n        } else {\n            num /= i;\n            factors.push_back(i);\n        }\n    }\n    if (num > 1) {\n        factors.push_back(num);\n    }\n    return set<int>(factors.begin(), factors.end()).size();\n}\n\nint distinctPrimesFactors(int n) {\n    for (int i = n; i < 1000000; i++) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "string selfPowers(int n) {\n    vector<int> digits(10, 0);\n    digits[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        vector<int> temp_digits(10, 0);\n        temp_digits[0] = 1;\n        for (int j = 0; j < i; j++) {\n            int carry = 0;\n            for (int k = 0; k < 10; k++) {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for (int j = 0; j < 10; j++) {\n            digits[j] += temp_digits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    string result;\n    for (int i = 9; i >= 0; i--) {\n        result += to_string(digits[i]);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < perm.size(); i++) {\n            result.push_back(perm.substr(0, i) + s[0] + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nstring primePermutations(int n) {\n    for (int i = n; i >= 999; i--) {\n        if (isPrime(i)) {\n            vector<string> permutations = genPermutations(to_string(i));\n            set<int> candidates;\n            for (const string& j : permutations) {\n                int candidate = stoi(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.insert(candidate);\n                }\n            }\n            for (int m : candidates) {\n                if (m + (m - i) in candidates) {\n                    return to_string(i) + to_string(m) + to_string(m + (m - i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "int consecutivePrimeSum(int limit) {\n    vector<bool> sieve(limit, true);\n    vector<int> primes;\n    for (int i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n            for (int j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    int max_length = 0;\n    int max_prime = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i + max_length; j < primes.size(); j++) {\n            int s = accumulate(primes.begin() + i, primes.begin() + j, 0);\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > max_length) {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    return max_prime;\n}"
            ],
            "csharp": [
                "class Global {\n    public static int MultiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int EvenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = s.Length / 2; i < s.Length; i++) {\n            if (s[i] != s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int LargestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (IsPalindrome(prod.ToString()) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SmallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i != 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SumSquareDifference(int n) {\n        int sqr_sum = 0;\n        int num_sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqr_sum += i * i;\n            num_sum += i;\n        }\n        return num_sum * num_sum - sqr_sum;\n    }\n}",
                "class Global {\n    public static int NthPrime(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (primes.Count < n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes[primes.Count - 1];\n    }\n}",
                "class Global {\n    public static int LargestProductInASeries(string s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.Length - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= int.Parse(s[i + j].ToString());\n            }\n            result = Math.Max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SpecialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int SummationOfPrimes(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (i <= n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        foreach (int prime in primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestProductInAGrid(IList<IList<int>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.Count - 3; i++) {\n            for (int j = 0; j < grid[i].Count - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid[i + k][j];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid[i][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid[i + k][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid[i + k][j + 3 - k];\n                }\n                result = Math.Max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int HighlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int)Math.Sqrt(result) + 1; j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string LargeSum(IList<string> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            foreach (string num in numbers) {\n                tmp += int.Parse(num[49 - i].ToString());\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i] != 0) {\n                string result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += digits[j].ToString();\n                }\n                return result;\n            }\n        }\n        return \"0\";\n    }\n}",
                "class Global {\n    public static int LongestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num /= 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LatticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][];\n        for (int i = 0; i < grid.Length; i++) {\n            grid[i] = new int[n + 1];\n        }\n        for (int i = 0; i < grid.Length; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j < grid[0].Length; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i < grid.Length; i++) {\n            for (int j = 1; j < grid[0].Length; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int PowerDigitSum(int n) {\n        IList<int> digits = new List<int> { 2 };\n        for (int _ = 1; _ < n; _++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                int temp = digits[j] * 2 + carry;\n                digits[j] = temp % 10;\n                carry = temp / 10;\n            }\n            if (carry != 0) {\n                digits.Add(carry);\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string NumberToWords(int n) {\n        string[] ones = new string[] { \"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\n        string[] teens = new string[] { \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" };\n        string[] tens = new string[] { \"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            string suf = \"\";\n            if (n % 10 != 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int MaximumPathSumI(IList<IList<int>> triangle) {\n        IList<int> curr = triangle[triangle.Count - 1].ToList();\n        for (int i = triangle.Count - 2; i >= 0; i--) {\n            IList<int> next = triangle[i].ToList();\n            for (int j = 0; j < next.Count; j++) {\n                next[j] += Math.Max(curr[j], curr[j + 1]);\n            }\n            curr = next;\n        }\n        return curr[0];\n    }\n}",
                "class Global {\n    public static int CountingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count += 1;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int FactorialDigitSum(int n) {\n        IList<int> digits = new List<int> { 1 };\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                digits[j] = digits[j] * i + carry;\n                carry = digits[j] / 10;\n                digits[j] %= 10;\n            }\n            while (carry != 0) {\n                digits.Add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int D(int n) {\n        int result = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n) + 1; i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i != n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int AmicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = D(a);\n            if (a != b && a == D(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NamesScores(IList<string> names, IList<string> queries) {\n        IList<string> s_names = new List<string>(names);\n        s_names.Sort();\n        int result = 0;\n        for (int i = 0; i < s_names.Count; i++) {\n            int x = 0;\n            foreach (char c in s_names[i]) {\n                x += (int)c - 64;\n            }\n            if (queries.Contains(s_names[i])) {\n                result += x * (i + 1);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sum_divisors = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n) + 1; i++) {\n            if (n % i == 0) {\n                sum_divisors += i;\n                if (i != n / i) {\n                    sum_divisors += n / i;\n                }\n            }\n        }\n        return sum_divisors > n;\n    }\n\n    public static int NonAbundantSums(int n) {\n        IList<int> abundants = new List<int>();\n        for (int i = 12; i < n; i++) {\n            if (IsAbundant(i)) {\n                abundants.Add(i);\n            }\n        }\n        ISet<int> abundant_sums = new HashSet<int>();\n        foreach (int i in abundants) {\n            foreach (int j in abundants) {\n                abundant_sums.Add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundant_sums.Contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string LexicographicPermutations(int n) {\n        string result = \"\";\n        IList<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += idx.ToString();\n            digits.RemoveAt(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NDigitFibonacciNumber(int n) {\n        IList<int> a = new List<int> { 1 };\n        IList<int> b = new List<int> { 1 };\n        int i = 2;\n        while (b.Count < n) {\n            int carry = 0;\n            IList<int> c = new List<int>(b);\n            for (int j = 0; j < b.Count; j++) {\n                if (j < a.Count) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry) {\n                b.Add(carry);\n            }\n            a = c;\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int ReciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            IList<int> remainders = new List<int>();\n            int remainder = 1;\n            while (remainder != 0 && !remainders.Contains(remainder)) {\n                remainders.Add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder != 0) {\n                length = remainders.Count - remainders.IndexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int QuadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a <= n; a += 2) {\n            for (int b = -n + 1; b <= n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!IsPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x += 1;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NumberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DistinctPowers(int n) {\n        int result = 0;\n        HashSet<string> xs = new HashSet<string>();\n        for (int i = 2; i <= n; i++) {\n            int[] primes = new int[] { 2, 3, 5, 7 };\n            int[] powers = new int[] { 0, 0, 0, 0 };\n            int num = i;\n            for (int j = 0; j < primes.Length; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num != 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                string pstr = $\"{powers[0] * j}-{powers[1] * j}-{powers[2] * j}-{powers[3] * j}\";\n                xs.Add(pstr);\n            }\n        }\n        result += xs.Count;\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * (int)Math.Pow(10, n); i++) {\n            int digits_sum = 0;\n            foreach (char digit in i.ToString()) {\n                digits_sum += (int)Math.Pow(digit - '0', n);\n            }\n            if (i == digits_sum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int CoinSums(int n) {\n        int[] coins = new int[] { 1, 2, 5, 10, 20, 50, 100, 200 };\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        foreach (int coin in coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int PandigitalProducts(int n) {\n        HashSet<int> products = new HashSet<int>();\n        string s = string.Join(\"\", Enumerable.Range(1, n).Select(i => i.ToString()));\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                List<char> chars = new List<char>(str(a) + str(b) + str(c));\n                chars.Sort();\n                if (string.Join(\"\", chars) == s) {\n                    products.Add(c);\n                }\n            }\n        }\n        int result = 0;\n        foreach (int product in products) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int DigitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int fact_sum = 0;\n            foreach (char digit in i.ToString()) {\n                int fact = 1;\n                for (int j = 1; j <= int.Parse(digit.ToString()); j++) {\n                    fact *= j;\n                }\n                fact_sum += fact;\n            }\n            if (i == fact_sum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int CircularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (IsPrime(i)) {\n                HashSet<int> rotations = new HashSet<int>();\n                for (int j = 0; j < i.ToString().Length; j++) {\n                    rotations.Add(int.Parse(i.ToString().Substring(j) + i.ToString().Substring(0, j)));\n                }\n                bool flag = true;\n                foreach (int x in rotations) {\n                    if (!IsPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count += 1;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i] != s[s.Length - (i + 1)]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int DoubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            string str_i = i.ToString();\n            string bin_i = Convert.ToString(i, 2);\n            if (IsPalindrome(str_i) && IsPalindrome(bin_i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int TruncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                bool flag = true;\n                for (int j = 1; j < si.Length; j++) {\n                    int p1 = int.Parse(si.Substring(j));\n                    int p2 = int.Parse(si.Substring(0, si.Length - j));\n                    if (!IsPrime(p1) || !IsPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            string cprod = \"\";\n            for (int j = 1; j <= 9; j++) {\n                cprod += (i * j).ToString();\n                if (cprod.Length == 9) {\n                    if (string.Concat(cprod.OrderBy(c => c)) == \"123456789\") {\n                        result = Math.Max(result, int.Parse(cprod));\n                        break;\n                    }\n                } else if (cprod.Length > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int IntegerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a <= p / 2; a++) {\n                for (int b = a; b <= p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol += 1;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int ChampernowneConstant(int b) {\n        string s = \"\";\n        for (int i = 1; i < (int)Math.Pow(b, 6); i++) {\n            s += i.ToString();\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            result *= int.Parse(s[(int)Math.Pow(b, i) - 1].ToString());\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int PandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                int length = si.Length;\n                bool flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.Contains(j.ToString())) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int CodedTriangleNumbers(IList<string> words) {\n        int result = 0;\n        foreach (string word in words) {\n            int value = 0;\n            foreach (char c in word) {\n                value += (int)c - 64;\n            }\n            int n = (int)Math.Sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int SubStringDivisibility(int n) {\n        int result = 0;\n        int[] primes = new int[] { 2, 3, 5, 7, 11, 13, 17 };\n        string s = string.Join(\"\", Enumerable.Range(0, n + 1).Select(i => i.ToString()));\n        foreach (string i in GenPermutations(s)) {\n            bool flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if int.Parse(i.Substring(j, 3)) % primes[j - 1] != 0 {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += int.Parse(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PentagonNumbers(int n) {\n        HashSet<int> pentagon = new HashSet<int>();\n        for (int i = 1; i < n; i++) {\n            pentagon.Add(i * (3 * i - 1) / 2);\n        }\n        int result = -1;\n        foreach (int j in pentagon) {\n            foreach (int k in pentagon) {\n                if (j + k in pentagon && k - j in pentagon) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int TriangularPentagonalAndHexagonal(int n) {\n        HashSet<int> ps = new HashSet<int>();\n        int i = 1;\n        int c = (int) (0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i += 1;\n            ps.Add(c);\n            c = (int) (0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i += 1;\n            if (ps.Contains(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int GoldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i >= n; i -= 2) {\n            int upper = (int)Math.Sqrt(i / 2);\n            bool flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (IsPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PrimeFactors(int n) {\n        int num = n;\n        IList<int> factors = new List<int>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i != 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.Add(i);\n            }\n        }\n        if (num > 1) {\n            factors.Add(num);\n        }\n        return factors.Count;\n    }\n\n    public static int DistinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string SelfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] temp_digits = new int[10];\n            temp_digits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    temp_digits[k] = temp_digits[k] * i + carry;\n                    carry = temp_digits[k] / 10;\n                    temp_digits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += temp_digits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        string result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += digits[i].ToString();\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static string PrimePermutations(int n) {\n        for (int i = n; i >= 999; i--) {\n            if (IsPrime(i)) {\n                IList<string> permutations = GenPermutations(i.ToString());\n                HashSet<int> candidates = new HashSet<int>();\n                foreach (string j in permutations) {\n                    int candidate = int.Parse(j);\n                    if (candidate > i && IsPrime(candidate)) {\n                        candidates.Add(candidate);\n                    }\n                }\n                foreach (int m in candidates) {\n                    if (m + (m - i) in candidates) {\n                        return i.ToString() + m.ToString() + (m + (m - i)).ToString();\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int ConsecutivePrimeSum(int limit) {\n        bool[] sieve = new bool[limit];\n        for (int i = 0; i < limit; i++) {\n            sieve[i] = true;\n        }\n        IList<int> primes = new List<int>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.Add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int max_length = 0;\n        int max_prime = 0;\n        for (int i = 0; i < primes.Count; i++) {\n            for (int j = i + max_length; j < primes.Count; j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes[k];\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > max_length) {\n                    max_length = j - i;\n                    max_prime = s;\n                }\n            }\n        }\n        return max_prime;\n    }\n}"
            ],
            "go": [
                "func MultiplesOf3And5(n int) int {\n    result := 0\n    for i := 0; i < n; i++ {\n        if i%3 == 0 || i%5 == 0 {\n            result += i\n        }\n    }\n    return result\n}",
                "func EvenFibonacciNumbers(n int) int {\n    result := 0\n    a := 1\n    b := 2\n    for a < n {\n        if a%2 == 0 {\n            result += a\n        }\n        tmp := a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
                "func LargestPrimeFactor(n int) int {\n    result := n\n    i := 2\n    for i*i <= result {\n        if result % i != 0 {\n            i++\n        } else {\n            result /= i\n        }\n    }\n    return result\n}",
                "func IsPalindrome(s string) bool {\n    for i := 0; i < len(s)/2; i++ {\n        if s[i] != s[len(s)-i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc LargestPalindromeProduct(n int) int {\n    result := 0\n    for i := 100; i < 1000; i++ {\n        for j := i; j < 1000; j++ {\n            prod := i * j\n            if IsPalindrome(strconv.Itoa(prod)) && prod > result && prod < n {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
                "func SmallestMultiple(n int) int {\n    result := 1\n    for i := 1; i < n + 1; i++ {\n        if result % i != 0 {\n            for j := 1; j < n + 1; j++ {\n                if (result * j) % i == 0 {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
                "func SumSquareDifference(n int) int {\n    sqrSum := 0\n    numSum := 0\n    for i := 1; i < n + 1; i++ {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
                "func NthPrime(n int) int {\n    primes := []int{2}\n    i := 3\n    for len(primes) < n {\n        for _, p := range primes {\n            if i%p == 0 {\n                break\n            }\n            if p*p > i {\n                primes = append(primes, i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes[len(primes)-1]\n}",
                "func LargestProductInASeries(s string, k int) int {\n    result := 0\n    for i := 0; i < len(s) - k; i++ {\n        product := 1\n        for j := 0; j < k; j++ {\n            product *= int(s[i + j])\n        }\n        result = max(result, product)\n    }\n    return result\n}",
                "func SpecialPythagoreanTriplet(n int) int {\n    for a := 1; a < n; a++ {\n        for b := a; b < n; b++ {\n            c := n - a - b\n            if a*a+b*b == c*c {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
                "func SummationOfPrimes(n int) int {\n    primes := []int{2}\n    i := 3\n    for i <= n {\n        for _, p := range primes {\n            if i%p == 0 {\n                break\n            }\n            if p*p > i {\n                primes = append(primes, i)\n                break\n            }\n        }\n        i += 2\n    }\n    result := 0\n    for _, prime := range primes {\n        result += prime\n    }\n    return result\n}",
                "func LargestProductInAGrid(grid [][]int) int {\n    result := 0\n    for i := 0; i < len(grid) - 3; i++ {\n        for j := 0; j < len(grid[i]) - 3; j++ {\n            p1, p2, p3, p4 := 1, 1, 1, 1\n            for k := 0; k < 4; k++ {\n                p1 *= grid[i + k][j]\n            }\n            for k := 0; k < 4; k++ {\n                p2 *= grid[i][j + k]\n            }\n            for k := 0; k < 4; k++ {\n                p3 *= grid[i + k][j + k]\n            }\n            for k := 0; k < 4; k++ {\n                p4 *= grid[i + k][j + 3 - k]\n            }\n            result = max(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
                "func HighlyDivisibleTriangularNumber(n int) int {\n    for i := 1; i < 100000000; i++ {\n        result := i * (i + 1) / 2\n        count := 0\n        for j := 1; j <= int(math.Sqrt(float64(result))) + 1; j++ {\n            if result % j == 0 {\n                count += 2\n            }\n            if j*j == result {\n                count -= 1\n            }\n        }\n        if count > n {\n            return result\n        }\n    }\n    return -1\n}",
                "func LargeSum(numbers []string) string {\n    digits := make([]int, 60)\n    for i := 0; i < 50; i++ {\n        tmp := 0\n        for _, num := range numbers {\n            tmp += int(num[49 - i]) - '0'\n        }\n        for j := i; j < 60; j++ {\n            digits[j] += tmp % 10\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if tmp == 0 {\n                break\n            }\n        }\n    }\n    for i := 59; i >= 0; i-- {\n        if digits[i] != 0 {\n            result := \"\"\n            for j := i; j > i - 10; j-- {\n                result += strconv.Itoa(digits[j])\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
                "func LongestCollatzSequence(n int) int {\n    longest := 0\n    result := 0\n    for i := 1; i < n; i++ {\n        chain := 1\n        num := i\n        for num != 1 {\n            if num%2 == 0 {\n                num /= 2\n            } else {\n                num = 3*num + 1\n            }\n            chain++\n        }\n        if chain > longest {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
                "func LatticePaths(m int, n int) int {\n    grid := make([][]int, m + 1)\n    for i := 0; i < m + 1; i++ {\n        grid[i] = make([]int, n + 1)\n    }\n    for i := 0; i < m + 1; i++ {\n        grid[i][0] = 1\n    }\n    for j := 0; j < n + 1; j++ {\n        grid[0][j] = 1\n    }\n    for i := 1; i < m + 1; i++ {\n        for j := 1; j < n + 1; j++ {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
                "func PowerDigitSum(n int) int {\n    digits := []int{2}\n    for i := 1; i < n; i++ {\n        carry := 0\n        for j := 0; j < len(digits); j++ {\n            temp := digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if carry != 0 {\n            digits = append(digits, carry)\n        }\n    }\n    result := 0\n    for _, digit := range digits {\n        result += digit\n    }\n    return result\n}",
                "func NumberToWords(n int) string {\n    ones := []string{\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    teens := []string{\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"}\n    tens := []string{\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"}\n    if n == 1000 {\n        return \"one thousand\"\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n / 100] + \" hundred\"\n        } else {\n            return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100)\n        }\n    } else if n >= 20 {\n        suf := \"\"\n        if n % 10 != 0 {\n            suf = \" \" + ones[n % 10]\n        }\n        return tens[n / 10] + suf\n    } else if n >= 10 {\n        return teens[n - 10]\n    } else {\n        return ones[n]\n    }\n}",
                "func MaximumPathSumI(triangle [][]int) int {\n    curr := make([]int, len(triangle[len(triangle)-1]))\n    copy(curr, triangle[len(triangle)-1])\n    for i := len(triangle) - 2; i >= 0; i-- {\n        next := make([]int, len(triangle[i]))\n        copy(next, triangle[i])\n        for j := range next {\n            next[j] += max(curr[j], curr[j+1])\n        }\n        curr = next\n    }\n    return curr[0]\n}",
                "func CountingSundays(y1 int, y2 int) int {\n    day := 0\n    count := 0\n    for year := 1900; year <= y2; year++ {\n        for month := 1; month <= 12; month++ {\n            if year >= y1 && day%7 == 6 {\n                count++\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30\n            } else if month == 2 {\n                if year%4 == 0 && (year%100 != 0 || year%400 == 0) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
                "func FactorialDigitSum(n int) int {\n    digits := []int{1}\n    for i := 1; i < n+1; i++ {\n        carry := 0\n        for j := 0; j < len(digits); j++ {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        for carry != 0 {\n            digits = append(digits, carry%10)\n            carry /= 10\n        }\n    }\n    result := 0\n    for _, digit := range digits {\n        result += digit\n    }\n    return result\n}",
                "func D(n int) int {\n    result := 1\n    for i := 2; i <= int(math.Sqrt(float64(n)))+1; i++ {\n        if n%i == 0 {\n            result += i\n            if i != n/i {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfunc AmicableNumbers(n int) int {\n    result := 0\n    for a := 2; a < n; a++ {\n        b := D(a)\n        if a != b && a == D(b) {\n            result += a\n        }\n    }\n    return result\n}",
                "func NamesScores(names []string, queries []string) int {\n    s_names := make([]string, len(names))\n    copy(s_names, names)\n    sort.Strings(s_names)\n    result := 0\n    for i, name := range s_names {\n        x := 0\n        for _, c := range name {\n            x += int(c) - 64\n        }\n        if strings.Contains(queries, name) {\n            result += x * (i + 1)\n        }\n    }\n    return result\n}",
                "func IsAbundant(n int) bool {\n    if n < 12 {\n        return false\n    }\n    sumDivisors := 1\n    for i := 2; i <= int(math.Sqrt(float64(n)))+1; i++ {\n        if n%i == 0 {\n            sumDivisors += i\n            if i != n/i {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfunc NonAbundantSums(n int) int {\n    abundants := []int{}\n    for i := 12; i < n; i++ {\n        if IsAbundant(i) {\n            abundants = append(abundants, i)\n        }\n    }\n    abundantSums := map[int]bool{}\n    for _, i := range abundants {\n        for _, j := range abundants {\n            abundantSums[i+j] = true\n        }\n    }\n    result := 0\n    for i := 0; i < n; i++ {\n        if !abundantSums[i] {\n            result += i\n        }\n    }\n    return result\n}",
                "func LexicographicPermutations(n int) string {\n    result := \"\"\n    digits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    x := n - 1\n    for i := 10; i > 0; i-- {\n        fact := 1\n        for j := 1; j < i; j++ {\n            fact *= j\n        }\n        idx := x / fact\n        result += strconv.Itoa(digits[idx])\n        digits = append(digits[:idx], digits[idx+1:]...)\n        x -= idx * fact\n    }\n    return result\n}",
                "func NDigitFibonacciNumber(n int) int {\n    a := []int{1}\n    b := []int{1}\n    i := 2\n    for len(b) < n {\n        carry := 0\n        c := make([]int, len(b))\n        copy(c, b)\n        for j := 0; j < len(b); j++ {\n            if j < len(a) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if carry {\n            b = append(b, carry)\n        }\n        a = c\n        i = i + 1\n    }\n    return i\n}",
                "func ReciprocalCycles(n int) int {\n    result := 0\n    maxLength := 0\n    for i := 1; i < n; i++ {\n        remainders := []int{}\n        remainder := 1\n        for remainder != 0 && !contains(remainders, remainder) {\n            remainders = append(remainders, remainder)\n            remainder = (remainder * 10) % i\n        }\n        length := 0\n        if remainder != 0 {\n            length = len(remainders) - indexOf(remainders, remainder)\n        }\n        if length > maxLength {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n\nfunc indexOf(s []int, e int) int {\n    for i, a := range s {\n        if a == e {\n            return i\n        }\n    }\n    return -1\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n)))+1; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc QuadraticPrimes(n int) int {\n    maxPrimes := 0\n    result := 0\n    for a := -n + 1; a < n; a += 2 {\n        for b := -n + 1; b < n; b += 2 {\n            x := 0\n            for {\n                if x*x+a*x+b < 2 {\n                    break\n                }\n                if !IsPrime(x*x + a*x + b) {\n                    break\n                }\n                x++\n            }\n            if x > maxPrimes {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
                "func NumberSpiralDiagonals(n int) int {\n    result := 1\n    for i := 3; i < n+1; i += 2 {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
                "func DistinctPowers(n int) int {\n    result := 0\n    xs := map[string]bool{}\n    for i := 2; i <= n; i++ {\n        primes := []int{2, 3, 5, 7}\n        powers := []int{0, 0, 0, 0}\n        num := i\n        for j := 0; j < len(primes); j++ {\n            for num%primes[j] == 0 {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if num != 1 {\n            result += n - 1\n            continue\n        }\n        for j := 2; j <= n; j++ {\n            pstr := fmt.Sprintf(\"%d-%d-%d-%d\", powers[0]*j, powers[1]*j, powers[2]*j, powers[3]*j)\n            xs[pstr] = true\n        }\n    }\n    result += len(xs)\n    return result\n}",
                "func DigitNthPowers(n int) int {\n    result := 0\n    for i := 2; i < 4*10**n; i++ {\n        digitsSum := 0\n        for _, digit := range strconv.Itoa(i) {\n            digitsSum += int(digit - '0') ** n\n        }\n        if i == digitsSum {\n            result += i\n        }\n    }\n    return result\n}",
                "func CoinSums(n int) int {\n    coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\n    ways := make([]int, n + 1)\n    ways[0] = 1\n    for _, coin := range coins {\n        for i := coin; i <= n; i++ {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
                "func PandigitalProducts(n int) int {\n    products := map[int]bool{}\n    s := \"123456789\"[:n]\n    for a := 1; a < 100; a++ {\n        for b := 1; b < 10000; b++ {\n            c := a * b\n            chars := []byte(strconv.Itoa(a) + strconv.Itoa(b) + strconv.Itoa(c))\n            sort.Slice(chars, func(i, j int) bool { return chars[i] < chars[j] })\n            if string(chars) == s {\n                products[c] = true\n            }\n        }\n    }\n    result := 0\n    for product := range products {\n        result += product\n    }\n    return result\n}",
                "func DigitCancelingFractions(m int) int {\n    numer := 1\n    denom := 1\n    for d := 10; d < m; d++ {\n        for n := 10; n < d; n++ {\n            n0, n1 := n % 10, n / 10\n            d0, d1 := d % 10, d / 10\n            if (n1 == d0 && n0*d == n*d1) || (n0 == d1 && n1*d == n*d0) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    a, b := numer, denom\n    for b != 0 {\n        a, b = b, a%b\n    }\n    return denom / a\n}",
                "func DigitFactorials(n int) int {\n    result := 0\n    for i := 3; i < n; i++ {\n        factSum := 0\n        for _, digit := range strconv.Itoa(i) {\n            fact := 1\n            for j := 1; j < int(digit) + 1; j++ {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if i == factSum {\n            result += i\n        }\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n)))+1; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc CircularPrimes(n int) int {\n    count := 0\n    for i := 2; i < n; i++ {\n        if IsPrime(i) {\n            rotations := make(map[int]bool)\n            for j := 0; j < len(strconv.Itoa(i)); j++ {\n                rotations[int(strconv.Itoa(i)[j:] + strconv.Itoa(i)[:j])] = true\n            }\n            flag := true\n            for x := range rotations {\n                if !IsPrime(x) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                count++\n            }\n        }\n    }\n    return count\n}",
                "func IsPalindrome(s string) bool {\n    for i := 0; i < len(s)/2; i++ {\n        if s[i] != s[len(s)-(i+1)] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc DoubleBasePalindromes(n int) int {\n    result := 0\n    for i := 1; i < n; i++ {\n        str_i := strconv.Itoa(i)\n        bin_i := strconv.FormatInt(int64(i), 2)\n        if IsPalindrome(str_i) && IsPalindrome(bin_i) {\n            result += i\n        }\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n)))+1; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TruncatablePrimes(n int) int {\n    result := 0\n    for i := 10; i < n; i++ {\n        if IsPrime(i) {\n            si := strconv.Itoa(i)\n            flag := true\n            for j := 1; j < len(si); j++ {\n                p1, _ := strconv.Atoi(si[j:])\n                p2, _ := strconv.Atoi(si[:len(si)-j])\n                if !IsPrime(p1) || !IsPrime(p2) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                result += i\n            }\n        }\n    }\n    return result\n}",
                "func PandigitalMultiples(n int) int {\n    result := -1\n    for i := 2; i <= n; i++ {\n        cprod := \"\"\n        for j := 1; j <= 9; j++ {\n            cprod += strconv.Itoa(i * j)\n            if len(cprod) == 9 {\n                if strings.Join(sort.StringSlice(cprod), \"\") == \"123456789\" {\n                    result = max(result, strconv.Atoi(cprod))\n                    break\n                }\n            } else if len(cprod) > 9 {\n                break\n            }\n        }\n    }\n    return result\n}",
                "func IntegerRightTriangles(n int) int {\n    maxSol := 0\n    result := 0\n    for p := 3; p <= n; p++ {\n        sol := 0\n        for a := 1; a < p / 2; a++ {\n            for b := a; b < p / 2; b++ {\n                c := p - a - b\n                if a*a+b*b == c*c {\n                    sol++\n                }\n            }\n        }\n        if sol > maxSol {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
                "func ChampernowneConstant(b int) int {\n    s := \"\"\n    for i := 1; i < b**6; i++ {\n        s += strconv.Itoa(i)\n    }\n    result := 1\n    for i := 7; i > 0; i-- {\n        num, _ := strconv.Atoi(s[b**(i-1) - 1])\n        result *= num\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc PandigitalPrime(n int) int {\n    for i := n - 1; i > 0; i-- {\n        if IsPrime(i) {\n            si := strconv.Itoa(i)\n            length := len(si)\n            flag := true\n            for j := 1; j <= length; j++ {\n                if !strings.Contains(si, strconv.Itoa(j)) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                return i\n            }\n        }\n    }\n    return -1\n}",
                "func CodedTriangleNumbers(words []string) int {\n    result := 0\n    for _, word := range words {\n        value := 0\n        for _, c := range word {\n            value += int(c) - 64\n        }\n        n := int(math.Sqrt(float64(value * 2)))\n        if n * (n + 1) == value * 2 {\n            result += 1\n        }\n    }\n    return result\n}",
                "func GenPermutations(s string) []string {\n    if len(s) <= 1 {\n        return []string{s}\n    }\n    result := []string{}\n    for _, perm := range GenPermutations(s[1:]) {\n        for i := 0; i < len(s); i++ {\n            result = append(result, perm[:i] + s[0:1] + perm[i:])\n        }\n    }\n    return result\n}\n\nfunc SubStringDivisibility(n int) int {\n    result := 0\n    primes := []int{2, 3, 5, 7, 11, 13, 17}\n    s := strings.Join([]string{strconv.Itoa(i) for i := 0; i < n + 1}, \"\")\n    for _, i := range GenPermutations(s) {\n        flag := true\n        for j := 1; j < n - 1; j++ {\n            num, _ := strconv.Atoi(i[j:j + 3])\n            if num % primes[j - 1] != 0 {\n                flag = false\n                break\n            }\n        }\n        if flag {\n            num, _ := strconv.Atoi(i)\n            result += num\n        }\n    }\n    return result\n}",
                "func PentagonNumbers(n int) int {\n    pentagon := map[int]bool{}\n    for i := 1; i < n; i++ {\n        pentagon[i*(3*i-1)/2] = true\n    }\n    result := -1\n    for j := range pentagon {\n        for k := range pentagon {\n            if pentagon[j+k] && pentagon[k-j] {\n                if result == -1 || k-j < result {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
                "func TriangularPentagonalAndHexagonal(n int) int {\n    ps := map[int]bool{}\n    i := 1\n    c := 0.5 * i * (3 * i - 1)\n    for c < n {\n        i += 1\n        ps[c] = true\n        c = 0.5 * i * (3 * i - 1)\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    result := -1\n    for c < n {\n        i += 1\n        if _, ok := ps[c]; ok {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc GoldbachsOtherConjecture(n int) int {\n    result := -1\n    for i := 9999; i >= n; i -= 2 {\n        upper := int(math.Sqrt(float64(i / 2)))\n        flag := false\n        for j := 0; j <= upper; j++ {\n            if IsPrime(i - 2*j*j) {\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            result = i\n        }\n    }\n    return result\n}",
                "func PrimeFactors(n int) int {\n    num := n\n    factors := []int{}\n    i := 2\n    for i*i <= num {\n        if num%i != 0 {\n            i++\n        } else {\n            num /= i\n            factors = append(factors, i)\n        }\n    }\n    if num > 1 {\n        factors = append(factors, num)\n    }\n    return len(factors)\n}\n\nfunc DistinctPrimesFactors(n int) int {\n    for i := n; i < 1000000; i++ {\n        if PrimeFactors(i) == 4 && PrimeFactors(i+1) == 4 && PrimeFactors(i+2) == 4 && PrimeFactors(i+3) == 4 {\n            return i\n        }\n    }\n    return -1\n}",
                "func SelfPowers(n int) string {\n    digits := make([]int, 10)\n    for i := 1; i <= n; i++ {\n        tempDigits := make([]int, 10)\n        tempDigits[0] = 1\n        for j := 0; j < i; j++ {\n            carry := 0\n            for k := 0; k < 10; k++ {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for j := 0; j < 10; j++ {\n            digits[j] += tempDigits[j]\n            if digits[j] >= 10 {\n                digits[j] -= 10\n                if j < 9 {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    result := \"\"\n    for i := 9; i >= 0; i-- {\n        result += strconv.Itoa(digits[i])\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n%2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n)))+1; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc GenPermutations(s string) []string {\n    if len(s) <= 1 {\n        return []string{s}\n    }\n    result := []string{}\n    for _, perm := range GenPermutations(s[1:]) {\n        for i := 0; i < len(s); i++ {\n            result = append(result, perm[:i]+s[0:1]+perm[i:])\n        }\n    }\n    return result\n}\n\nfunc PrimePermutations(n int) string {\n    for i := n; i >= 100; i-- {\n        if IsPrime(i) {\n            permutations := GenPermutations(strconv.Itoa(i))\n            candidates := map[int]bool{}\n            for _, j := range permutations {\n                candidate, _ := strconv.Atoi(j)\n                if candidate > i && IsPrime(candidate) {\n                    candidates[candidate] = true\n                }\n            }\n            for m := range candidates {\n                if m+(m-i) in candidates {\n                    return strconv.Itoa(i) + strconv.Itoa(m) + strconv.Itoa(m+(m-i))\n                }\n            }\n        }\n    }\n    return \"\"\n}",
                "func ConsecutivePrimeSum(limit int) int {\n    sieve := make([]bool, limit)\n    for i := 2; i < limit; i++ {\n        sieve[i] = true\n    }\n    primes := []int{}\n    for i := 2; i < limit; i++ {\n        if sieve[i] {\n            primes = append(primes, i)\n            for j := i * 2; j < limit; j += i {\n                sieve[j] = false\n            }\n        }\n    }\n    maxLength := 0\n    maxPrime := 0\n    for i := 0; i < len(primes); i++ {\n        for j := i + maxLength; j < len(primes); j++ {\n            s := 0\n            for _, p := range primes[i:j] {\n                s += p\n            }\n            if s >= limit {\n                break\n            }\n            if sieve[s] && j-i > maxLength {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
            ],
            "java": [
                "class Global {\n    public static int multiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int evenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int largestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (isPalindrome(Integer.toString(prod)) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int smallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i != 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int sumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int nthPrime(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (primes.size() < n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes.get(primes.size() - 1);\n    }\n}",
                "class Global {\n    public static int largestProductInASeries(String s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.length() - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= Integer.parseInt(s.substring(i + j, i + j + 1));\n            }\n            result = Math.max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int specialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int summationOfPrimes(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (i <= n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        for (int prime : primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestProductInAGrid(List<List<Integer>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.size() - 3; i++) {\n            for (int j = 0; j < grid.get(i).size() - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid.get(i + k).get(j);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid.get(i).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid.get(i + k).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid.get(i + k).get(j + 3 - k);\n                }\n                result = Math.max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int highlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= Math.sqrt(result) + 1; j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String largeSum(List<String> numbers) {\n        int[] digits = new int[60];\n        for (int i = 50; i < 60; i++) {\n            int tmp = 0;\n            for (String num : numbers) {\n                tmp += Integer.parseInt(num.substring(49 - i, 50 - i));\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i] != 0) {\n                String result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += String.valueOf(digits[j]);\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int longestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num /= 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int latticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int powerDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(2);\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                int temp = digits.get(j) * 2 + carry;\n                digits.set(j, temp % 10);\n                carry = temp / 10;\n            }\n            if (carry != 0) {\n                digits.add(carry);\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String numberToWords(int n) {\n        String[] ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        String[] teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        String[] tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            String suf = \"\";\n            if (n % 10 != 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int maximumPathSumI(List<List<Integer>> triangle) {\n        List<Integer> curr = new ArrayList<>(triangle.get(triangle.size() - 1));\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            List<Integer> next = new ArrayList<>(triangle.get(i));\n            for (int j = 0; j < next.size(); j++) {\n                next.set(j, next.get(j) + Math.max(curr.get(j), curr.get(j + 1)));\n            }\n            curr = next;\n        }\n        return curr.get(0);\n    }\n}",
                "class Global {\n    public static int countingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count += 1;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int factorialDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(1);\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                digits.set(j, digits.get(j) * i + carry);\n                carry = digits.get(j) / 10;\n                digits.set(j, digits.get(j) % 10);\n            }\n            while (carry != 0) {\n                digits.add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int d(int n) {\n        int result = 1;\n        for (int i = 2; i <= Math.sqrt(n) + 1; i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i != n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int amicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = d(a);\n            if (a != b && a == d(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int namesScores(List<String> names, List<String> queries) {\n        List<String> sNames = new ArrayList<>(names);\n        Collections.sort(sNames);\n        int result = 0;\n        for (int i = 0; i < sNames.size(); i++) {\n            int x = 0;\n            for (int j = 0; j < sNames.get(i).length(); j++) {\n                x += sNames.get(i).charAt(j) - 64;\n            }\n            if (queries.contains(sNames.get(i))) {\n                result += x * (i + 1);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= Math.sqrt(n) + 1; i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i != n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int nonAbundantSums(int n) {\n        List<Integer> abundants = new ArrayList<>();\n        for (int i = 12; i < n; i++) {\n            if (isAbundant(i)) {\n                abundants.add(i);\n            }\n        }\n        Set<Integer> abundantSums = new HashSet<>();\n        for (int i : abundants) {\n            for (int j : abundants) {\n                abundantSums.add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String lexicographicPermutations(int n) {\n        String result = \"\";\n        List<Integer> digits = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            digits.add(i);\n        }\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += String.valueOf(digits.get(idx));\n            digits.remove(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int nDigitFibonacciNumber(int n) {\n        List<Integer> a = new ArrayList<>();\n        a.add(1);\n        List<Integer> b = new ArrayList<>();\n        b.add(1);\n        int i = 2;\n        while (b.size() < n) {\n            int carry = 0;\n            List<Integer> c = new ArrayList<>(b);\n            for (int j = 0; j < b.size(); j++) {\n                if (j < a.size()) {\n                    b.set(j, a.get(j) + b.get(j) + carry);\n                } else {\n                    b.set(j, b.get(j) + carry);\n                }\n                carry = b.get(j) / 10;\n                b.set(j, b.get(j) % 10);\n            }\n            if (carry) {\n                b.add(carry);\n            }\n            a = c;\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int reciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            List<Integer> remainders = new ArrayList<>();\n            int remainder = 1;\n            while (remainder != 0 && !remainders.contains(remainder)) {\n                remainders.add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder != 0) {\n                length = remainders.size() - remainders.indexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int quadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!isPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x += 1;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int numberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int distinctPowers(int n) {\n        int result = 0;\n        Set<String> xs = new HashSet<>();\n        for (int i = 2; i <= n; i++) {\n            int[] primes = {2, 3, 5, 7};\n            int[] powers = {0, 0, 0, 0};\n            int num = i;\n            for (int j = 0; j < primes.length; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num != 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                String pstr = powers[0] * j + \"-\" + powers[1] * j + \"-\" + powers[2] * j + \"-\" + powers[3] * j;\n                xs.add(pstr);\n            }\n        }\n        result += xs.size();\n        return result;\n    }\n}",
                "class Global {\n    public static int digitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * (int) Math.pow(10, n); i++) {\n            int digitsSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                digitsSum += (int) Math.pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int coinSums(int n) {\n        int[] coins = {1, 2, 5, 10, 20, 50, 100, 200};\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int pandigitalProducts(int n) {\n        Set<Integer> products = new HashSet<>();\n        String s = String.join(\"\", Arrays.stream(new Integer[n]).map(i -> String.valueOf(i)).toArray(String[]::new));\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                List<String> chars = new ArrayList<>();\n                chars.add(String.valueOf(a));\n                chars.add(String.valueOf(b));\n                chars.add(String.valueOf(c));\n                Collections.sort(chars);\n                if (String.join(\"\", chars).equals(s)) {\n                    products.add(c);\n                }\n            }\n        }\n        int result = 0;\n        for (int product : products) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int digitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int digitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int fact_sum = 0;\n            for (int digit : String.valueOf(i).chars().map(c -> c - '0').toArray()) {\n                int fact = 1;\n                for (int j = 1; j <= digit; j++) {\n                    fact *= j;\n                }\n                fact_sum += fact;\n            }\n            if (i == fact_sum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int circularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                Set<Integer> rotations = new HashSet<>();\n                for (int j = 0; j < String.valueOf(i).length(); j++) {\n                    rotations.add(Integer.parseInt(String.valueOf(i).substring(j) + String.valueOf(i).substring(0, j)));\n                }\n                boolean flag = true;\n                for (int x : rotations) {\n                    if (!isPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int doubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            String str_i = Integer.toString(i);\n            String bin_i = Integer.toBinaryString(i);\n            if (isPalindrome(str_i) && isPalindrome(bin_i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int truncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (isPrime(i)) {\n                String si = String.valueOf(i);\n                boolean flag = true;\n                for (int j = 1; j < si.length(); j++) {\n                    int p1 = Integer.parseInt(si.substring(j));\n                    int p2 = Integer.parseInt(si.substring(0, si.length() - j));\n                    if (!isPrime(p1) || !isPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            String cprod = \"\";\n            for (int j = 1; j <= 9; j++) {\n                cprod += String.valueOf(i * j);\n                if (cprod.length() == 9) {\n                    if (cprod.chars().sorted().collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString().equals(\"123456789\")) {\n                        result = Math.max(result, Integer.parseInt(cprod));\n                        break;\n                    }\n                } else if (cprod.length() > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int integerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a <= p / 2; a++) {\n                for (int b = a; b <= p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol += 1;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int champernowneConstant(int b) {\n        String s = \"\";\n        for (int i = 1; i < (int)Math.pow(b, 6); i++) {\n            s += String.valueOf(i);\n        }\n        int result = 1;\n        for (int i = 7; i > 0; i--) {\n            result *= Integer.parseInt(s.substring(b - 1, b - 1 + i));\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int pandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (isPrime(i)) {\n                String si = String.valueOf(i);\n                int length = si.length();\n                boolean flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.contains(String.valueOf(j))) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int codedTriangleNumbers(List<String> words) {\n        int result = 0;\n        for (String word : words) {\n            int value = 0;\n            for (char c : word.toCharArray()) {\n                value += c - 64;\n            }\n            int n = (int) Math.sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return Arrays.asList(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int subStringDivisibility(int n) {\n        int result = 0;\n        int[] primes = {2, 3, 5, 7, 11, 13, 17};\n        String s = String.join(\"\", Arrays.stream(new Integer[n + 1]).map(i -> String.valueOf(i)).toArray(String[]::new));\n        for (String i : genPermutations(s)) {\n            boolean flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (Integer.parseInt(i.substring(j, j + 3)) % primes[j - 1] != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += Integer.parseInt(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pentagonNumbers(int n) {\n        Set<Integer> pentagon = new HashSet<>();\n        for (int i = 1; i < n; i++) {\n            pentagon.add(i * (3 * i - 1) / 2);\n        }\n        int result = -1;\n        for (int j : pentagon) {\n            for (int k : pentagon) {\n                if (pentagon.contains(j + k) && pentagon.contains(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int triangularPentagonalAndHexagonal(int n) {\n        Set<Integer> ps = new HashSet<>();\n        int i = 1;\n        int c = (int) (0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i += 1;\n            ps.add(c);\n            c = (int) (0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i += 1;\n            if (ps.contains(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int goldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i >= n; i -= 2) {\n            int upper = (int) Math.sqrt(i / 2);\n            boolean flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (isPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int primeFactors(int n) {\n        int num = n;\n        List<Integer> factors = new ArrayList<>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i != 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.add(i);\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        return new HashSet<>(factors).size();\n    }\n\n    public static int distinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String selfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        String result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += String.valueOf(digits[i]);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return Collections.singletonList(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static String primePermutations(int n) {\n        for (int i = n; i >= 999; i--) {\n            if (isPrime(i)) {\n                List<String> permutations = genPermutations(String.valueOf(i));\n                Set<Integer> candidates = new HashSet<>();\n                for (String j : permutations) {\n                    int candidate = Integer.parseInt(j);\n                    if (candidate > i && isPrime(candidate)) {\n                        candidates.add(candidate);\n                    }\n                }\n                for (int m : candidates) {\n                    if (m + (m - i) in candidates) {\n                        return String.valueOf(i) + String.valueOf(m) + String.valueOf(m + (m - i));\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int consecutivePrimeSum(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + maxLength; j < primes.size(); j++) {\n                int s = primes.subList(i, j).stream().mapToInt(Integer::intValue).sum();\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
            ],
            "javascript": [
                "const multiplesOf3And5 = (n) => {\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const evenFibonacciNumbers = (n) => {\n    let result = 0;\n    let a = 1;\n    let b = 2;\n    while (a < n) {\n        if (a % 2 === 0) {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "const largestPrimeFactor = (n) => {\n    let result = n;\n    let i = 2;\n    while (i * i <= result) {\n        if (result % i) {\n            i += 1;\n        } else {\n            result = Math.floor(result / i);\n        }\n    }\n    return result;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i] !== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst largestPalindromeProduct = (n) => {\n    let result = 0;\n    for (let i = 100; i < 1000; i++) {\n        for (let j = i; j < 1000; j++) {\n            let prod = i * j;\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "const smallestMultiple = (n) => {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        if (result % i !== 0) {\n            for (let j = 1; j <= n; j++) {\n                if ((result * j) % i === 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const sumSquareDifference = (n) => {\n    let sqrSum = 0;\n    let numSum = 0;\n    for (let i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "const nthPrime = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (primes.length < n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.length - 1];\n}",
                "const largestProductInASeries = (s, k) => {\n    let result = 0;\n    for (let i = 0; i < s.length - k; i++) {\n        let product = 1;\n        for (let j = 0; j < k; j++) {\n            product *= parseInt(s[i + j]);\n        }\n        result = Math.max(result, product);\n    }\n    return result;\n}",
                "const specialPythagoreanTriplet = (n) => {\n    for (let a = 1; a < n; a++) {\n        for (let b = a; b < n; b++) {\n            let c = n - a - b;\n            if (a * a + b * b === c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "const summationOfPrimes = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (i <= n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let result = 0;\n    for (let prime of primes) {\n        result += prime;\n    }\n    return result;\n}",
                "const largestProductInAGrid = (grid) => {\n    let result = 0;\n    for (let i = 0; i < grid.length - 3; i++) {\n        for (let j = 0; j < grid[i].length - 3; j++) {\n            let p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (let k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (let k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = Math.max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "const highlyDivisibleTriangularNumber = (n) => {\n    for (let i = 1; i < 100000000; i++) {\n        let result = i * (i + 1) / 2;\n        let count = 0;\n        for (let j = 1; j <= Math.sqrt(result) + 1; j++) {\n            if (result % j === 0) {\n                count += 2;\n            }\n            if (j * j === result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "const largeSum = (numbers) => {\n    let digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
                "const longestCollatzSequence = (n) => {\n    let longest = 0;\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let chain = 1;\n        let num = i;\n        while (num !== 1) {\n            if (num % 2 === 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const latticePaths = (m, n) => {\n    let grid = [];\n    for (let i = 0; i <= m; i++) {\n        grid[i] = [];\n        for (let j = 0; j <= n; j++) {\n            grid[i][j] = 0;\n        }\n    }\n    for (let i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (let j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "const powerDigitSum = (n) => {\n    let digits = [2];\n    for (let _ = 1; _ < n; _++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp // 10;\n        }\n        if (carry) {\n            digits.push(carry);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const numberToWords = (n) => {\n    let ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n // 100] + \" hundred\";\n        } else {\n            return ones[n // 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        let suf = \"\";\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n // 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "const maximumPathSumI = (triangle) => {\n    let curr = triangle[triangle.length - 1].slice();\n    for (let i = triangle.length - 2; i >= 0; i--) {\n        let next = triangle[i].slice();\n        for (let j = 0; j < next.length; j++) {\n            next[j] += Math.max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "const countingSundays = (y1, y2) => {\n    let day = 0;\n    let count = 0;\n    for (let year = 1900; year <= y2; year++) {\n        for (let month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 === 6) {\n                count += 1;\n            }\n            if (month === 4 || month === 6 || month === 9 || month === 11) {\n                day += 30;\n            } else if (month === 2) {\n                if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "const factorialDigitSum = (n) => {\n    let digits = [1];\n    for (let i = 1; i <= n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] // 10;\n            digits[j] %= 10;\n        }\n        while (carry) {\n            digits.push(carry % 10);\n            carry //= 10;\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const d = (n) => {\n    let result = 1;\n    for (let i = 2; i <= Math.sqrt(n) + 1; i++) {\n        if (n % i === 0) {\n            result += i;\n            if (i !== n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nconst amicableNumbers = (n) => {\n    let result = 0;\n    for (let a = 2; a < n; a++) {\n        let b = d(a);\n        if (a !== b && a === d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "const namesScores = (names, queries) => {\n    let s_names = names.slice().sort();\n    let result = 0;\n    for (let i = 0; i < s_names.length; i++) {\n        let x = 0;\n        for (let c of s_names[i]) {\n            x += c.charCodeAt(0) - 64;\n        }\n        if (queries.includes(s_names[i])) {\n            result += x * (i + 1);\n        }\n    }\n    return result;\n}",
                "const isAbundant = (n) => {\n    if (n < 12) {\n        return false;\n    }\n    let sumDivisors = 1;\n    for (let i = 2; i <= Math.sqrt(n) + 1; i++) {\n        if (n % i === 0) {\n            sumDivisors += i;\n            if (i !== n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nconst nonAbundantSums = (n) => {\n    let abundants = [];\n    for (let i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push(i);\n        }\n    }\n    let abundantSums = new Set();\n    for (let i of abundants) {\n        for (let j of abundants) {\n            abundantSums.add(i + j);\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!abundantSums.has(i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const lexicographicPermutations = (n) => {\n    let result = '';\n    let digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let x = n - 1;\n    for (let i = 10; i > 0; i--) {\n        let fact = 1;\n        for (let j = 1; j < i; j++) {\n            fact *= j;\n        }\n        let idx = Math.floor(x / fact);\n        result += String(digits[idx]);\n        digits.splice(idx, 1);\n        x -= idx * fact;\n    }\n    return result;\n}",
                "const nDigitFibonacciNumber = (n) => {\n    let a = [1];\n    let b = [1];\n    let i = 2;\n    while (b.length < n) {\n        let carry = 0;\n        let c = b.slice();\n        for (let j = 0; j < b.length; j++) {\n            if (j < a.length) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] // 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry) {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
                "const reciprocalCycles = (n) => {\n    let result = 0;\n    let maxLength = 0;\n    for (let i = 1; i < n; i++) {\n        let remainders = [];\n        let remainder = 1;\n        while (remainder !== 0 && remainders.indexOf(remainder) === -1) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = 0;\n        if (remainder !== 0) {\n            length = remainders.length - remainders.indexOf(remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst quadraticPrimes = (n) => {\n    let maxPrimes = 0;\n    let result = 0;\n    for (let a = -n + 1; a < n; a += 2) {\n        for (let b = -n + 1; b < n; b += 2) {\n            let x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x += 1;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "const numberSpiralDiagonals = (n) => {\n    let result = 1;\n    for (let i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "const distinctPowers = (n) => {\n    let result = 0;\n    let xs = new Set();\n    for (let i = 2; i <= n; i++) {\n        let primes = [2, 3, 5, 7];\n        let powers = [0, 0, 0, 0];\n        let num = i;\n        for (let j = 0; j < primes.length; j++) {\n            while (num % primes[j] === 0) {\n                num = Math.floor(num / primes[j]);\n                powers[j] += 1;\n            }\n        }\n        if (num !== 1) {\n            result += n - 1;\n            continue;\n        }\n        for (let j = 2; j <= n; j++) {\n            let pstr = `${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}`;\n            xs.add(pstr);\n        }\n    }\n    result += xs.size;\n    return result;\n}",
                "const digitNthPowers = (n) => {\n    let result = 0;\n    for (let i = 2; i < 4 * 10 ** n; i++) {\n        let digitsSum = 0;\n        for (let digit of i.toString()) {\n            digitsSum += parseInt(digit) ** n;\n        }\n        if (i === digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const coinSums = (n) => {\n    let coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    let ways = [0];\n    for (let i = 0; i < n + 1; i++) {\n        ways.push(0);\n    }\n    ways[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i < n + 1; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "const pandigitalProducts = (n) => {\n    let products = new Set();\n    let s = '';\n    for (let i = 1; i <= n; i++) {\n        s += i;\n    }\n    for (let a = 1; a < 100; a++) {\n        for (let b = 1; b < 10000; b++) {\n            let c = a * b;\n            let chars = [a, b, c].map(String).sort().join('');\n            if (chars === s) {\n                products.add(c);\n            }\n        }\n    }\n    let result = 0;\n    for (let product of products) {\n        result += product;\n    }\n    return result;\n}",
                "const digitCancelingFractions = (m) => {\n    let numer = 1;\n    let denom = 1;\n    for (let d = 10; d < m; d++) {\n        for (let n = 10; n < d; n++) {\n            let n0 = n % 10;\n            let n1 = n // 10;\n            let d0 = d % 10;\n            let d1 = d // 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let a = numer;\n    let b = denom;\n    while (b) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return denom // a;\n}",
                "const digitFactorials = (n) => {\n    let result = 0;\n    for (let i = 3; i < n; i++) {\n        let fact_sum = 0;\n        for (let digit of i.toString()) {\n            let fact = 1;\n            for (let j = 1; j <= parseInt(digit); j++) {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if (i == fact_sum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst circularPrimes = (n) => {\n    let count = 0;\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            let rotations = new Set();\n            for (let j = 0; j < String(i).length; j++) {\n                rotations.add(parseInt(String(i).substring(j) + String(i).substring(0, j)));\n            }\n            let flag = true;\n            for (let x of rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i] !== s[s.length - (i + 1)]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst doubleBasePalindromes = (n) => {\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let str_i = i.toString();\n        let bin_i = i.toString(2);\n        if (isPalindrome(str_i) && isPalindrome(bin_i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst truncatablePrimes = (n) => {\n    let result = 0;\n    for (let i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            let si = i.toString();\n            let flag = true;\n            for (let j = 1; j < si.length; j++) {\n                let p1 = parseInt(si.substring(j));\n                let p2 = parseInt(si.substring(0, si.length - j));\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "const pandigitalMultiples = (n) => {\n    let result = -1;\n    for (let i = 2; i <= n; i++) {\n        let cprod = '';\n        for (let j = 1; j <= 9; j++) {\n            cprod += i * j;\n            if (cprod.length === 9) {\n                if (cprod.split('').sort().join('') === '123456789') {\n                    result = Math.max(result, parseInt(cprod));\n                    break;\n                }\n            } else if (cprod.length > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "const integerRightTriangles = (n) => {\n    let maxSol = 0;\n    let result = 0;\n    for (let p = 3; p <= n; p++) {\n        let sol = 0;\n        for (let a = 1; a <= p / 2; a++) {\n            for (let b = a; b <= p / 2; b++) {\n                let c = p - a - b;\n                if (a * a + b * b === c * c) {\n                    sol += 1;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "const champernowneConstant = (b) => {\n    let s = '';\n    for (let i = 1; i < Math.pow(b, 6); i++) {\n        s += i.toString();\n    }\n    let result = 1;\n    for (let i = 0; i < 7; i++) {\n        result *= parseInt(s[Math.pow(b, i) - 1]);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst pandigitalPrime = (n) => {\n    for (let i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            const si = i.toString();\n            const length = si.length;\n            let flag = true;\n            for (let j = 1; j <= length; j++) {\n                if (si.indexOf(j.toString()) === -1) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "const codedTriangleNumbers = (words) => {\n    let result = 0;\n    for (let word of words) {\n        let value = 0;\n        for (let c of word) {\n            value += c.charCodeAt(0) - 64;\n        }\n        let n = Math.floor(Math.sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result += 1;\n        }\n    }\n    return result;\n}",
                "const genPermutations = (s) => {\n    if (s.length <= 1) {\n        return s;\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst subStringDivisibility = (n) => {\n    let result = 0;\n    let primes = [2, 3, 5, 7, 11, 13, 17];\n    let s = '';\n    for (let i = 0; i <= n; i++) {\n        s += i;\n    }\n    for (let i of genPermutations(s)) {\n        let flag = true;\n        for (let j = 1; j < n - 1; j++) {\n            if (parseInt(i.substring(j, j + 3)) % primes[j - 1] !== 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += parseInt(i);\n        }\n    }\n    return result;\n}",
                "const pentagonNumbers = (n) => {\n    let pentagon = new Set();\n    for (let i = 1; i < n; i++) {\n        pentagon.add(Math.floor((i * (3 * i - 1)) / 2));\n    }\n    let result = -1;\n    for (let j of pentagon) {\n        for (let k of pentagon) {\n            if (pentagon.has(j + k) && pentagon.has(k - j)) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const triangularPentagonalAndHexagonal = (n) => {\n    let ps = new Set();\n    let i = 1;\n    let c = 0.5 * i * (3 * i - 1);\n    while (c < n) {\n        i += 1;\n        ps.add(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let result = -1;\n    while (c < n) {\n        i += 1;\n        if (ps.has(c)) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst goldbachsOtherConjecture = (n) => {\n    let result = -1;\n    for (let i = 9999; i >= n; i -= 2) {\n        const upper = Math.sqrt(i / 2);\n        let flag = false;\n        for (let j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "const primeFactors = (n) => {\n    let num = n;\n    let factors = [];\n    let i = 2;\n    while (i * i <= num) {\n        if (num % i) {\n            i += 1;\n        } else {\n            num = Math.floor(num / i);\n            factors.push(i);\n        }\n    }\n    if (num > 1) {\n        factors.push(num);\n    }\n    return factors.length;\n}\n\nconst distinctPrimesFactors = (n) => {\n    for (let i = n; i < 1000000; i++) {\n        if (primeFactors(i) === 4 && primeFactors(i + 1) === 4 && primeFactors(i + 2) === 4 && primeFactors(i + 3) === 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "const selfPowers = (n) => {\n    let digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let i = 1; i <= n; i++) {\n        let tempDigits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        tempDigits[0] = 1;\n        for (let j = 0; j < i; j++) {\n            let carry = 0;\n            for (let k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = tempDigits[k] / 10;\n                tempDigits[k] %= 10;\n            }\n        }\n        for (let j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let result = \"\";\n    for (let i = 9; i >= 0; i--) {\n        result += digits[i];\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n) + 1; i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst genPermutations = (s) => {\n    if (s.length <= 1) {\n        return s;\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst primePermutations = (n) => {\n    for (let i = n; i >= 999; i--) {\n        if (isPrime(i)) {\n            let permutations = genPermutations(i.toString());\n            let candidates = new Set();\n            for (let j of permutations) {\n                let candidate = parseInt(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.add(candidate);\n                }\n            }\n            for (let m of candidates) {\n                if (m + (m - i) in candidates) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString();\n                }\n            }\n        }\n    }\n    return '';\n}",
                "const consecutivePrimeSum = (limit) => {\n    let sieve = [];\n    for (let i = 0; i < limit; i++) {\n        sieve.push(true);\n    }\n    let primes = [];\n    for (let i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push(i);\n            for (let j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    let maxLength = 0;\n    let maxPrime = 0;\n    for (let i = 0; i < primes.length; i++) {\n        for (let j = i + maxLength; j < primes.length; j++) {\n            let s = primes.slice(i, j).reduce((a, b) => a + b);\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
            ],
            "kotlin": [
                "fun multiplesOf3And5(n: Int): Int {\n    var result = 0\n    for (i in 0 until n) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun evenFibonacciNumbers(n: Int): Int {\n    var result = 0\n    var a = 1\n    var b = 2\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a\n        }\n        val tmp = a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
                "fun largestPrimeFactor(n: Int): Int {\n    var result = n\n    var i = 2\n    while (i * i <= result) {\n        if (result % i != 0) {\n            i += 1\n        } else {\n            result /= i\n        }\n    }\n    return result\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i] != s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun largestPalindromeProduct(n: Int): Int {\n    var result = 0\n    for (i in 100 until 1000) {\n        for (j in i until 1000) {\n            val prod = i * j\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
                "fun smallestMultiple(n: Int): Int {\n    var result = 1\n    for (i in 1..n) {\n        if result % i != 0 {\n            for (j in 1..n) {\n                if (result * j) % i == 0 {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun sumSquareDifference(n: Int): Int {\n    var sqrSum = 0\n    var numSum = 0\n    for (i in 1..n) {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
                "fun nthPrime(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (primes.size < n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes.last()\n}",
                "fun largestProductInASeries(s: String, k: Int): Int {\n    var result = 0\n    for (i in 0 until s.length - k) {\n        var product = 1\n        for (j in 0 until k) {\n            product *= s[i + j].toInt()\n        }\n        result = maxOf(result, product)\n    }\n    return result\n}",
                "fun specialPythagoreanTriplet(n: Int): Int {\n    for (a in 1 until n) {\n        for (b in a until n) {\n            val c = n - a - b\n            if (a * a + b * b == c * c) {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
                "fun summationOfPrimes(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (i <= n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    var result = 0\n    for (prime in primes) {\n        result += prime\n    }\n    return result\n}",
                "fun largestProductInAGrid(grid: List<List<Int>>): Int {\n    var result = 0\n    for (i in 0 until grid.size - 3) {\n        for (j in 0 until grid[i].size - 3) {\n            var p1 = 1\n            var p2 = 1\n            var p3 = 1\n            var p4 = 1\n            for (k in 0 until 4) {\n                p1 *= grid[i + k][j]\n            }\n            for (k in 0 until 4) {\n                p2 *= grid[i][j + k]\n            }\n            for (k in 0 until 4) {\n                p3 *= grid[i + k][j + k]\n            }\n            for (k in 0 until 4) {\n                p4 *= grid[i + k][j + 3 - k]\n            }\n            result = maxOf(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
                "fun highlyDivisibleTriangularNumber(n: Int): Int {\n    for (i in 1..100000000) {\n        val result = i * (i + 1) / 2\n        var count = 0\n        for (j in 1..Math.sqrt(result.toDouble()).toInt()) {\n            if (result % j == 0) {\n                count += 2\n            }\n            if (j * j == result) {\n                count -= 1\n            }\n        }\n        if (count > n) {\n            return result\n        }\n    }\n    return -1\n}",
                "fun largeSum(numbers: List<String>): String {\n    val digits = IntArray(60)\n    for (i in 0 until 50) {\n        var tmp = 0\n        for (num in numbers) {\n            tmp += num[49 - i].toString().toInt()\n        }\n        for (j in i until 60) {\n            digits[j] += tmp % 10\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if (tmp == 0) {\n                break\n            }\n        }\n    }\n    for (i in 59 downTo 0) {\n        if (digits[i] != 0) {\n            var result = \"\"\n            for (j in i downTo i - 10) {\n                result += digits[j].toString()\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
                "fun longestCollatzSequence(n: Int): Int {\n    var longest = 0\n    var result = 0\n    for (i in 1 until n) {\n        var chain = 1\n        var num = i\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num /= 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain += 1\n        }\n        if (chain > longest) {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
                "fun latticePaths(m: Int, n: Int): Int {\n    val grid = Array(m + 1) { IntArray(n + 1) }\n    for (i in 0..m) {\n        grid[i][0] = 1\n    }\n    for (j in 0..n) {\n        grid[0][j] = 1\n    }\n    for (i in 1..m) {\n        for (j in 1..n) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
                "fun powerDigitSum(n: Int): Int {\n    var digits = mutableListOf(2)\n    for (i in 1 until n) {\n        var carry = 0\n        for (j in 0 until digits.size) {\n            val temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if (carry != 0) {\n            digits.add(carry)\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun numberToWords(n: Int): String {\n    val ones = listOf(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val teens = listOf(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n    val tens = listOf(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n    return when {\n        n == 1000 -> \"one thousand\"\n        n >= 100 -> {\n            if (n % 100 == 0) {\n                \"${ones[n / 100]} hundred\"\n            } else {\n                \"${ones[n / 100]} hundred and ${numberToWords(n % 100)}\"\n            }\n        }\n        n >= 20 -> {\n            val suf = if (n % 10 != 0) \" ${ones[n % 10]}\" else \"\"\n            \"${tens[n / 10]}$suf\"\n        }\n        n >= 10 -> teens[n - 10]\n        else -> ones[n]\n    }\n}",
                "fun maximumPathSumI(triangle: List<List<Int>>): Int {\n    var curr = triangle.last().toMutableList()\n    for (i in triangle.size - 2 downTo 0) {\n        val next = triangle[i].toMutableList()\n        for (j in next.indices) {\n            next[j] += max(curr[j], curr[j + 1])\n        }\n        curr = next\n    }\n    return curr[0]\n}",
                "fun countingSundays(y1: Int, y2: Int): Int {\n    var day = 0\n    var count = 0\n    for (year in 1900 until y2 + 1) {\n        for (month in 1 until 13) {\n            if (year >= y1 && day % 7 == 6) {\n                count += 1\n            }\n            if (month in listOf(4, 6, 9, 11)) {\n                day += 30\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
                "fun factorialDigitSum(n: Int): Int {\n    var digits = mutableListOf(1)\n    for (i in 1..n) {\n        var carry = 0\n        for (j in 0 until digits.size) {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        while (carry != 0) {\n            digits.add(carry % 10)\n            carry /= 10\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun d(n: Int): Int {\n    var result = 1\n    for (i in 2..(Math.sqrt(n.toDouble()) + 1).toInt()) {\n        if (n % i == 0) {\n            result += i\n            if (i != n / i) {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfun amicableNumbers(n: Int): Int {\n    var result = 0\n    for (a in 2 until n) {\n        val b = d(a)\n        if (a != b && a == d(b)) {\n            result += a\n        }\n    }\n    return result\n}",
                "fun namesScores(names: List<String>, queries: List<String>): Int {\n    val sNames = names.sorted()\n    var result = 0\n    for ((i, name) in sNames.withIndex()) {\n        var x = 0\n        for (c in name) {\n            x += c.toInt() - 64\n        }\n        if (name in queries) {\n            result += x * (i + 1)\n        }\n    }\n    return result\n}",
                "fun isAbundant(n: Int): Boolean {\n    if (n < 12) {\n        return false\n    }\n    var sumDivisors = 1\n    for (i in 2..(n / i).toInt()) {\n        if (n % i == 0) {\n            sumDivisors += i\n            if (i != n / i) {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfun nonAbundantSums(n: Int): Int {\n    val abundants = mutableListOf<Int>()\n    for (i in 12 until n) {\n        if (isAbundant(i)) {\n            abundants.add(i)\n        }\n    }\n    val abundantSums = mutableSetOf<Int>()\n    for (i in abundants) {\n        for (j in abundants) {\n            abundantSums.add(i + j)\n        }\n    }\n    var result = 0\n    for (i in 0 until n) {\n        if (i !in abundantSums) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun lexicographicPermutations(n: Int): String {\n    val result = StringBuilder()\n    val digits = mutableListOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n    var x = n - 1\n    for (i in 10 downTo 1) {\n        var fact = 1\n        for (j in 1 until i) {\n            fact *= j\n        }\n        val idx = x / fact\n        result.append(digits[idx].toString())\n        digits.removeAt(idx)\n        x -= idx * fact\n    }\n    return result.toString()\n}",
                "fun nDigitFibonacciNumber(n: Int): Int {\n    var a = listOf(1)\n    var b = listOf(1)\n    var i = 2\n    while (b.size < n) {\n        var carry = 0\n        val c = b.toMutableList()\n        for (j in b.indices) {\n            if (j < a.size) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if (carry != 0) {\n            b.add(carry)\n        }\n        a = c\n        i = i + 1\n    }\n    return i\n}",
                "fun reciprocalCycles(n: Int): Int {\n    var result = 0\n    var maxLength = 0\n    for (i in 1 until n) {\n        val remainders = mutableListOf<Int>()\n        var remainder = 1\n        while (remainder != 0 && !remainders.contains(remainder)) {\n            remainders.add(remainder)\n            remainder = (remainder * 10) % i\n        }\n        var length = 0\n        if (remainder != 0) {\n            length = remainders.size - remainders.indexOf(remainder)\n        }\n        if (length > maxLength) {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun quadraticPrimes(n: Int): Int {\n    var maxPrimes = 0\n    var result = 0\n    for (a in -n + 1..n step 2) {\n        for (b in -n + 1..n step 2) {\n            var x = 0\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break\n                }\n                x += 1\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
                "fun numberSpiralDiagonals(n: Int): Int {\n    var result = 1\n    for (i in 3 until n + 1 step 2) {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
                "fun distinctPowers(n: Int): Int {\n    var result = 0\n    val xs = mutableSetOf<String>()\n    for (i in 2..n) {\n        val primes = listOf(2, 3, 5, 7)\n        val powers = listOf(0, 0, 0, 0)\n        var num = i\n        for (j in primes.indices) {\n            while (num % primes[j] == 0) {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if (num != 1) {\n            result += n - 1\n            continue\n        }\n        for (j in 2..n) {\n            val pstr = \"${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}\"\n            xs.add(pstr)\n        }\n    }\n    result += xs.size\n    return result\n}",
                "fun digitNthPowers(n: Int): Int {\n    var result = 0\n    for (i in 2 until 40 * 10.0.pow(n).toInt()) {\n        var digitsSum = 0\n        for (digit in i.toString()) {\n            digitsSum += digit.toInt().pow(n)\n        }\n        if (i == digitsSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun coinSums(n: Int): Int {\n    val coins = listOf(1, 2, 5, 10, 20, 50, 100, 200)\n    val ways = IntArray(n + 1) { 0 }\n    ways[0] = 1\n    for (coin in coins) {\n        for (i in coin..n) {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
                "fun pandigitalProducts(n: Int): Int {\n    val products = mutableSetOf<Int>()\n    val s = (1..n).joinToString(\"\") { it.toString() }\n    for (a in 1 until 100) {\n        for (b in 1 until 10000) {\n            val c = a * b\n            val chars = listOf(a.toString(), b.toString(), c.toString()).sorted()\n            if (chars.joinToString(\"\") == s) {\n                products.add(c)\n            }\n        }\n    }\n    var result = 0\n    for (product in products) {\n        result += product\n    }\n    return result\n}",
                "fun digitCancelingFractions(m: Int): Int {\n    var numer = 1\n    var denom = 1\n    for (d in 10 until m) {\n        for (n in 10 until d) {\n            val n0 = n % 10\n            val n1 = n / 10\n            val d0 = d % 10\n            val d1 = d / 10\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    var a = numer\n    var b = denom\n    while (b != 0) {\n        val t = b\n        b = a % b\n        a = t\n    }\n    return denom / a\n}",
                "fun digitFactorials(n: Int): Int {\n    var result = 0\n    for (i in 3 until n) {\n        var factSum = 0\n        for (digit in i.toString()) {\n            var fact = 1\n            for (j in 1 until digit.toInt() + 1) {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if (i == factSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun circularPrimes(n: Int): Int {\n    var count = 0\n    for (i in 2 until n) {\n        if (isPrime(i)) {\n            val rotations = mutableSetOf<Int>()\n            for (j in 0 until i.toString().length) {\n                rotations.add(i.toString().substring(j).toInt() + i.toString().substring(0, j).toInt())\n            }\n            var flag = true\n            for (x in rotations) {\n                if (!isPrime(x)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                count += 1\n            }\n        }\n    }\n    return count\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i] != s[s.length - 1 - i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun doubleBasePalindromes(n: Int): Int {\n    var result = 0\n    for (i in 1 until n) {\n        val strI = i.toString()\n        val binI = i.toString(2)\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun truncatablePrimes(n: Int): Int {\n    var result = 0\n    for (i in 10 until n) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            var flag = true\n            for (j in 1 until si.length) {\n                val p1 = si.substring(j).toInt()\n                val p2 = si.substring(0, si.length - j).toInt()\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                result += i\n            }\n        }\n    }\n    return result\n}",
                "fun pandigitalMultiples(n: Int): Int {\n    var result = -1\n    for (i in 2..n) {\n        var cprod = \"\"\n        for (j in 1..9) {\n            cprod += i * j\n            if (cprod.length == 9) {\n                if (cprod.toCharArray().sortedArray().joinToString(\"\") == \"123456789\") {\n                    result = maxOf(result, cprod.toInt())\n                    break\n                }\n            } else if (cprod.length > 9) {\n                break\n            }\n        }\n    }\n    return result\n}",
                "fun integerRightTriangles(n: Int): Int {\n    var maxSol = 0\n    var result = 0\n    for (p in 3..n) {\n        var sol = 0\n        for (a in 1 until p / 2) {\n            for (b in a until p / 2) {\n                val c = p - a - b\n                if (a * a + b * b == c * c) {\n                    sol += 1\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
                "fun champernowneConstant(b: Int): Int {\n    var s = \"\"\n    for (i in 1 until b.toDouble().pow(6).toInt()) {\n        s += i.toString()\n    }\n    var result = 1\n    for (i in 0 until 7) {\n        result *= s[b.toDouble().pow(i).toInt() - 1].toString().toInt()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun pandigitalPrime(n: Int): Int {\n    for (i in n - 1 downTo 1) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            val length = si.length\n            var flag = true\n            for (j in 1..length) {\n                if (!si.contains(j.toString())) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                return i\n            }\n        }\n    }\n    return -1\n}",
                "fun codedTriangleNumbers(words: List<String>): Int {\n    var result = 0\n    for (word in words) {\n        var value = 0\n        for (c in word) {\n            value += c.toInt() - 64\n        }\n        val n = (Math.sqrt(value * 2.0)).toInt()\n        if (n * (n + 1) == value * 2) {\n            result += 1\n        }\n    }\n    return result\n}",
                "fun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun subStringDivisibility(n: Int): Int {\n    var result = 0\n    val primes = listOf(2, 3, 5, 7, 11, 13, 17)\n    val s = (0..n).joinToString(\"\")\n    for (i in genPermutations(s)) {\n        var flag = true\n        for (j in 1 until n - 1) {\n            if (i.substring(j, j + 3).toInt() % primes[j - 1] != 0) {\n                flag = false\n                break\n            }\n        }\n        if (flag) {\n            result += i.toInt()\n        }\n    }\n    return result\n}",
                "fun pentagonNumbers(n: Int): Int {\n    val pentagon = mutableSetOf<Int>()\n    for (i in 1 until n) {\n        pentagon.add((i * (3 * i - 1) / 2).toInt())\n    }\n    var result = -1\n    for (j in pentagon) {\n        for (k in pentagon) {\n            if (j + k in pentagon && k - j in pentagon) {\n                if (result == -1 || k - j < result) {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun triangularPentagonalAndHexagonal(n: Int): Int {\n    val ps = mutableSetOf<Int>()\n    var i = 1\n    var c = 0.5 * i * (3 * i - 1)\n    while (c < n) {\n        i += 1\n        ps.add(c)\n        c = 0.5 * i * (3 * i - 1)\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    var result = -1\n    while (c < n) {\n        i += 1\n        if (c in ps) {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..(Math.sqrt(n.toDouble()) + 1).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun goldbachsOtherConjecture(n: Int): Int {\n    var result = -1\n    for (i in 9999 downTo n step 2) {\n        val upper = Math.sqrt(i / 2.0).toInt()\n        var flag = false\n        for (j in 0..upper) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true\n                break\n            }\n        }\n        if (!flag) {\n            result = i\n        }\n    }\n    return result\n}",
                "fun primeFactors(n: Int): Int {\n    var num = n\n    val factors = mutableListOf<Int>()\n    var i = 2\n    while (i * i <= num) {\n        if (num % i != 0) {\n            i++\n        } else {\n            num /= i\n            factors.add(i)\n        }\n    }\n    if (num > 1) {\n        factors.add(num)\n    }\n    return factors.distinct().size\n}\n\nfun distinctPrimesFactors(n: Int): Int {\n    for (i in n until 1000000) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i\n        }\n    }\n    return -1\n}",
                "fun selfPowers(n: Int): String {\n    val digits = IntArray(10)\n    for (i in 1..n) {\n        val tempDigits = IntArray(10)\n        tempDigits[0] = 1\n        for (j in 0 until i) {\n            var carry = 0\n            for (k in 0 until 10) {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for (j in 0 until 10) {\n            digits[j] += tempDigits[j]\n            if (digits[j] >= 10) {\n                digits[j] -= 10\n                if (j < 9) {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    var result = \"\"\n    for (i in 9 downTo 0) {\n        result += digits[i].toString()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun primePermutations(n: Int): String {\n    for (i in n downTo 999) {\n        if (isPrime(i)) {\n            val permutations = genPermutations(i.toString())\n            val candidates = mutableSetOf<Int>()\n            for (j in permutations) {\n                val candidate = j.toInt()\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.add(candidate)\n                }\n            }\n            for (m in candidates) {\n                if (m + (m - i) in candidates) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString()\n                }\n            }\n        }\n    }\n    return \"\"\n}",
                "fun consecutivePrimeSum(limit: Int): Int {\n    val sieve = BooleanArray(limit) { true }\n    val primes = mutableListOf<Int>()\n    for (i in 2 until limit) {\n        if (sieve[i]) {\n            primes.add(i)\n            for (j in i * 2 until limit step i) {\n                sieve[j] = false\n            }\n        }\n    }\n    var maxLength = 0\n    var maxPrime = 0\n    for (i in primes.indices) {\n        for (j in i + maxLength until primes.size) {\n            val s = primes.subList(i, j).sum()\n            if (s >= limit) {\n                break\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
            ],
            "php": [
                "function multiplesOf3And5($n) {\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 3 === 0 || $i % 5 === 0) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function evenFibonacciNumbers($n) {\n    $result = 0;\n    $a = 1;\n    $b = 2;\n    while ($a < $n) {\n        if ($a % 2 == 0) {\n            $result += $a;\n        }\n        $tmp = $a;\n        $a = $b;\n        $b = $tmp + $b;\n    }\n    return $result;\n}",
                "function largestPrimeFactor($n) {\n    $result = $n;\n    $i = 2;\n    while ($i * $i <= $result) {\n        if ($result % $i) {\n            $i += 1;\n        } else {\n            $result /= $i;\n        }\n    }\n    return $result;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i] != $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction largestPalindromeProduct($n) {\n    $result = 0;\n    for ($i = 100; $i < 1000; $i++) {\n        for ($j = $i; $j < 1000; $j++) {\n            $prod = $i * $j;\n            if (isPalindrome(strval($prod)) && $prod > $result && $prod < $n) {\n                $result = $prod;\n            }\n        }\n    }\n    return $result;\n}",
                "function smallestMultiple($n) {\n    $result = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($result % $i != 0) {\n            for ($j = 1; $j <= $n; $j++) {\n                if (($result * $j) % $i == 0) {\n                    $result *= $j;\n                    break;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function sumSquareDifference($n) {\n    $sqr_sum = 0;\n    $num_sum = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $sqr_sum += $i * $i;\n        $num_sum += $i;\n    }\n    return $num_sum * $num_sum - $sqr_sum;\n}",
                "function nthPrime($n) {\n    $primes = [2];\n    $i = 3;\n    while (count($primes) < $n) {\n        foreach ($primes as $p) {\n            if ($i % $p == 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    return $primes[count($primes) - 1];\n}",
                "function largestProductInASeries($s, $k) {\n    $result = 0;\n    for ($i = 0; $i < strlen($s) - $k; $i++) {\n        $product = 1;\n        for ($j = 0; $j < $k; $j++) {\n            $product *= intval(substr($s, $i + $j, 1));\n        }\n        $result = max($result, $product);\n    }\n    return $result;\n}",
                "function specialPythagoreanTriplet($n) {\n    for ($a = 1; $a < $n; $a++) {\n        for ($b = $a; $b < $n; $b++) {\n            $c = $n - $a - $b;\n            if ($a * $a + $b * $b == $c * $c) {\n                return $a * $b * $c;\n            }\n        }\n    }\n    return -1;\n}",
                "function summationOfPrimes($n) {\n    $primes = [2];\n    $i = 3;\n    while ($i <= $n) {\n        foreach ($primes as $p) {\n            if ($i % $p == 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    $result = 0;\n    foreach ($primes as $prime) {\n        $result += $prime;\n    }\n    return $result;\n}",
                "function largestProductInAGrid($grid) {\n    $result = 0;\n    for ($i = 0; $i < count($grid) - 3; $i++) {\n        for ($j = 0; $j < count($grid[$i]) - 3; $j++) {\n            $p1 = 1;\n            $p2 = 1;\n            $p3 = 1;\n            $p4 = 1;\n            for ($k = 0; $k < 4; $k++) {\n                $p1 *= $grid[$i + $k][$j];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p2 *= $grid[$i][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p3 *= $grid[$i + $k][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p4 *= $grid[$i + $k][$j + 3 - $k];\n            }\n            $result = max($result, $p1, $p2, $p3, $p4);\n        }\n    }\n    return $result;\n}",
                "function highlyDivisibleTriangularNumber($n) {\n    for ($i = 1; $i < 100000000; $i++) {\n        $result = $i * ($i + 1) / 2;\n        $count = 0;\n        for ($j = 1; $j <= intval(sqrt($result)) + 1; $j++) {\n            if ($result % $j == 0) {\n                $count += 2;\n            }\n            if ($j * $j == $result) {\n                $count -= 1;\n            }\n        }\n        if ($count > $n) {\n            return $result;\n        }\n    }\n    return -1;\n}",
                "function largeSum($numbers) {\n    $digits = [0] * 60;\n    for ($i = 1; $i < 50; $i++) {\n        $tmp = 0;\n        foreach ($numbers as $num) {\n            $tmp += intval(substr($num, 49 - $i));\n        }\n        for ($j = $i; $j < 60; $j++) {\n            $digits[$j] += $tmp % 10;\n            if ($digits[$j] >= 10) {\n                $digits[$j + 1] += $digits[$j] // 10;\n                $digits[$j] %= 10;\n            }\n            $tmp //= 10;\n            if ($tmp == 0) {\n                break;\n            }\n        }\n    }\n    for ($i = 59; $i >= 0; $i--) {\n        if ($digits[$i] != 0) {\n            $result = '';\n            for ($j = $i; $j > $i - 10; $j--) {\n                $result .= strval($digits[$j]);\n            }\n            return $result;\n        }\n    }\n}",
                "function longestCollatzSequence($n) {\n    $longest = 0;\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $chain = 1;\n        $num = $i;\n        while ($num != 1) {\n            if ($num % 2 == 0) {\n                $num = $num / 2;\n            } else {\n                $num = 3 * $num + 1;\n            }\n            $chain += 1;\n        }\n        if ($chain > $longest) {\n            $longest = $chain;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function latticePaths($m, $n) {\n    $grid = array_fill(0, $m + 1, array_fill(0, $n + 1, 0));\n    for ($i = 1; $i < $m + 1; $i++) {\n        $grid[$i][0] = 1;\n    }\n    for ($j = 1; $j < $n + 1; $j++) {\n        $grid[0][$j] = 1;\n    }\n    for ($i = 1; $i < $m + 1; $i++) {\n        for ($j = 1; $j < $n + 1; $j++) {\n            $grid[$i][$j] = $grid[$i - 1][$j] + $grid[$i][$j - 1];\n        }\n    }\n    return $grid[$m][$n];\n}",
                "function powerDigitSum($n) {\n    $digits = [2];\n    for ($i = 1; $i < $n; $i++) {\n        $carry = 0;\n        for ($j = 0; $j < count($digits); $j++) {\n            $temp = $digits[$j] * 2 + $carry;\n            $digits[$j] = $temp % 10;\n            $carry = $temp // 10;\n        }\n        if ($carry) {\n            array_push($digits, $carry);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function numberToWords($n) {\n    $ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    $teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    $tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if ($n == 1000) {\n        return \"one thousand\";\n    } elseif ($n >= 100) {\n        if ($n % 100 == 0) {\n            return $ones[$n // 100] . \" hundred\";\n        } else {\n            return $ones[$n // 100] . \" hundred and \" . numberToWords($n % 100);\n        }\n    } elseif ($n >= 20) {\n        $suf = \"\";\n        if ($n % 10 != 0) {\n            $suf = \" \" . $ones[$n % 10];\n        }\n        return $tens[$n // 10] . $suf;\n    } elseif ($n >= 10) {\n        return $teens[$n - 10];\n    } else {\n        return $ones[$n];\n    }\n}",
                "function maximumPathSumI($triangle) {\n    $curr = $triangle[count($triangle) - 1];\n    for ($i = count($triangle) - 2; $i >= 0; $i--) {\n        $next = $triangle[$i];\n        for ($j = 0; $j < count($next); $j++) {\n            $next[$j] += max($curr[$j], $curr[$j + 1]);\n        }\n        $curr = $next;\n    }\n    return $curr[0];\n}",
                "function countingSundays($y1, $y2) {\n    $day = 0;\n    $count = 0;\n    for ($year = 1900; $year <= $y2; $year++) {\n        for ($month = 1; $month <= 12; $month++) {\n            if ($year >= $y1 && $day % 7 == 6) {\n                $count += 1;\n            }\n            if ($month == 4 || $month == 6 || $month == 9 || $month == 11) {\n                $day += 30;\n            } elseif ($month == 2) {\n                if ($year % 4 == 0 && ($year % 100 != 0 || $year % 400 == 0)) {\n                    $day += 29;\n                } else {\n                    $day += 28;\n                }\n            } else {\n                $day += 31;\n            }\n        }\n    }\n    return $count;\n}",
                "function factorialDigitSum($n) {\n    $digits = [1];\n    for ($i = 1; $i <= $n; $i++) {\n        $carry = 0;\n        for ($j = 0; $j < count($digits); $j++) {\n            $digits[$j] = $digits[$j] * $i + $carry;\n            $carry = $digits[$j] // 10;\n            $digits[$j] %= 10;\n        }\n        while ($carry) {\n            array_push($digits, $carry % 10);\n            $carry //= 10;\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function d($n) {\n    $result = 1;\n    for ($i = 2; $i <= intval(sqrt($n)) + 1; $i++) {\n        if ($n % $i == 0) {\n            $result += $i;\n            if ($i != $n / $i) {\n                $result += $n / $i;\n            }\n        }\n    }\n    return $result;\n}\n\nfunction amicableNumbers($n) {\n    $result = 0;\n    for ($a = 2; $a < $n; $a++) {\n        $b = d($a);\n        if ($a != $b && $a == d($b)) {\n            $result += $a;\n        }\n    }\n    return $result;\n}",
                "function namesScores($names, $queries) {\n    $s_names = sort($names);\n    $result = 0;\n    for ($i = 0; $i < count($s_names); $i++) {\n        $name = $s_names[$i];\n        $x = 0;\n        for ($j = 0; $j < strlen($name); $j++) {\n            $x += ord($name[$j]) - 64;\n        }\n        if (in_array($name, $queries)) {\n            $result += $x * ($i + 1);\n        }\n    }\n    return $result;\n}",
                "function isAbundant($n) {\n    if ($n < 12) {\n        return false;\n    }\n    $sum_divisors = 1;\n    for ($i = 2; $i <= intval(sqrt($n)) + 1; $i++) {\n        if ($n % $i == 0) {\n            $sum_divisors += $i;\n            if ($i != $n / $i) {\n                $sum_divisors += $n / $i;\n            }\n        }\n    }\n    return $sum_divisors > $n;\n}\n\nfunction nonAbundantSums($n) {\n    $abundants = [];\n    for ($i = 12; $i < $n; $i++) {\n        if (isAbundant($i)) {\n            array_push($abundants, $i);\n        }\n    }\n    $abundant_sums = [];\n    foreach ($abundants as $i) {\n        foreach ($abundants as $j) {\n            array_push($abundant_sums, $i + $j);\n        }\n    }\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!in_array($i, $abundant_sums)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function lexicographicPermutations($n) {\n    $result = '';\n    $digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    $x = $n - 1;\n    for ($i = 10; $i > 0; $i--) {\n        $fact = 1;\n        for ($j = 1; $j < $i; $j++) {\n            $fact *= $j;\n        }\n        $idx = $x / $fact;\n        $result .= strval($digits[$idx]);\n        array_splice($digits, $idx, 1);\n        $x -= $idx * $fact;\n    }\n    return $result;\n}",
                "function nDigitFibonacciNumber($n) {\n    $a = [1];\n    $b = [1];\n    $i = 2;\n    while (count($b) < $n) {\n        $carry = 0;\n        $c = $b;\n        for ($j = 0; $j < count($b); $j++) {\n            if ($j < count($a)) {\n                $b[$j] = $a[$j] + $b[$j] + $carry;\n            } else {\n                $b[$j] = $b[$j] + $carry;\n            }\n            $carry = $b[$j] // 10;\n            $b[$j] = $b[$j] % 10;\n        }\n        if ($carry) {\n            array_push($b, $carry);\n        }\n        $a = $c;\n        $i = $i + 1;\n    }\n    return $i;\n}",
                "function reciprocalCycles($n) {\n    $result = 0;\n    $maxLength = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $remainders = [];\n        $remainder = 1;\n        while ($remainder != 0 && !in_array($remainder, $remainders)) {\n            array_push($remainders, $remainder);\n            $remainder = ($remainder * 10) % $i;\n        }\n        $length = 0;\n        if ($remainder != 0) {\n            $length = count($remainders) - array_search($remainder, $remainders);\n        }\n        if ($length > $maxLength) {\n            $maxLength = $length;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n) + 1; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction quadraticPrimes($n) {\n    $maxPrimes = 0;\n    $result = 0;\n    for ($a = -$n + 1; $a < $n; $a += 2) {\n        for ($b = -$n + 1; $b < $n; $b += 2) {\n            $x = 0;\n            while (true) {\n                if ($x * $x + $a * $x + $b < 2) {\n                    break;\n                }\n                if (!isPrime($x * $x + $a * $x + $b)) {\n                    break;\n                }\n                $x += 1;\n            }\n            if ($x > $maxPrimes) {\n                $maxPrimes = $x;\n                $result = $a * $b;\n            }\n        }\n    }\n    return $result;\n}",
                "function numberSpiralDiagonals($n) {\n    $result = 1;\n    for ($i = 3; $i <= $n; $i += 2) {\n        $result += 4 * $i * $i - 6 * $i + 6;\n    }\n    return $result;\n}",
                "function distinctPowers($n) {\n    $result = 0;\n    $xs = [];\n    for ($i = 2; $i <= $n; $i++) {\n        $primes = [2, 3, 5, 7];\n        $powers = [0, 0, 0, 0];\n        $num = $i;\n        for ($j = 0; $j < count($primes); $j++) {\n            while ($num % $primes[$j] == 0) {\n                $num /= $primes[$j];\n                $powers[$j] += 1;\n            }\n        }\n        if ($num != 1) {\n            $result += $n - 1;\n            continue;\n        }\n        for ($j = 2; $j <= $n; $j++) {\n            $pstr = $powers[0] * $j . \"-\" . $powers[1] * $j . \"-\" . $powers[2] * $j . \"-\" . $powers[3] * $j;\n            array_push($xs, $pstr);\n        }\n    }\n    $result += count(array_unique($xs));\n    return $result;\n}",
                "function digitNthPowers($n) {\n    $result = 0;\n    for ($i = 2; $i < 4 * pow(10, $n); $i++) {\n        $digits_sum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $digits_sum += pow(intval($digit), $n);\n        }\n        if ($i == $digits_sum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function coinSums($n) {\n    $coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    $ways = array_fill(0, $n + 1, 0);\n    $ways[0] = 1;\n    foreach ($coins as $coin) {\n        for ($i = $coin; $i <= $n; $i++) {\n            $ways[$i] += $ways[$i - $coin];\n        }\n    }\n    return $ways[$n];\n}",
                "function pandigitalProducts($n) {\n    $products = [];\n    $s = implode('', array_map(function($i) { return strval($i); }, range(1, $n+1)));\n    for ($a = 1; $a < 100; $a++) {\n        for ($b = 1; $b < 10000; $b++) {\n            $c = $a * $b;\n            $chars = str_split(strval($a) . strval($b) . strval($c));\n            sort($chars);\n            if (implode('', $chars) == $s) {\n                array_push($products, $c);\n            }\n        }\n    }\n    $result = 0;\n    foreach ($products as $product) {\n        $result += $product;\n    }\n    return $result;\n}",
                "function digitCancelingFractions($m) {\n    $numer = 1;\n    $denom = 1;\n    for ($d = 10; $d < $m; $d++) {\n        for ($n = 10; $n < $d; $n++) {\n            $n0 = $n % 10;\n            $n1 = $n // 10;\n            $d0 = $d % 10;\n            $d1 = $d // 10;\n            if (($n1 == $d0 && $n0 * $d == $n * $d1) || ($n0 == $d1 && $n1 * $d == $n * $d0)) {\n                $numer *= $n;\n                $denom *= $d;\n            }\n        }\n    }\n    $a = $numer;\n    $b = $denom;\n    while ($b) {\n        $a = $b;\n        $b = $a % $b;\n    }\n    return $denom // $a;\n}",
                "function digitFactorials($n) {\n    $result = 0;\n    for ($i = 3; $i < $n; $i++) {\n        $fact_sum = 0;\n        for ($digit = 0; $digit < strlen(strval($i)); $digit++) {\n            $fact = 1;\n            for ($j = 1; $j <= intval(substr(strval($i), $digit, 1)) + 1; $j++) {\n                $fact *= $j;\n            }\n            $fact_sum += $fact;\n        }\n        if ($i == $fact_sum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n) + 1; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction circularPrimes($n) {\n    $count = 0;\n    for ($i = 2; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $rotations = [];\n            for ($j = 0; $j < strlen(strval($i)); $j++) {\n                array_push($rotations, intval(substr(strval($i), $j) . substr(strval($i), 0, $j)));\n            }\n            $flag = true;\n            foreach ($rotations as $x) {\n                if (!isPrime($x)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $count += 1;\n            }\n        }\n    }\n    return $count;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i] != $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction doubleBasePalindromes($n) {\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $str_i = strval($i);\n        $bin_i = strval(decbin($i));\n        if (isPalindrome($str_i) && isPalindrome($bin_i)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n) + 1; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction truncatablePrimes($n) {\n    $result = 0;\n    for ($i = 10; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $flag = true;\n            for ($j = 1; $j < strlen($si); $j++) {\n                $p1 = intval(substr($si, $j));\n                $p2 = intval(substr($si, 0, -$j));\n                if (!isPrime($p1) || !isPrime($p2)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $result += $i;\n            }\n        }\n    }\n    return $result;\n}",
                "function pandigitalMultiples($n) {\n    $result = -1;\n    for ($i = 2; $i <= $n; $i++) {\n        $cprod = '';\n        for ($j = 1; $j <= 9; $j++) {\n            $cprod .= strval($i * $j);\n            if (strlen($cprod) == 9) {\n                if (join('', sort(str_split($cprod))) == '123456789') {\n                    $result = max($result, intval($cprod));\n                    break;\n                }\n            } elseif (strlen($cprod) > 9) {\n                break;\n            }\n        }\n    }\n    return $result;\n}",
                "function integerRightTriangles($n) {\n    $max_sol = 0;\n    $result = 0;\n    for ($p = 3; $p <= $n; $p++) {\n        $sol = 0;\n        for ($a = 1; $a <= $p // 2; $a++) {\n            for ($b = $a; $b <= $p // 2; $b++) {\n                $c = $p - $a - $b;\n                if ($a * $a + $b * $b == $c * $c) {\n                    $sol += 1;\n                }\n            }\n        }\n        if ($sol > $max_sol) {\n            $max_sol = $sol;\n            $result = $p;\n        }\n    }\n    return $result;\n}",
                "function champernowneConstant($b) {\n    $s = '';\n    for ($i = 1; $i < pow($b, 6); $i++) {\n        $s .= strval($i);\n    }\n    $result = 1;\n    for ($i = 7; $i < strlen($s); $i++) {\n        $result *= intval(substr($s, $i, 1));\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n) + 1; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction pandigitalPrime($n) {\n    for ($i = $n - 1; $i > 0; $i--) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $length = strlen($si);\n            $flag = true;\n            for ($j = 1; $j <= $length; $j++) {\n                if (strpos($si, strval($j)) === false) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                return $i;\n            }\n        }\n    }\n    return -1;\n}",
                "function codedTriangleNumbers($words) {\n    $result = 0;\n    foreach ($words as $word) {\n        $value = 0;\n        for ($i = 0; $i < strlen($word); $i++) {\n            $value += ord($word[$i]) - 64;\n        }\n        $n = intval(sqrt($value * 2));\n        if ($n * ($n + 1) == $value * 2) {\n            $result += 1;\n        }\n    }\n    return $result;\n}",
                "function genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return $s;\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, substr($perm, 0, $i) . substr($s, 0, 1) . substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction subStringDivisibility($n) {\n    $result = 0;\n    $primes = [2, 3, 5, 7, 11, 13, 17];\n    $s = implode('', array_map(function ($i) { return strval($i); }, range(0, $n)));\n    foreach (genPermutations($s) as $i) {\n        $flag = true;\n        for ($j = 1; $j < $n - 1; $j++) {\n            if (intval(substr($i, $j, 3)) % $primes[$j - 1] != 0) {\n                $flag = false;\n                break;\n            }\n        }\n        if ($flag) {\n            $result += intval($i);\n        }\n    }\n    return $result;\n}",
                "function pentagonNumbers($n) {\n    $pentagon = [];\n    for ($i = 1; $i < $n; $i++) {\n        array_push($pentagon, $i * (3 * $i - 1) / 2);\n    }\n    $result = -1;\n    foreach ($pentagon as $j) {\n        foreach ($pentagon as $k) {\n            if ($j + $k in $pentagon and $k - $j in $pentagon) {\n                if ($result == -1 or $k - $j < $result) {\n                    $result = $k - $j;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function triangularPentagonalAndHexagonal($n) {\n    $ps = [];\n    $i = 1;\n    $c = 0.5 * $i * (3 * $i - 1);\n    while ($c < $n) {\n        $i += 1;\n        array_push($ps, $c);\n        $c = 0.5 * $i * (3 * $i - 1);\n    }\n    $i = 1;\n    $c = $i * (2 * $i - 1);\n    $result = -1;\n    while ($c < $n) {\n        $i += 1;\n        if (in_array($c, $ps)) {\n            $result = $c;\n        }\n        $c = $i * (2 * $i - 1);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n); $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction goldbachsOtherConjecture($n) {\n    $result = -1;\n    for ($i = 9999; $i >= $n; $i -= 2) {\n        $upper = intval(sqrt($i / 2));\n        $flag = false;\n        for ($j = 0; $j <= $upper; $j++) {\n            if (isPrime($i - 2 * $j * $j)) {\n                $flag = true;\n                break;\n            }\n        }\n        if (!$flag) {\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function primeFactors($n) {\n    $num = $n;\n    $factors = [];\n    $i = 2;\n    while ($i * $i <= $num) {\n        if ($num % $i) {\n            $i += 1;\n        } else {\n            $num /= $i;\n            array_push($factors, $i);\n        }\n    }\n    if ($num > 1) {\n        array_push($factors, $num);\n    }\n    return count(array_unique($factors));\n}\n\nfunction distinctPrimesFactors($n) {\n    for ($i = $n; $i < 1000000; $i++) {\n        if (primeFactors($i) == 4 && primeFactors($i + 1) == 4 && primeFactors($i + 2) == 4 && primeFactors($i + 3) == 4) {\n            return $i;\n        }\n    }\n    return -1;\n}",
                "function selfPowers($n) {\n    $digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for ($i = 1; $i <= $n; $i++) {\n        $temp_digits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        $temp_digits[0] = 1;\n        for ($j = 0; $j < $i; $j++) {\n            $carry = 0;\n            for ($k = 0; $k < 10; $k++) {\n                $temp_digits[$k] = $temp_digits[$k] * $i + $carry;\n                $carry = $temp_digits[$k] / 10;\n                $temp_digits[$k] %= 10;\n            }\n        }\n        for ($j = 0; $j < 10; $j++) {\n            $digits[$j] += $temp_digits[$j];\n            if ($digits[$j] >= 10) {\n                $digits[$j] -= 10;\n                if ($j < 9) {\n                    $digits[$j + 1] += 1;\n                }\n            }\n        }\n    }\n    $result = \"\";\n    for ($i = 9; $i >= 0; $i--) {\n        $result .= strval($digits[$i]);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n == 2) {\n        return true;\n    }\n    if ($n % 2 == 0) {\n        return false;\n    }\n    for ($i = 3; $i <= sqrt($n) + 1; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return $s;\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, substr($perm, 0, $i) . substr($s, 0, 1) . substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction primePermutations($n) {\n    for ($i = $n; $i >= 999; $i--) {\n        if (isPrime($i)) {\n            $permutations = genPermutations(strval($i));\n            $candidates = [];\n            foreach ($permutations as $j) {\n                $candidate = intval($j);\n                if ($candidate > $i && isPrime($candidate)) {\n                    array_push($candidates, $candidate);\n                }\n            }\n            foreach ($candidates as $m) {\n                if ($m + ($m - $i) in $candidates) {\n                    return strval($i) . strval($m) . strval($m + ($m - $i));\n                }\n            }\n        }\n    }\n    return '';\n}",
                "function consecutivePrimeSum($limit) {\n    $sieve = array_fill(0, $limit, true);\n    $primes = [];\n    for ($i = 2; $i < $limit; $i++) {\n        if ($sieve[$i]) {\n            array_push($primes, $i);\n            for ($j = $i * 2; $j < $limit; $j += $i) {\n                $sieve[$j] = false;\n            }\n        }\n    }\n    $max_length = 0;\n    $max_prime = 0;\n    for ($i = 0; $i < count($primes); $i++) {\n        for ($j = $i + $max_length; $j < count($primes); $j++) {\n            $s = array_sum(array_slice($primes, $i, $j - $i));\n            if ($s >= $limit) {\n                break;\n            }\n            if ($sieve[$s] && $j - $i > $max_length) {\n                $max_length = $j - $i;\n                $max_prime = $s;\n            }\n        }\n    }\n    return $max_prime;\n}"
            ],
            "ruby": [
                "def multiples_of_3_and_5(n)\n    result = 0\n    (0...n).each do |i|\n        if i % 3 == 0 or i % 5 == 0\n            result += i\n        end\n    end\n    result\nend",
                "def even_fibonacci_numbers(n)\n    result = 0\n    a = 1\n    b = 2\n    while a < n\n        if a % 2 == 0\n            result += a\n        end\n        tmp = a\n        a = b\n        b = tmp + b\n    end\n    result\nend",
                "def largest_prime_factor(n)\n    result = n\n    i = 2\n    while i * i <= result\n        if result % i\n            i += 1\n        else\n            result //= i\n        end\n    end\n    result\nend",
                "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        return false if s[i] != s[s.length - i - 1]\n    end\n    true\nend\n\ndef largest_palindrome_product(n)\n    result = 0\n    (100..999).each do |i|\n        (i..999).each do |j|\n            prod = i * j\n            if is_palindrome(prod.to_s) && prod > result && prod < n\n                result = prod\n            end\n        end\n    end\n    result\nend",
                "def smallest_multiple(n)\n    result = 1\n    (1...n + 1).each do |i|\n        if result % i != 0\n            (1...n + 1).each do |j|\n                if (result * j) % i == 0\n                    result *= j\n                    break\n                end\n            end\n        end\n    end\n    result\nend",
                "def sum_square_difference(n)\n    sqr_sum = 0\n    num_sum = 0\n    (1...(n + 1)).each do |i|\n        sqr_sum += i * i\n        num_sum += i\n    end\n    num_sum * num_sum - sqr_sum\nend",
                "def nth_prime(n)\n    primes = [2]\n    i = 3\n    while primes.length < n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    primes[-1]\nend",
                "def largest_product_in_a_series(s, k)\n    result = 0\n    (0...(s.length - k)).each do |i|\n        product = 1\n        (0...k).each do |j|\n            product *= s[i + j].to_i\n        end\n        result = [result, product].max\n    end\n    result\nend",
                "def special_pythagorean_triplet(n)\n    (1...n).each do |a|\n        (a...n).each do |b|\n            c = n - a - b\n            return a * b * c if a * a + b * b == c * c\n        end\n    end\n    -1\nend",
                "def summation_of_primes(n)\n    primes = [2]\n    i = 3\n    while i <= n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    result = 0\n    primes.each do |prime|\n        result += prime\n    end\n    result\nend",
                "def largest_product_in_a_grid(grid)\n    result = 0\n    (0...grid.length - 3).each do |i|\n        (0...grid[i].length - 3).each do |j|\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            (0...4).each do |k|\n                p1 *= grid[i + k][j]\n            end\n            (0...4).each do |k|\n                p2 *= grid[i][j + k]\n            end\n            (0...4).each do |k|\n                p3 *= grid[i + k][j + k]\n            end\n            (0...4).each do |k|\n                p4 *= grid[i + k][j + 3 - k]\n            end\n            result = [result, p1, p2, p3, p4].max\n        end\n    end\n    result\nend",
                "def highly_divisible_triangular_number(n)\n    (1...100000000).each do |i|\n        result = i * (i + 1) // 2\n        count = 0\n        (1...(Math.sqrt(result) + 1)).each do |j|\n            if result % j == 0\n                count += 2\n            end\n            if j * j == result\n                count -= 1\n            end\n        end\n        if count > n\n            return result\n        end\n    end\n    return -1\nend",
                "def large_sum(numbers)\n    digits = [0] * 60\n    (0...50).each do |i|\n        tmp = 0\n        numbers.each do |num|\n            tmp += num[49 - i].to_i\n        end\n        (i...60).each do |j|\n            digits[j] += tmp % 10\n            if digits[j] >= 10\n                digits[j + 1] += digits[j] // 10\n                digits[j] %= 10\n            end\n            tmp //= 10\n            break if tmp == 0\n        end\n    end\n    (49...-1).each do |i|\n        if digits[i] != 0\n            result = ''\n            (i...i - 10).each do |j|\n                result += digits[j].to_s\n            end\n            return result\n        end\n    end\nend",
                "def longest_collatz_sequence(n)\n    longest = 0\n    result = 0\n    (1...n).each do |i|\n        chain = 1\n        num = i\n        while num != 1\n            if num % 2 == 0\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end\n            chain += 1\n            if chain > longest\n                longest = chain\n                result = i\n            end\n        end\n    end\n    result\nend",
                "def lattice_paths(m, n)\n    grid = Array.new(m + 1) { Array.new(n + 1, 0) }\n    (1...m + 1).each do |i|\n        grid[i][0] = 1\n    end\n    (1...n + 1).each do |j|\n        grid[0][j] = 1\n    end\n    (1...m + 1).each do |i|\n        (1...n + 1).each do |j|\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        end\n    end\n    grid[m][n]\nend",
                "def power_digit_sum(n)\n    digits = [2]\n    (1...n).each do\n        carry = 0\n        (0...digits.length).each do |j|\n            temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp // 10\n        end\n        if carry:\n            digits.push(carry)\n        end\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def number_to_words(n)\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000\n        return \"one thousand\"\n    elsif n >= 100\n        if n % 100 == 0\n            return ones[n // 100] + \" hundred\"\n        else\n            return ones[n // 100] + \" hundred and \" + number_to_words(n % 100)\n        end\n    elsif n >= 20\n        suf = \"\"\n        if n % 10 != 0\n            suf = \" \" + ones[n % 10]\n        end\n        return tens[n // 10] + suf\n    elsif n >= 10\n        return teens[n - 10]\n    else\n        return ones[n]\n    end\nend",
                "def maximum_path_sum_i(triangle)\n    curr = triangle[-1].dup\n    (triangle.length - 2).downto(0).each do |i|\n        next = triangle[i].dup\n        (0...next.length).each do |j|\n            next[j] += [curr[j], curr[j + 1]].max\n        end\n        curr = next\n    end\n    curr[0]\nend",
                "def counting_sundays(y1, y2)\n    day = 0\n    count = 0\n    (1900...(y2 + 1)).each do |year|\n        (1...13).each do |month|\n            if year >= y1 and day % 7 == 6\n                count += 1\n            end\n            if [4, 6, 9, 11].include?(month)\n                day += 30\n            elsif month == 2\n                if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n                    day += 29\n                else\n                    day += 28\n                end\n            else\n                day += 31\n            end\n        end\n    end\n    count\nend",
                "def factorial_digit_sum(n)\n    digits = [1]\n    (1...n+1).each do |i|\n        carry = 0\n        (0...digits.length).each do |j|\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] // 10\n            digits[j] %= 10\n        end\n        while carry:\n            digits.push(carry % 10)\n            carry //= 10\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def d(n)\n    result = 1\n    (2...(n ** 0.5) + 1).each do |i|\n        if n % i == 0\n            result += i\n            result += n / i unless i == n / i\n        end\n    end\n    result\nend\n\ndef amicable_numbers(n)\n    result = 0\n    (2...n).each do |a|\n        b = d(a)\n        result += a if a != b && a == d(b)\n    end\n    result\nend",
                "def names_scores(names, queries)\n    s_names = names.sort\n    result = 0\n    s_names.each_with_index do |name, i|\n        x = 0\n        name.each_char do |c|\n            x += c.ord - 64\n        end\n        if queries.include?(name)\n            result += x * (i + 1)\n        end\n    end\n    result\nend",
                "def is_abundant(n)\n    return false if n < 12\n    sum_divisors = 1\n    (2..(n ** 0.5).ceil).each do |i|\n        if n % i == 0\n            sum_divisors += i\n            sum_divisors += n / i if i != n / i\n        end\n    end\n    sum_divisors > n\nend\n\ndef non_abundant_sums(n)\n    abundants = []\n    (12..n).each do |i|\n        abundants.push(i) if is_abundant(i)\n    end\n    abundant_sums = Set.new\n    abundants.each do |i|\n        abundants.each do |j|\n            abundant_sums.add(i + j)\n        end\n    end\n    result = 0\n    (0...n).each do |i|\n        result += i unless abundant_sums.include?(i)\n    end\n    result\nend",
                "def lexicographic_permutations(n)\n    result = ''\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    (10..1).each do |i|\n        fact = 1\n        (1...i).each do |j|\n            fact *= j\n        end\n        idx = x / fact\n        result += digits[idx].to_s\n        digits.delete_at(idx)\n        x -= idx * fact\n    end\n    result\nend",
                "def n_digit_fibonacci_number(n)\n    a = [1]\n    b = [1]\n    i = 2\n    while b.length < n\n        carry = 0\n        c = b.dup\n        b.length.times do |j|\n            if j < a.length\n                b[j] = a[j] + b[j] + carry\n            else\n                b[j] = b[j] + carry\n            end\n            carry = b[j] // 10\n            b[j] = b[j] % 10\n        end\n        if carry\n            b.push(carry)\n        end\n        a = c\n        i = i + 1\n    end\n    i\nend",
                "def reciprocal_cycles(n)\n    result = 0\n    max_length = 0\n    (1...n).each do |i|\n        remainders = []\n        remainder = 1\n        while remainder != 0 and !remainders.include?(remainder)\n            remainders.push(remainder)\n            remainder = (remainder * 10) % i\n        end\n        length = 0\n        if remainder != 0\n            length = remainders.length - remainders.index(remainder)\n        end\n        if length > max_length\n            max_length = length\n            result = i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i + 1).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef quadratic_primes(n)\n    max_primes = 0\n    result = 0\n    (-n + 1..n).step(2).each do |a|\n        (-n + 1..n).step(2).each do |b|\n            x = 0\n            while true\n                break if x * x + a * x + b < 2\n                break unless is_prime(x * x + a * x + b)\n                x += 1\n            end\n            if x > max_primes\n                max_primes = x\n                result = a * b\n            end\n        end\n    end\n    result\nend",
                "def number_spiral_diagonals(n)\n    result = 1\n    (3...n + 1).step(2).each do |i|\n        result += 4 * i * i - 6 * i + 6\n    end\n    result\nend",
                "def distinct_powers(n)\n    result = 0\n    xs = Set.new\n    (2...n + 1).each do |i|\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        (0...primes.length).each do |j|\n            while num % primes[j] == 0\n                num //= primes[j]\n                powers[j] += 1\n            end\n        end\n        if num != 1\n            result += n - 1\n            next\n        end\n        (2...n + 1).each do |j|\n            pstr = \"#{powers[0] * j}-#{powers[1] * j}-#{powers[2] * j}-#{powers[3] * j}\"\n            xs.add(pstr)\n        end\n    end\n    result += xs.length\n    result\nend",
                "def digit_nth_powers(n)\n    result = 0\n    (2...(4 * 10 ** n)).each do |i|\n        digits_sum = 0\n        i.to_s.each_char do |digit|\n            digits_sum += digit.to_i ** n\n        end\n        if i == digits_sum\n            result += i\n        end\n    end\n    result\nend",
                "def coin_sums(n)\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    coins.each do |coin|\n        (coin...n + 1).each do |i|\n            ways[i] += ways[i - coin]\n        end\n    end\n    ways[n]\nend",
                "def pandigital_products(n)\n    products = Set.new\n    s = (1..n).map { |i| i.to_s }.join\n    (1..99).each do |a|\n        (1..9999).each do |b|\n            c = a * b\n            chars = [a.to_s, b.to_s, c.to_s].sort\n            if chars.join == s\n                products.add(c)\n            end\n        end\n    end\n    result = 0\n    products.each do |product|\n        result += product\n    end\n    result\nend",
                "def digit_canceling_fractions(m)\n    numer = 1\n    denom = 1\n    (10...m).each do |d|\n        (10...d).each do |n|\n            n0, n1 = n % 10, n // 10\n            d0, d1 = d % 10, d // 10\n            if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0)\n                numer *= n\n                denom *= d\n            end\n        end\n    end\n    a, b = numer, denom\n    while b:\n        a, b = b, a % b\n    end\n    denom // a\nend",
                "def digit_factorials(n)\n    result = 0\n    (3...n).each do |i|\n        fact_sum = 0\n        i.to_s.each_char do |digit|\n            fact = 1\n            (1...(digit.to_i + 1)).each do |j|\n                fact *= j\n            end\n            fact_sum += fact\n        end\n        if i == fact_sum\n            result += i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i + 1).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef circular_primes(n)\n    count = 0\n    (2...n).each do |i|\n        if is_prime(i)\n            rotations = Set.new\n            (0...i.to_s.length).each do |j|\n                rotations.add(i.to_s[j..-1] + i.to_s[0...j].to_i)\n            end\n            flag = true\n            rotations.each do |x|\n                if not is_prime(x)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                count += 1\n            end\n        end\n    end\n    count\nend",
                "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        return false if s[i] != s[-(i + 1)]\n    end\n    true\nend\n\ndef double_base_palindromes(n)\n    result = 0\n    (1...n).each do |i|\n        str_i = i.to_s\n        bin_i = i.to_s(2)\n        result += i if is_palindrome(str_i) && is_palindrome(bin_i)\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i + 1).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef truncatable_primes(n)\n    result = 0\n    (10...n).each do |i|\n        if is_prime(i)\n            si = i.to_s\n            flag = true\n            (1...si.length).each do |j|\n                p1 = si[j..-1].to_i\n                p2 = si[0...-j].to_i\n                if not is_prime(p1) or not is_prime(p2)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                result += i\n            end\n        end\n    end\n    result\nend",
                "def pandigital_multiples(n)\n    result = -1\n    (2...n + 1).each do |i|\n        cprod = ''\n        (1...10).each do |j|\n            cprod += i * j\n            if cprod.length == 9\n                if cprod.chars.sort.join == '123456789'\n                    result = [result, cprod.to_i].max\n                    break\n                end\n            elsif cprod.length > 9\n                break\n            end\n        end\n    end\n    result\nend",
                "def integer_right_triangles(n)\n    max_sol = 0\n    result = 0\n    (3...n + 1).each do |p|\n        sol = 0\n        (1...p // 2).each do |a|\n            (a...p // 2).each do |b|\n                c = p - a - b\n                if a * a + b * b == c * c\n                    sol += 1\n                end\n            end\n        end\n        if sol > max_sol\n            max_sol = sol\n            result = p\n        end\n    end\n    result\nend",
                "def champernowne_constant(b)\n    s = ''\n    (1...(b**6)).each do |i|\n        s += i.to_s\n    end\n    result = 1\n    (0...7).each do |i|\n        result *= s[b**i - 1].to_i\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i + 1).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef pandigital_prime(n)\n    (n-1).downto(1).each do |i|\n        return i if is_prime(i)\n        si = i.to_s\n        length = si.length\n        (1..length).each do |j|\n            return false if si.index(j.to_s) == nil\n        end\n    end\n    -1\nend",
                "def coded_triangle_numbers(words)\n    result = 0\n    words.each do |word|\n        value = 0\n        word.each_char do |c|\n            value += c.ord - 64\n        end\n        n = (Math.sqrt(value * 2) - 1).to_i\n        if n * (n + 1) == value * 2\n            result += 1\n        end\n    end\n    result\nend",
                "def gen_permutations(s)\n    if s.length <= 1\n        return s\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef sub_string_divisibility(n)\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = (0...n + 1).map { |i| i.to_s }.join\n    gen_permutations(s).each do |i|\n        flag = true\n        (1...n - 1).each do |j|\n            if i[j, 3].to_i % primes[j - 1] != 0\n                flag = false\n                break\n            end\n        end\n        if flag\n            result += i.to_i\n        end\n    end\n    result\nend",
                "def pentagon_numbers(n)\n    pentagon = Set.new\n    (1...n).each do |i|\n        pentagon.add(i * (3 * i - 1) / 2)\n    end\n    result = -1\n    pentagon.each do |j|\n        pentagon.each do |k|\n            if pentagon.include?(j + k) and pentagon.include?(k - j)\n                if result == -1 or k - j < result\n                    result = k - j\n            end\n        end\n    end\n    result\nend",
                "def triangular_pentagonal_and_hexagonal(n)\n    ps = Set.new\n    i = 1\n    c = 0.5 * i * (3 * i - 1)\n    while c < n\n        i += 1\n        ps.add(c)\n        c = 0.5 * i * (3 * i - 1)\n    end\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n\n        i += 1\n        if ps.include?(c)\n            result = c\n        end\n        c = i * (2 * i - 1)\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i + 1).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef goldbachs_other_conjecture(n)\n    result = -1\n    (9999...n).step(-2).each do |i|\n        upper = Math.sqrt(i / 2).to_i\n        flag = false\n        (0...upper + 1).step(2).each do |j|\n            if is_prime(i - 2 * j * j)\n                flag = true\n                break\n            end\n        end\n        if not flag\n            result = i\n        end\n    end\n    result\nend",
                "def prime_factors(n)\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num\n        if num % i\n            i += 1\n        else\n            num //= i\n            factors.push(i)\n        end\n    end\n    if num > 1\n        factors.push(num)\n    end\n    factors.length\nend\n\ndef distinct_primes_factors(n)\n    for i in n..1000000\n        if prime_factors(i) == 4 and prime_factors(i + 1) == 4 and prime_factors(i + 2) == 4 and prime_factors(i + 3) == 4\n            return i\n        end\n    end\n    -1\nend",
                "def self_powers(n)\n    digits = [0] * 10\n    (1...n + 1).each do |i|\n        temp_digits = [0] * 10\n        temp_digits[0] = 1\n        (i - 1).times do |j|\n            carry = 0\n            (0...10).each do |k|\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] // 10\n                temp_digits[k] %= 10\n            end\n        end\n        (0...10).each do |j|\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10\n                digits[j] -= 10\n                if j < 9\n                    digits[j + 1] += 1\n                end\n            end\n        end\n    end\n    result = \"\"\n    (9...-1).step(-1) do |i|\n        result += digits[i].to_s\n    end\n    result\nend",
                "def is_prime(n)\n    return false if n < 2\n    return true if n == 2\n    return false if n % 2 == 0\n    (3...Math.sqrt(n).to_i + 1).step(2).each do |i|\n        return false if n % i == 0\n    end\n    true\nend\n\ndef gen_permutations(s)\n    return s if s.length <= 1\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef prime_permutations(n)\n    (n...999).step(-1).each do |i|\n        next unless is_prime(i)\n        permutations = gen_permutations(i.to_s)\n        candidates = Set.new\n        permutations.each do |j|\n            candidate = j.to_i\n            next unless is_prime(candidate)\n            candidates.add(candidate)\n        end\n        candidates.each do |m|\n            next unless m + (m - i) in candidates\n            return i.to_s + m.to_s + (m + (m - i)).to_s\n        end\n    end\n    ''\nend",
                "def consecutive_prime_sum(limit)\n    sieve = [true] * limit\n    primes = []\n    (2...limit).each do |i|\n        if sieve[i]\n            primes.push(i)\n            (i * 2...limit).step(i) do |j|\n                sieve[j] = false\n            end\n        end\n    end\n    max_length = 0\n    max_prime = 0\n    (0...primes.length).each do |i|\n        (i + max_length...primes.length).each do |j|\n            s = primes[i..j].sum\n            if s >= limit\n                break\n            end\n            if sieve[s] && j - i > max_length\n                max_length = j - i\n                max_prime = s\n            end\n        end\n    end\n    max_prime\nend"
            ],
            "rust": [
                "fn multiples_of_3_and_5(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..n {\n        if i % 3 == 0 || i % 5 == 0 {\n            result += i;\n        }\n    }\n    result\n}",
                "fn even_fibonacci_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut a = 1;\n    let mut b = 2;\n    while a < n {\n        if a % 2 == 0 {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    result\n}",
                "fn largest_prime_factor(n: i32) -> i32 {\n    let mut result = n;\n    let mut i = 2;\n    while i * i <= result {\n        if result % i != 0 {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    result\n}",
                "fn is_palindrome(s: &String) -> bool {\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn largest_palindrome_product(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 100..1000 {\n        for j in i..1000 {\n            let prod = i * j;\n            if is_palindrome(&prod.to_string()) && prod > result && prod < n {\n                result = prod;\n            }\n        }\n    }\n    result\n}",
                "fn smallest_multiple(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 1..n + 1 {\n        if result % i != 0 {\n            for j in 1..n + 1 {\n                if (result * j) % i == 0 {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn sum_square_difference(n: i32) -> i32 {\n    let mut sqr_sum = 0;\n    let mut num_sum = 0;\n    for i in 1..n + 1 {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    num_sum * num_sum - sqr_sum\n}",
                "fn nth_prime(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while primes.len() < n as usize {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    primes[primes.len() - 1]\n}",
                "fn largest_product_in_a_series(s: &String, k: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..(s.len() - k as usize) {\n        let mut product = 1;\n        for j in 0..k as usize {\n            product *= s[i + j].parse::<i32>().unwrap();\n        }\n        result = std::cmp::max(result, product);\n    }\n    result\n}",
                "fn special_pythagorean_triplet(n: i32) -> i32 {\n    for a in 1..n {\n        for b in a..n {\n            let c = n - a - b;\n            if a * a + b * b == c * c {\n                return a * b * c;\n            }\n        }\n    }\n    -1\n}",
                "fn summation_of_primes(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while i <= n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let mut result = 0;\n    for prime in &primes {\n        result += prime;\n    }\n    result\n}",
                "fn largest_product_in_a_grid(grid: &Vec<Vec<i32>>) -> i32 {\n    let mut result = 0;\n    for i in 0..grid.len() - 3 {\n        for j in 0..grid[i].len() - 3 {\n            let mut p1 = 1;\n            let mut p2 = 1;\n            let mut p3 = 1;\n            let mut p4 = 1;\n            for k in 0..4 {\n                p1 *= grid[i + k][j];\n                p2 *= grid[i][j + k];\n                p3 *= grid[i + k][j + k];\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = result.max(p1).max(p2).max(p3).max(p4);\n        }\n    }\n    result\n}",
                "fn highly_divisible_triangular_number(n: i32) -> i32 {\n    for i in 1..100000000 {\n        let result = i * (i + 1) / 2;\n        let mut count = 0;\n        for j in 1..=((result as f64).sqrt() as i32) {\n            if result % j == 0 {\n                count += 2;\n            }\n            if j * j == result {\n                count -= 1;\n            }\n        }\n        if count > n {\n            return result;\n        }\n    }\n    -1\n}",
                "fn large_sum(numbers: &Vec<String>) -> String {\n    let mut digits = vec![0; 60];\n    for i in 0..50 {\n        let mut tmp = 0;\n        for num in numbers {\n            tmp += num.chars().nth(49 - i).unwrap().to_digit(10).unwrap();\n        }\n        for j in i..60 {\n            digits[j] += tmp % 10;\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if tmp == 0 {\n                break;\n            }\n        }\n    }\n    for i in (59..0).rev() {\n        if digits[i] != 0 {\n            let mut result = String::new();\n            for j in i..i - 10 {\n                result.push(char::from_digit(digits[j], 10).unwrap());\n            }\n            return result;\n        }\n    }\n    \"0\".to_string()\n}",
                "fn longest_collatz_sequence(n: i32) -> i32 {\n    let mut longest = 0;\n    let mut result = 0;\n    for i in 1..n {\n        let mut chain = 1;\n        let mut num = i;\n        while num != 1 {\n            if num % 2 == 0 {\n                num /= 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if chain > longest {\n            longest = chain;\n            result = i;\n        }\n    }\n    result\n}",
                "fn lattice_paths(m: i32, n: i32) -> i32 {\n    let mut grid = vec![vec![0; n as usize + 1]; m as usize + 1];\n    for i in 0..m as usize + 1 {\n        grid[i][0] = 1;\n    }\n    for j in 0..n as usize + 1 {\n        grid[0][j] = 1;\n    }\n    for i in 1..m as usize + 1 {\n        for j in 1..n as usize + 1 {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    grid[m as usize][n as usize]\n}",
                "fn power_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![2];\n    for _ in 1..n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if carry != 0 {\n            digits.push(carry);\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
                "fn number_to_words(n: i32) -> String {\n    let ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if n == 1000 {\n        return \"one thousand\".to_string();\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n / 100].to_string() + \" hundred\";\n        } else {\n            return ones[n / 100].to_string() + \" hundred and \" + &number_to_words(n % 100);\n        }\n    } else if n >= 20 {\n        let suf = if n % 10 != 0 {\n            \" \" + &ones[n % 10]\n        } else {\n            \"\".to_string()\n        };\n        return tens[n / 10].to_string() + suf;\n    } else if n >= 10 {\n        return teens[n - 10].to_string();\n    } else {\n        return ones[n].to_string();\n    }\n}",
                "fn maximum_path_sum_i(triangle: &Vec<Vec<i32>>) -> i32 {\n    let mut curr = triangle.last().unwrap().clone();\n    for i in (0..triangle.len() - 1).rev() {\n        let mut next = triangle[i].clone();\n        for j in 0..next.len() {\n            next[j] += std::cmp::max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    curr[0]\n}",
                "fn counting_sundays(y1: i32, y2: i32) -> i32 {\n    let mut day = 0;\n    let mut count = 0;\n    for year in 1900..y2 + 1 {\n        for month in 1..13 {\n            if year >= y1 && day % 7 == 6 {\n                count += 1;\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30;\n            } else if month == 2 {\n                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    count\n}",
                "fn factorial_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![1];\n    for i in 1..=n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while carry > 0 {\n            digits.push(carry % 10);\n            carry /= 10;\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
                "fn d(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 2..=n.sqrt() {\n        if n % i == 0 {\n            result += i;\n            if i != n / i {\n                result += n / i;\n            }\n        }\n    }\n    result\n}\n\nfn amicable_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    for a in 2..n {\n        let b = d(a);\n        if a != b && a == d(b) {\n            result += a;\n        }\n    }\n    result\n}",
                "fn names_scores(names: &Vec<String>, queries: &Vec<String>) -> i32 {\n    let mut s_names = names.clone();\n    s_names.sort();\n    let mut result = 0;\n    for i in 0..s_names.len() {\n        let mut x = 0;\n        for c in s_names[i].chars() {\n            x += c as i32 - 64;\n        }\n        if queries.contains(&s_names[i]) {\n            result += x * (i + 1);\n        }\n    }\n    result\n}",
                "fn is_abundant(n: i32) -> bool {\n    if n < 12 {\n        return false;\n    }\n    let mut sum_divisors = 1;\n    for i in 2..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            sum_divisors += i;\n            if i != n / i {\n                sum_divisors += n / i;\n            }\n        }\n    }\n    sum_divisors > n\n}\n\nfn non_abundant_sums(n: i32) -> i32 {\n    let mut abundants = Vec::new();\n    for i in 12..n {\n        if is_abundant(i) {\n            abundants.push(i);\n        }\n    }\n    let mut abundant_sums = HashSet::new();\n    for i in abundants {\n        for j in abundants {\n            abundant_sums.insert(i + j);\n        }\n    }\n    let mut result = 0;\n    for i in 0..n {\n        if !abundant_sums.contains(&i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn lexicographic_permutations(n: i32) -> String {\n    let mut result = String::new();\n    let mut digits = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut x = n - 1;\n    for i in (1..=10).rev() {\n        let mut fact = 1;\n        for j in 1..i {\n            fact *= j;\n        }\n        let idx = x / fact;\n        result.push_str(&idx.to_string());\n        digits.remove(idx as usize);\n        x -= idx * fact;\n    }\n    result\n}",
                "fn n_digit_fibonacci_number(n: i32) -> i32 {\n    let mut a = vec![1];\n    let mut b = vec![1];\n    let mut i = 2;\n    while b.len() < n as usize {\n        let mut carry = 0;\n        let mut c = b.clone();\n        for j in 0..b.len() {\n            if j < a.len() {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if carry {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    i\n}",
                "fn reciprocal_cycles(n: i32) -> i32 {\n    let mut result = 0;\n    let mut max_length = 0;\n    for i in 1..n {\n        let mut remainders = Vec::new();\n        let mut remainder = 1;\n        while remainder != 0 && !remainders.contains(&remainder) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = if remainder != 0 {\n            remainders.len() - remainders.iter().position(|&x| x == remainder).unwrap()\n        } else {\n            0\n        };\n        if length > max_length {\n            max_length = length;\n            result = i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=((n as f64).sqrt() as i32) + 1).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn quadratic_primes(n: i32) -> i32 {\n    let mut max_primes = 0;\n    let mut result = 0;\n    for a in (-n + 1..=n).step_by(2) {\n        for b in (-n + 1..=n).step_by(2) {\n            let mut x = 0;\n            while x * x + a * x + b >= 2 {\n                if !is_prime(x * x + a * x + b) {\n                    break;\n                }\n                x += 1;\n            }\n            if x > max_primes {\n                max_primes = x;\n                result = a * b;\n            }\n        }\n    }\n    result\n}",
                "fn number_spiral_diagonals(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 3..=n {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    result\n}",
                "fn distinct_powers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut xs = HashSet::new();\n    for i in 2..n + 1 {\n        let primes = vec![2, 3, 5, 7];\n        let mut powers = vec![0, 0, 0, 0];\n        let mut num = i;\n        for j in 0..primes.len() {\n            while num % primes[j] == 0 {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if num != 1 {\n            result += n - 1;\n            continue;\n        }\n        for j in 2..n + 1 {\n            let pstr = format!(\"{}-{}-{}-{}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.len() as i32;\n    result\n}",
                "fn digit_nth_powers(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 2..4 * 10i32.pow(n) {\n        let mut digits_sum = 0;\n        for digit in i.to_string().chars() {\n            digits_sum += digit.to_digit(10).unwrap().pow(n);\n        }\n        if i == digits_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn coin_sums(n: i32) -> i32 {\n    let coins = vec![1, 2, 5, 10, 20, 50, 100, 200];\n    let mut ways = vec![0; n as usize + 1];\n    ways[0] = 1;\n    for coin in coins {\n        for i in coin..=n {\n            ways[i as usize] += ways[(i - coin) as usize];\n        }\n    }\n    ways[n as usize]\n}",
                "fn pandigital_products(n: i32) -> i32 {\n    let mut products = HashSet::new();\n    let s = (1..n+1).map(|i| i.to_string()).collect::<String>();\n    for a in 1..100 {\n        for b in 1..10000 {\n            let c = a * b;\n            let mut chars = vec![a.to_string(), b.to_string(), c.to_string()];\n            chars.sort();\n            if chars.iter().collect::<String>() == s {\n                products.insert(c);\n            }\n        }\n    }\n    let mut result = 0;\n    for product in products {\n        result += product;\n    }\n    result\n}",
                "fn digit_canceling_fractions(m: i32) -> i32 {\n    let mut numer = 1;\n    let mut denom = 1;\n    for d in 10..m {\n        for n in 10..d {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let mut a = numer;\n    let mut b = denom;\n    while b != 0 {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    denom / a\n}",
                "fn digit_factorials(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 3..n {\n        let mut fact_sum = 0;\n        for digit in i.to_string().chars() {\n            let mut fact = 1;\n            for j in 1..(digit.to_digit(10).unwrap() + 1) {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if i == fact_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn circular_primes(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 2..=n {\n        if is_prime(i) {\n            let mut rotations = HashSet::new();\n            for j in 0..(i.to_string().len()) {\n                rotations.insert(i.to_string()[j..].parse::<i32>().unwrap() + i.to_string()[..j].parse::<i32>().unwrap());\n            }\n            let mut flag = true;\n            for x in rotations {\n                if !is_prime(x) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
                "fn is_palindrome(s: &String) -> bool {\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn double_base_palindromes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 1..n {\n        let str_i = i.to_string();\n        let bin_i = format!(\"{:b}\", i);\n        if is_palindrome(&str_i) && is_palindrome(&bin_i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn truncatable_primes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 10..=n {\n        if is_prime(i) {\n            let si = i.to_string();\n            let mut flag = true;\n            for j in 1..si.len() {\n                let p1 = si[j..].parse::<i32>().unwrap();\n                let p2 = si[..si.len() - j].parse::<i32>().unwrap();\n                if !is_prime(p1) || !is_prime(p2) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                result += i;\n            }\n        }\n    }\n    result\n}",
                "fn pandigital_multiples(n: i32) -> i32 {\n    let mut result = -1;\n    for i in 2..n + 1 {\n        let mut cprod = String::new();\n        for j in 1..10 {\n            cprod.push_str(&(i * j).to_string());\n            if cprod.len() == 9 {\n                if cprod.chars().sorted().collect::<String>() == \"123456789\" {\n                    result = result.max(cprod.parse::<i32>().unwrap());\n                    break;\n                }\n            } else if cprod.len() > 9 {\n                break;\n            }\n        }\n    }\n    result\n}",
                "fn integer_right_triangles(n: i32) -> i32 {\n    let mut max_sol = 0;\n    let mut result = 0;\n    for p in 3..=n {\n        let mut sol = 0;\n        for a in 1..=(p / 2) {\n            for b in a..=(p / 2) {\n                let c = p - a - b;\n                if a * a + b * b == c * c {\n                    sol += 1;\n                }\n            }\n        }\n        if sol > max_sol {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    result\n}",
                "fn champernowne_constant(b: i32) -> i32 {\n    let mut s = String::new();\n    for i in 1..(b.pow(6)) {\n        s.push_str(&i.to_string());\n    }\n    let mut result = 1;\n    for i in 0..6 {\n        result *= s[b.pow(i) as usize - 1..b.pow(i + 1) as usize - 1].parse::<i32>().unwrap();\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=((n as f64).sqrt() as i32) + 1).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn pandigital_prime(n: i32) -> i32 {\n    for i in (n - 1..1).rev() {\n        if is_prime(i) {\n            let si = i.to_string();\n            let length = si.len();\n            let mut flag = true;\n            for j in 1..=length {\n                if !si.contains(&j.to_string()) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                return i;\n            }\n        }\n    }\n    -1\n}",
                "fn coded_triangle_numbers(words: &Vec<String>) -> i32 {\n    let mut result = 0;\n    for word in words {\n        let mut value = 0;\n        for c in word.chars() {\n            value += c as i32 - 64;\n        }\n        let n = (value as f64).sqrt() as i32;\n        if n * (n + 1) == value * 2 {\n            result += 1;\n        }\n    }\n    result\n}",
                "fn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.to_string()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn sub_string_divisibility(n: i32) -> i32 {\n    let mut result = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17];\n    let s = (0..n + 1).map(|i| i.to_string()).collect::<String>();\n    for i in gen_permutations(&s) {\n        let mut flag = true;\n        for j in 1..n - 1 {\n            if i[j..j + 3].parse::<i32>().unwrap() % primes[j - 1] != 0 {\n                flag = false;\n                break;\n            }\n        }\n        if flag {\n            result += i.parse::<i32>().unwrap();\n        }\n    }\n    result\n}",
                "fn pentagon_numbers(n: i32) -> i32 {\n    let mut pentagon = HashSet::new();\n    for i in 1..n {\n        pentagon.insert(i * (3 * i - 1) / 2);\n    }\n    let mut result = -1;\n    for j in &pentagon {\n        for k in &pentagon {\n            if pentagon.contains(&(j + k)) && pentagon.contains(&(k - j)) {\n                if result == -1 || k - j < result {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn triangular_pentagonal_and_hexagonal(n: i32) -> i32 {\n    let mut ps = HashSet::new();\n    let mut i = 1;\n    let mut c = 0.5 * i * (3 * i - 1);\n    while c < n {\n        i += 1;\n        ps.insert(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    let mut i = 1;\n    let mut c = i * (2 * i - 1);\n    let mut result = -1;\n    while c < n {\n        i += 1;\n        if ps.contains(&c) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=((n as f64).sqrt() as i32)).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn goldbachs_other_conjecture(n: i32) -> i32 {\n    let mut result = -1;\n    for i in (9999..=n).step_by(-2) {\n        let upper = ((i as f64).sqrt() as i32);\n        let mut flag = false;\n        for j in 0..=upper {\n            if is_prime(i - 2 * j * j) {\n                flag = true;\n                break;\n            }\n        }\n        if !flag {\n            result = i;\n        }\n    }\n    result\n}",
                "fn prime_factors(n: i32) -> i32 {\n    let mut num = n;\n    let mut factors = Vec::new();\n    let mut i = 2;\n    while i * i <= num {\n        if num % i != 0 {\n            i += 1;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if num > 1 {\n        factors.push(num);\n    }\n    factors.len() as i32\n}\n\nfn distinct_primes_factors(n: i32) -> i32 {\n    let mut i = n;\n    while i < 1000000 {\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4 {\n            return i;\n        }\n        i += 1;\n    }\n    -1\n}",
                "fn self_powers(n: i32) -> String {\n    let mut digits = [0; 10];\n    for i in 1..=n {\n        let mut temp_digits = [0; 10];\n        temp_digits[0] = 1;\n        for j in 0..i {\n            let mut carry = 0;\n            for k in 0..10 {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for j in 0..10 {\n            digits[j] += temp_digits[j];\n            if digits[j] >= 10 {\n                digits[j] -= 10;\n                if j < 9 {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let mut result = String::new();\n    for i in (0..10).rev() {\n        result.push_str(&digits[i].to_string());\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.clone()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn prime_permutations(n: i32) -> String {\n    for i in (n..=999).rev() {\n        if is_prime(i) {\n            let permutations = gen_permutations(&i.to_string());\n            let mut candidates = HashSet::new();\n            for j in permutations {\n                let candidate = j.parse::<i32>().unwrap();\n                if candidate > i && is_prime(candidate) {\n                    candidates.insert(candidate);\n                }\n            }\n            for m in candidates {\n                if m + (m - i) in candidates {\n                    return i.to_string() + m.to_string() + (m + (m - i)).to_string();\n                }\n            }\n        }\n    }\n    \"\".to_string()\n}",
                "fn consecutive_prime_sum(limit: i32) -> i32 {\n    let mut sieve = vec![true; limit as usize];\n    let mut primes = Vec::new();\n    for i in 2..limit {\n        if sieve[i as usize] {\n            primes.push(i);\n            for j in (i * 2)..limit {\n                sieve[j as usize] = false;\n            }\n        }\n    }\n    let mut max_length = 0;\n    let mut max_prime = 0;\n    for i in 0..primes.len() {\n        for j in i + max_length..primes.len() {\n            let s = primes[i..j].iter().sum();\n            if s >= limit {\n                break;\n            }\n            if sieve[s as usize] && j - i > max_length {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    max_prime\n}"
            ],
            "scala": [
                "def multiplesOf3And5(n: Int): Int = {\n  var result = 0\n  for (i <- 0 until n) {\n    if (i % 3 == 0 || i % 5 == 0) {\n      result += i\n    }\n  }\n  result\n}",
                "def evenFibonacciNumbers(n: Int): Int = {\n  var result = 0\n  var a = 1\n  var b = 2\n  while (a < n) {\n    if (a % 2 == 0) {\n      result += a\n    }\n    val tmp = a\n    a = b\n    b = tmp + b\n  }\n  result\n}",
                "def largestPrimeFactor(n: Int): Int = {\n  var result = n\n  var i = 2\n  while (i * i <= result) {\n    if (result % i != 0) {\n      i += 1\n    } else {\n      result /= i\n    }\n  }\n  result\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i) != s(s.length - i - 1)) {\n      return false\n    }\n  }\n  true\n}\n\ndef largestPalindromeProduct(n: Int): Int = {\n  var result = 0\n  for (i <- 100 until 1000) {\n    for (j <- i until 1000) {\n      val prod = i * j\n      if (isPalindrome(prod.toString) && prod > result && prod < n) {\n        result = prod\n      }\n    }\n  }\n  result\n}",
                "def smallestMultiple(n: Int): Int = {\n  var result = 1\n  for (i <- 1 to n) {\n    if result % i != 0 then {\n      for (j <- 1 to n) {\n        if (result * j) % i == 0 then {\n          result *= j\n          break\n        }\n      }\n    }\n  }\n  result\n}",
                "def sumSquareDifference(n: Int): Int = {\n  var sqrSum = 0\n  var numSum = 0\n  for (i <- 1 to n) {\n    sqrSum += i * i\n    numSum += i\n  }\n  numSum * numSum - sqrSum\n}",
                "def nthPrime(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (primes.length < n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  primes.last\n}",
                "def largestProductInASeries(s: String, k: Int): Int = {\n  var result = 0\n  for (i <- 0 until s.length - k) {\n    var product = 1\n    for (j <- 0 until k) {\n      product *= s(i + j).toInt\n    }\n    result = math.max(result, product)\n  }\n  result\n}",
                "def specialPythagoreanTriplet(n: Int): Int = {\n  for (a <- 1 until n) {\n    for (b <- a until n) {\n      val c = n - a - b\n      if (a * a + b * b == c * c) {\n        return a * b * c\n      }\n    }\n  }\n  -1\n}",
                "def summationOfPrimes(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (i <= n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  var result = 0\n  for (prime <- primes) {\n    result += prime\n  }\n  result\n}",
                "def largestProductInAGrid(grid: collection.Seq[collection.Seq[Int]]): Int = {\n  var result = 0\n  for (i <- 0 until grid.length - 3) {\n    for (j <- 0 until grid(i).length - 3) {\n      var p1, p2, p3, p4 = 1, 1, 1, 1\n      for (k <- 0 until 4) {\n        p1 *= grid(i + k)(j)\n      }\n      for (k <- 0 until 4) {\n        p2 *= grid(i)(j + k)\n      }\n      for (k <- 0 until 4) {\n        p3 *= grid(i + k)(j + k)\n      }\n      for (k <- 0 until 4) {\n        p4 *= grid(i + k)(j + 3 - k)\n      }\n      result = math.max(result, p1, p2, p3, p4)\n    }\n  }\n  result\n}",
                "def highlyDivisibleTriangularNumber(n: Int): Int = {\n  for (i <- 1 until 100000000) {\n    val result = i * (i + 1) / 2\n    var count = 0\n    for (j <- 1 until math.sqrt(result).toInt + 1) {\n      if (result % j == 0) {\n        count += 2\n      }\n      if (j * j == result) {\n        count -= 1\n      }\n    }\n    if (count > n) {\n      return result\n    }\n  }\n  -1\n}",
                "def largeSum(numbers: collection.Seq[String]): String = {\n  val digits = Array.fill(60)(0)\n  for (i <- 0 until 50) {\n    var tmp = 0\n    for (num <- numbers) {\n      tmp += num.charAt(49 - i).asDigit\n    }\n    for (j <- i until 60) {\n      digits(j) += tmp % 10\n      if (digits(j) >= 10) {\n        digits(j + 1) += digits(j) / 10\n        digits(j) %= 10\n      }\n      tmp /= 10\n      if (tmp == 0) {\n        break\n      }\n    }\n  }\n  for (i <- 59 to 0 by -1) {\n    if (digits(i) != 0) {\n      var result = \"\"\n      for (j <- i until i - 10 by -1) {\n        result += digits(j).toString\n      }\n      return result\n    }\n  }\n  \"\"\n}",
                "def longestCollatzSequence(n: Int): Int = {\n  var longest = 0\n  var result = 0\n  for (i <- 1 until n) {\n    var chain = 1\n    var num = i\n    while (num != 1) {\n      if (num % 2 == 0) {\n        num = num / 2\n      } else {\n        num = 3 * num + 1\n      }\n      chain += 1\n    }\n    if (chain > longest) {\n      longest = chain\n      result = i\n    }\n  }\n  result\n}",
                "def latticePaths(m: Int, n: Int): Int = {\n  val grid = Array.ofDim[Int](m + 1, n + 1)\n  for (i <- 0 until m + 1) {\n    grid(i)(0) = 1\n  }\n  for (j <- 0 until n + 1) {\n    grid(0)(j) = 1\n  }\n  for (i <- 1 until m + 1) {\n    for (j <- 1 until n + 1) {\n      grid(i)(j) = grid(i - 1)(j) + grid(i)(j - 1)\n    }\n  }\n  grid(m)(n)\n}",
                "def powerDigitSum(n: Int): Int = {\n  var digits = collection.mutable.ArrayBuffer[Int](2)\n  for (_ <- 1 until n) {\n    var carry = 0\n    for (j <- 0 until digits.length) {\n      val temp = digits(j) * 2 + carry\n      digits(j) = temp % 10\n      carry = temp / 10\n    }\n    if (carry != 0) {\n      digits += carry\n    }\n  }\n  var result = 0\n  for (digit <- digits) {\n    result += digit\n  }\n  result\n}",
                "def numberToWords(n: Int): String = {\n  val ones = Array(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n  val teens = Array(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n  val tens = Array(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n  if (n == 1000) {\n    return \"one thousand\"\n  } else if (n >= 100) {\n    if (n % 100 == 0) {\n      return ones(n / 100) + \" hundred\"\n    } else {\n      return ones(n / 100) + \" hundred and \" + numberToWords(n % 100)\n    }\n  } else if (n >= 20) {\n    var suf = \"\"\n    if (n % 10 != 0) {\n      suf = \" \" + ones(n % 10)\n    }\n    return tens(n / 10) + suf\n  } else if (n >= 10) {\n    return teens(n - 10)\n  } else {\n    return ones(n)\n  }\n}",
                "def maximumPathSumI(triangle: collection.Seq[collection.Seq[Int]]): Int = {\n  val curr = triangle.last.toArray\n  for (i <- triangle.length - 2 to 0 by -1) {\n    val next = triangle(i).toArray\n    for (j <- 0 until next.length) {\n      next(j) += math.max(curr(j), curr(j + 1))\n    }\n    curr = next\n  }\n  curr(0)\n}",
                "def countingSundays(y1: Int, y2: Int): Int = {\n  var day = 0\n  var count = 0\n  for (year <- 1900 until y2 + 1) {\n    for (month <- 1 until 13) {\n      if (year >= y1 && day % 7 == 6) {\n        count += 1\n      }\n      if (month == 4 || month == 6 || month == 9 || month == 11) {\n        day += 30\n      } else if (month == 2) {\n        if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n          day += 29\n        } else {\n          day += 28\n        }\n      } else {\n        day += 31\n      }\n    }\n  }\n  count\n}",
                "def factorialDigitSum(n: Int): Int = {\n  val digits = collection.mutable.ArrayBuffer[Int](1)\n  for (i <- 1 to n) {\n    var carry = 0\n    for (j <- 0 until digits.length) {\n      digits(j) = digits(j) * i + carry\n      carry = digits(j) / 10\n      digits(j) %= 10\n    }\n    while (carry > 0) {\n      digits += carry % 10\n      carry /= 10\n    }\n  }\n  var result = 0\n  for (digit <- digits) {\n    result += digit\n  }\n  result\n}",
                "def d(n: Int): Int = {\n  var result = 1\n  for (i <- 2 to math.sqrt(n).toInt + 1) {\n    if (n % i == 0) {\n      result += i\n      if (i != n / i) {\n        result += n / i\n      }\n    }\n  }\n  result\n}\n\ndef amicableNumbers(n: Int): Int = {\n  var result = 0\n  for (a <- 2 until n) {\n    val b = d(a)\n    if (a != b && a == d(b)) {\n      result += a\n    }\n  }\n  result\n}",
                "def namesScores(names: collection.Seq[String], queries: collection.Seq[String]): Int = {\n  val s_names = names.sorted\n  var result = 0\n  for (i <- s_names.indices) {\n    var x = 0\n    for (c <- s_names(i)) {\n      x += c.toInt - 64\n    }\n    if (s_names(i) == queries(i)) {\n      result += x * (i + 1)\n    }\n  }\n  result\n}",
                "def isAbundant(n: Int): Boolean = {\n  if (n < 12) {\n    return false\n  }\n  var sumDivisors = 1\n  for (i <- 2 to math.sqrt(n).toInt + 1) {\n    if (n % i == 0) {\n      sumDivisors += i\n      if (i != n / i) {\n        sumDivisors += n / i\n      }\n    }\n  }\n  sumDivisors > n\n}\n\ndef nonAbundantSums(n: Int): Int = {\n  val abundants = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 12 until n) {\n    if (isAbundant(i)) {\n      abundants += i\n    }\n  }\n  val abundantSums = collection.mutable.Set[Int]()\n  for (i <- abundants) {\n    for (j <- abundants) {\n      abundantSums += i + j\n    }\n  }\n  var result = 0\n  for (i <- 0 until n) {\n    if (!abundantSums.contains(i)) {\n      result += i\n    }\n  }\n  result\n}",
                "def lexicographicPermutations(n: Int): String = {\n  val result = new StringBuilder()\n  val digits = ArrayBuffer(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n  var x = n - 1\n  for (i <- 10 to 1 by -1) {\n    var fact = 1\n    for (j <- 1 until i) {\n      fact *= j\n    }\n    val idx = x / fact\n    result.append(digits(idx).toString)\n    digits.remove(idx)\n    x -= idx * fact\n  }\n  result.toString\n}",
                "def nDigitFibonacciNumber(n: Int): Int = {\n  val a = collection.mutable.ArrayBuffer[Int](1)\n  val b = collection.mutable.ArrayBuffer[Int](1)\n  var i = 2\n  while (b.length < n) {\n    var carry = 0\n    val c = b.clone()\n    for (j <- 0 until b.length) {\n      if (j < a.length) {\n        b(j) = a(j) + b(j) + carry\n      } else {\n        b(j) = b(j) + carry\n      }\n      carry = b(j) / 10\n      b(j) = b(j) % 10\n    }\n    if (carry) {\n      b.append(carry)\n    }\n    a = c\n    i = i + 1\n  }\n  i\n}",
                "def reciprocalCycles(n: Int): Int = {\n  var result = 0\n  var maxLength = 0\n  for (i <- 1 until n) {\n    val remainders = collection.mutable.ArrayBuffer[Int]()\n    var remainder = 1\n    while (remainder != 0 && !remainders.contains(remainder)) {\n      remainders += remainder\n      remainder = (remainder * 10) % i\n    }\n    var length = 0\n    if (remainder != 0) {\n      length = remainders.length - remainders.indexOf(remainder)\n    }\n    if (length > maxLength) {\n      maxLength = length\n      result = i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt + 1 by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef quadraticPrimes(n: Int): Int = {\n  var maxPrimes = 0\n  var result = 0\n  for (a <- -n + 1 to n by 2) {\n    for (b <- -n + 1 to n by 2) {\n      var x = 0\n      while (true) {\n        if (x * x + a * x + b < 2) {\n          break\n        }\n        if (!isPrime(x * x + a * x + b)) {\n          break\n        }\n        x += 1\n      }\n      if (x > maxPrimes) {\n        maxPrimes = x\n        result = a * b\n      }\n    }\n  }\n  result\n}",
                "def numberSpiralDiagonals(n: Int): Int = {\n  var result = 1\n  for (i <- 3 until n + 1 by 2) {\n    result += 4 * i * i - 6 * i + 6\n  }\n  result\n}",
                "def distinctPowers(n: Int): Int = {\n  var result = 0\n  val xs = collection.mutable.Set[String]()\n  for (i <- 2 until n + 1) {\n    val primes = Array(2, 3, 5, 7)\n    val powers = Array(0, 0, 0, 0)\n    var num = i\n    for (j <- 0 until primes.length) {\n      while (num % primes(j) == 0) {\n        num /= primes(j)\n        powers(j) += 1\n      }\n    }\n    if (num != 1) {\n      result += n - 1\n      continue\n    }\n    for (j <- 2 until n + 1) {\n      val pstr = s\"${powers(0) * j}-${powers(1) * j}-${powers(2) * j}-${powers(3) * j}\"\n      xs += pstr\n    }\n  }\n  result += xs.size\n  result\n}",
                "def digitNthPowers(n: Int): Int = {\n  var result = 0\n  for (i <- 2 until 4 * 10 ** n) {\n    var digitsSum = 0\n    for (digit <- i.toString) {\n      digitsSum += digit.toInt ** n\n    }\n    if (i == digitsSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def coinSums(n: Int): Int = {\n  val coins = Array(1, 2, 5, 10, 20, 50, 100, 200)\n  val ways = Array.fill(n + 1)(0)\n  ways(0) = 1\n  for (coin <- coins) {\n    for (i <- coin until n + 1) {\n      ways(i) += ways(i - coin)\n    }\n  }\n  ways(n)\n}",
                "def pandigitalProducts(n: Int): Int = {\n  val products = collection.mutable.Set[Int]()\n  val s = (1 to n).map(_.toString).mkString\n  for (a <- 1 until 100) {\n    for (b <- 1 until 10000) {\n      val c = a * b\n      val chars = (a.toString + b.toString + c.toString).toList.sorted\n      if (chars.mkString == s) {\n        products += c\n      }\n    }\n  }\n  var result = 0\n  for (product <- products) {\n    result += product\n  }\n  result\n}",
                "def digitCancelingFractions(m: Int): Int = {\n  var numer = 1\n  var denom = 1\n  for (d <- 10 until m) {\n    for (n <- 10 until d) {\n      val n0 = n % 10\n      val n1 = n / 10\n      val d0 = d % 10\n      val d1 = d / 10\n      if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n        numer *= n\n        denom *= d\n      }\n    }\n  }\n  var a = numer\n  var b = denom\n  while (b != 0) {\n    val t = b\n    b = a % b\n    a = t\n  }\n  denom / a\n}",
                "def digitFactorials(n: Int): Int = {\n  var result = 0\n  for (i <- 3 until n) {\n    var fact_sum = 0\n    for (digit <- i.toString) {\n      var fact = 1\n      for (j <- 1 until digit.toInt + 1) {\n        fact *= j\n      }\n      fact_sum += fact\n    }\n    if (i == fact_sum) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt + 1 by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef circularPrimes(n: Int): Int = {\n  var count = 0\n  for (i <- 2 until n) {\n    if (isPrime(i)) {\n      val rotations = collection.mutable.Set[Int]()\n      for (j <- 0 until i.toString.length) {\n        rotations += i.toString.substring(j).toInt + i.toString.substring(0, j).toInt\n      }\n      var flag = true\n      for (x <- rotations) {\n        if (!isPrime(x)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        count += 1\n      }\n    }\n  }\n  count\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i) != s(s.length - 1 - i)) {\n      return false\n    }\n  }\n  true\n}\n\ndef doubleBasePalindromes(n: Int): Int = {\n  var result = 0\n  for (i <- 1 until n) {\n    val str_i = i.toString\n    val bin_i = Integer.toBinaryString(i)\n    if (isPalindrome(str_i) && isPalindrome(bin_i)) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt + 1 by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef truncatablePrimes(n: Int): Int = {\n  var result = 0\n  for (i <- 10 until n) {\n    if (isPrime(i)) {\n      val si = i.toString\n      var flag = true\n      for (j <- 1 until si.length) {\n        val p1 = si.substring(j).toInt\n        val p2 = si.substring(0, si.length - j).toInt\n        if (!isPrime(p1) || !isPrime(p2)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        result += i\n      }\n    }\n  }\n  result\n}",
                "def pandigitalMultiples(n: Int): Int = {\n  var result = -1\n  for (i <- 2 until n + 1) {\n    var cprod = \"\"\n    for (j <- 1 until 10) {\n      cprod += i * j\n      if (cprod.length == 9) {\n        if (cprod.sorted.mkString == \"123456789\") {\n          result = math.max(result, cprod.toInt)\n          break\n        }\n      } else if (cprod.length > 9) {\n        break\n      }\n    }\n  }\n  result\n}",
                "def integerRightTriangles(n: Int): Int = {\n  var maxSol = 0\n  var result = 0\n  for (p <- 3 to n) {\n    var sol = 0\n    for (a <- 1 until p / 2) {\n      for (b <- a until p / 2) {\n        val c = p - a - b\n        if (a * a + b * b == c * c) {\n          sol += 1\n        }\n      }\n    }\n    if (sol > maxSol) {\n      maxSol = sol\n      result = p\n    }\n  }\n  result\n}",
                "def champernowneConstant(b: Int): Int = {\n  val s = new StringBuilder()\n  for (i <- 1 until math.pow(b, 6).toInt) {\n    s.append(i.toString)\n  }\n  var result = 1\n  for (i <- 0 until 7) {\n    result *= s.charAt(math.pow(b, i).toInt - 1).toString.toInt\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt + 1 by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef pandigitalPrime(n: Int): Int = {\n  for (i <- n - 1 to 1 by -1) {\n    if (isPrime(i)) {\n      val si = i.toString\n      val length = si.length\n      var flag = true\n      for (j <- 1 to length) {\n        if (!si.contains(j.toString)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        return i\n      }\n    }\n  }\n  -1\n}",
                "def codedTriangleNumbers(words: collection.Seq[String]): Int = {\n  var result = 0\n  for (word <- words) {\n    var value = 0\n    for (c <- word) {\n      value += c.toInt - 64\n    }\n    val n = math.sqrt(value * 2).toInt\n    if (n * (n + 1) == value * 2) {\n      result += 1\n    }\n  }\n  result\n}",
                "def genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    return s\n  }\n  val result = collection.mutable.ArrayBuffer[String]()\n  for (perm <- genPermutations(s.substring(1))) {\n    for (i <- 0 until s.length) {\n      result += perm.substring(0, i) + s.substring(0, 1) + perm.substring(i)\n    }\n  }\n  result\n}\n\ndef subStringDivisibility(n: Int): Int = {\n  val result = 0\n  val primes = Array(2, 3, 5, 7, 11, 13, 17)\n  val s = (0 until n + 1).map(i => i.toString).mkString\n  for (i <- genPermutations(s)) {\n    var flag = true\n    for (j <- 1 until n - 1) {\n      if (i.substring(j, j + 3).toInt % primes(j - 1) != 0) {\n        flag = false\n        break\n      }\n    }\n    if (flag) {\n      result += i.toInt\n    }\n  }\n  result\n}",
                "def pentagonNumbers(n: Int): Int = {\n  val pentagon = collection.mutable.Set[Int]()\n  for (i <- 1 until n) {\n    pentagon += (i * (3 * i - 1) / 2)\n  }\n  var result = -1\n  for (j <- pentagon) {\n    for (k <- pentagon) {\n      if (j + k) in pentagon && (k - j) in pentagon && (k - j) < result {\n        result = k - j\n      }\n    }\n  }\n  result\n}",
                "def triangularPentagonalAndHexagonal(n: Int): Int = {\n  val ps = collection.mutable.Set[Int]()\n  var i = 1\n  var c = 0.5 * i * (3 * i - 1)\n  while (c < n) {\n    i += 1\n    ps += c\n    c = 0.5 * i * (3 * i - 1)\n  }\n  i = 1\n  c = i * (2 * i - 1)\n  var result = -1\n  while (c < n) {\n    i += 1\n    if (ps.contains(c)) {\n      result = c\n    }\n    c = i * (2 * i - 1)\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    return false\n  }\n  if (n == 2) {\n    return true\n  }\n  if (n % 2 == 0) {\n    return false\n  }\n  for (i <- 3 to math.sqrt(n).toInt by 2) {\n    if (n % i == 0) {\n      return false\n    }\n  }\n  true\n}\n\ndef goldbachsOtherConjecture(n: Int): Int = {\n  var result = -1\n  for (i <- 9999 to n by -2) {\n    val upper = math.sqrt(i / 2).toInt\n    var flag = false\n    for (j <- 0 to upper) {\n      if (isPrime(i - 2 * j * j)) {\n        flag = true\n        break\n      }\n    }\n    if (!flag) {\n      result = i\n    }\n  }\n  result\n}",
                "def primeFactors(n: Int): Int = {\n  var num = n\n  val factors = collection.mutable.ArrayBuffer[Int]()\n  var i = 2\n  while (i * i <= num) {\n    if (num % i != 0) {\n      i += 1\n    } else {\n      num /= i\n      factors += i\n    }\n  }\n  if (num > 1) {\n    factors += num\n  }\n  factors.length\n}\n\ndef distinctPrimesFactors(n: Int): Int = {\n  var i = n\n  while (i < 1000000) {\n    if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n      return i\n    }\n    i += 1\n  }\n  -1\n}",
                "def selfPowers(n: Int): String = {\n  val digits = Array.fill(10)(0)\n  for (i <- 1 until n + 1) {\n    val tempDigits = Array.fill(10)(0)\n    tempDigits(0) = 1\n    for (j <- 0 until i) {\n      var carry = 0\n      for (k <- 0 until 10) {\n        tempDigits(k) = tempDigits(k) * i + carry\n        carry = tempDigits(k) / 10\n        tempDigits(k) %= 10\n      }\n    }\n    for (j <- 0 until 10) {\n      digits(j) += tempDigits(j)\n      if (digits(j) >= 10) {\n        digits(j) -= 10\n        if (j < 9) {\n          digits(j + 1) += 1\n        }\n      }\n    }\n  }\n  var result = \"\"\n  for (i <- 9 to 0 by -1) {\n    result += digits(i).toString\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    for (i <- 3 to math.sqrt(n).toInt + 1 by 2) {\n      if (n % i == 0) {\n        return false\n      }\n    }\n    true\n  }\n}\n\ndef genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    s\n  } else {\n    val result = collection.mutable.ArrayBuffer[String]()\n    for (perm <- genPermutations(s.substring(1))) {\n      for (i <- 0 until s.length) {\n        result += perm.substring(0, i) + s.substring(0, 1) + perm.substring(i)\n      }\n    }\n    result\n  }\n}\n\ndef primePermutations(n: Int): String = {\n  for (i <- n to 999 by -1) {\n    if (isPrime(i)) {\n      val permutations = genPermutations(i.toString)\n      val candidates = collection.mutable.Set[Int]()\n      for (j <- permutations) {\n        val candidate = j.toInt\n        if (candidate > i && isPrime(candidate)) {\n          candidates += candidate\n        }\n      }\n      for (m <- candidates) {\n        if (m + (m - i) in candidates) {\n          return i.toString + m.toString + (m + (m - i)).toString\n        }\n      }\n    }\n  }\n  \"\"\n}",
                "def consecutivePrimeSum(limit: Int): Int = {\n  val sieve = Array.fill(limit)(true)\n  val primes = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 2 until limit) {\n    if (sieve(i)) {\n      primes += i\n      for (j <- i * 2 until limit by i) {\n        sieve(j) = false\n      }\n    }\n  }\n  var maxLength = 0\n  var maxPrime = 0\n  for (i <- 0 until primes.length) {\n    for (j <- i + maxLength until primes.length) {\n      val s = primes.slice(i, j).sum\n      if (s >= limit) {\n        break\n      }\n      if (sieve(s) && j - i > maxLength) {\n        maxLength = j - i\n        maxPrime = s\n      }\n    }\n  }\n  maxPrime\n}"
            ]
        }
    },
    "starcoderbase": {
        "go": {
            "cpp": [
                "int multiplesOf3And5(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int evenFibonacciNumbers(int n) {\n    int result = 0;\n    int a = 1;\n    int b = 2;\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a;\n        }\n        int tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "int largestPrimeFactor(int n) {\n    int result = n;\n    int i = 2;\n    while (i * i <= result) {\n        if (result % i!= 0) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i]!= s[s.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint largestPalindromeProduct(int n) {\n    int result = 0;\n    for (int i = 100; i < 1000; i++) {\n        for (int j = i; j < 1000; j++) {\n            int prod = i * j;\n            if (isPalindrome(to_string(prod)) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "int smallestMultiple(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        if (result % i!= 0) {\n            for (int j = 1; j <= n; j++) {\n                if ((result * j) % i == 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int sumSquareDifference(int n) {\n    int sqrSum = 0;\n    int numSum = 0;\n    for (int i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "int nthPrime(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (primes.size() < n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.size() - 1];\n}",
                "int largestProductInASeries(const string& s, int k) {\n    int result = 0;\n    for (int i = 0; i < s.size() - k; i++) {\n        int product = 1;\n        for (int j = 0; j < k; j++) {\n            product *= s[i + j] - '0';\n        }\n        result = max(result, product);\n    }\n    return result;\n}",
                "int specialPythagoreanTriplet(int n) {\n    for (int a = 1; a < n; a++) {\n        for (int b = a; b < n; b++) {\n            int c = n - a - b;\n            if (a * a + b * b == c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "int summationOfPrimes(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (i <= n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    int result = 0;\n    for (int prime : primes) {\n        result += prime;\n    }\n    return result;\n}",
                "int largestProductInAGrid(const vector<vector<int>>& grid) {\n    int result = 0;\n    for (int i = 0; i < grid.size() - 3; i++) {\n        for (int j = 0; j < grid[i].size() - 3; j++) {\n            int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (int k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (int k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "int highlyDivisibleTriangularNumber(int n) {\n    for (int i = 1; i < 100000000; i++) {\n        int result = i * (i + 1) / 2;\n        int count = 0;\n        for (int j = 1; j <= int(sqrt(result)); j++) {\n            if (result % j == 0) {\n                count += 2;\n            }\n            if (j * j == result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "string largeSum(const vector<string>& numbers) {\n    vector<int> digits(60);\n    for (int i = 0; i < 50; i++) {\n        int tmp = 0;\n        for (const string& num : numbers) {\n            tmp += num[49 - i] - '0';\n        }\n        for (int j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if (tmp == 0) {\n                break;\n            }\n        }\n    }\n    for (int i = 59; i >= 0; i--) {\n        if (digits[i]!= 0) {\n            string result;\n            for (int j = i; j > i - 10; j--) {\n                result += to_string(digits[j]);\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
                "int longestCollatzSequence(int n) {\n    int longest = 0;\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        int chain = 1;\n        int num = i;\n        while (num!= 1) {\n            if (num % 2 == 0) {\n                num /= 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "int latticePaths(int m, int n) {\n    vector<vector<int>> grid(m + 1, vector<int>(n + 1));\n    for (int i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (int j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "int powerDigitSum(int n) {\n    vector<int> digits = {2};\n    for (int i = 1; i < n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            int temp = digits[j]*2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry!= 0) {\n            digits.push_back(carry);\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "string numberToWords(int n) {\n    vector<string> ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    vector<string> teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n    vector<string> tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        string suf = \"\";\n        if (n % 10!= 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "int maximumPathSumI(const vector<vector<int>>& triangle) {\n    vector<int> curr(triangle[triangle.size() - 1]);\n    for (int i = triangle.size() - 2; i >= 0; i--) {\n        vector<int> next(triangle[i]);\n        for (int j = 0; j < next.size(); j++) {\n            next[j] += max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "int countingSundays(int y1, int y2) {\n    int day = 0;\n    int count = 0;\n    for (int year = 1900; year <= y2; year++) {\n        for (int month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 == 6) {\n                count++;\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30;\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "int factorialDigitSum(int n) {\n    vector<int> digits = {1};\n    for (int i = 1; i <= n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while (carry!= 0) {\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "int d(int n) {\n    int result = 1;\n    for (int i = 2; i <= int(sqrt(n)); i++) {\n        if (n % i == 0) {\n            result += i;\n            if (i!= n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nint amicableNumbers(int n) {\n    int result = 0;\n    for (int a = 2; a < n; a++) {\n        int b = d(a);\n        if (a!= b && a == d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "int namesScores(const vector<string>& names, const vector<string>& queries) {\n    vector<string> sNames = slices::Clone(names);\n    slices::Sort(sNames);\n    int result = 0;\n    for (int i = 0; i < sNames.size(); i++) {\n        int x = 0;\n        for (char c : sNames[i]) {\n            x += int(c) - 64;\n        }\n        for (const string& query : queries) {\n            if (query == sNames[i]) {\n                result += x * (i + 1);\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "bool isAbundant(int n) {\n    if (n < 12) {\n        return false;\n    }\n    int sumDivisors = 1;\n    for (int i = 2; i <= int(sqrt(n)); i++) {\n        if (n % i == 0) {\n            sumDivisors += i;\n            if (i!= n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nint nonAbundantSums(int n) {\n    vector<int> abundants;\n    for (int i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push_back(i);\n        }\n    }\n    map<int, bool> abundantSums;\n    for (int i : abundants) {\n        for (int j : abundants) {\n            abundantSums[i + j] = true;\n        }\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (!abundantSums[i]) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "string lexicographicPermutations(int n) {\n    string result;\n    vector<int> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = n - 1;\n    for (int i = 10; i > 0; i--) {\n        int fact = 1;\n        for (int j = 1; j < i; j++) {\n            fact *= j;\n        }\n        int idx = x / fact;\n        result += to_string(digits[idx]);\n        digits.erase(digits.begin() + idx);\n        x -= idx * fact;\n    }\n    return result;\n}",
                "int nDigitFibonacciNumber(int n) {\n    vector<int> a = {1};\n    vector<int> b = {1};\n    int i = 2;\n    while (b.size() < n) {\n        int carry = 0;\n        vector<int> c = b;\n        for (int j = 0; j < b.size(); j++) {\n            if (j < a.size()) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry!= 0) {\n            b.push_back(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
                "int reciprocalCycles(int n) {\n    int result = 0;\n    int maxLength = 0;\n    for (int i = 1; i < n; i++) {\n        vector<int> remainders;\n        int remainder = 1;\n        while (remainder!= 0 &&!slices::contains(remainders, remainder)) {\n            remainders.push_back(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        int length = 0;\n        if (remainder!= 0) {\n            length = remainders.size() - slices::index(remainders, remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint quadraticPrimes(int n) {\n    int maxPrimes = 0;\n    int result = 0;\n    for (int a = -n + 1; a < n; a += 2) {\n        for (int b = -n + 1; b < n; b += 2) {\n            int x = 0;\n            for (;;) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "int numberSpiralDiagonals(int n) {\n    int result = 1;\n    for (int i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "int distinctPowers(int n) {\n    int result = 0;\n    map<string, bool> xs;\n    for (int i = 2; i <= n; i++) {\n        vector<int> primes = {2, 3, 5, 7};\n        vector<int> powers = {0, 0, 0, 0};\n        int num = i;\n        for (int j = 0; j < primes.size(); j++) {\n            while (num % primes[j] == 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num!= 1) {\n            result += n - 1;\n            continue;\n        }\n        for (int j = 2; j <= n; j++) {\n            string pstr = to_string(powers[0] * j) + \"-\" + to_string(powers[1] * j) + \"-\" + to_string(powers[2] * j) + \"-\" + to_string(powers[3] * j);\n            xs[pstr] = true;\n        }\n    }\n    result += xs.size();\n    return result;\n}",
                "int digitNthPowers(int n) {\n    int result = 0;\n    for (int i = 2; i < 4 * pow(10, n); i++) {\n        int digitsSum = 0;\n        for (char digit : to_string(i)) {\n            digitsSum += pow(digit - '0', n);\n        }\n        if (i == digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int coinSums(int n) {\n    vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 200};\n    vector<int> ways(n + 1);\n    ways[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "int pandigitalProducts(int n) {\n    map<int, bool> products;\n    string s;\n    for (int i = 1; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (int a = 1; a < 100; a++) {\n        for (int b = 1; b < 10000; b++) {\n            int c = a * b;\n            string chars = to_string(a) + to_string(b) + to_string(c);\n            sort(chars.begin(), chars.end());\n            if (chars == s) {\n                products[c] = true;\n            }\n        }\n    }\n    int result = 0;\n    for (int product : products) {\n        result += product;\n    }\n    return result;\n}",
                "int digitCancelingFractions(int m) {\n    int numer = 1;\n    int denom = 1;\n    for (int d = 10; d < m; d++) {\n        for (int n = 10; n < d; n++) {\n            int n0 = n % 10;\n            int n1 = n / 10;\n            int d0 = d % 10;\n            int d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    int a = numer;\n    int b = denom;\n    while (b!= 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return denom / a;\n}",
                "int digitFactorials(int n) {\n    int result = 0;\n    for (int i = 3; i < n; i++) {\n        int factSum = 0;\n        for (char digit : to_string(i)) {\n            int fact = 1;\n            for (int j = 1; j <= digit - '0'; j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i == factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint circularPrimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            map<int, struct> rotations;\n            string str = to_string(i);\n            for (int j = 0; j < str.size(); j++) {\n                int x = stoi(str.substr(j) + str.substr(0, j));\n                rotations[x] = {};\n            }\n            bool flag = true;\n            for (int x : rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i]!= s[s.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint doubleBasePalindromes(int n) {\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        string strI = to_string(i);\n        string binI = bitset<32>(i).to_string();\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint truncatablePrimes(int n) {\n    int result = 0;\n    for (int i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            bool flag = true;\n            for (int j = 1; j < si.size(); j++) {\n                int p1 = stoi(si.substr(j));\n                int p2 = stoi(si.substr(0, si.size() - j));\n                if (!isPrime(p1) ||!isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "int pandigitalMultiples(int n) {\n    int result = -1;\n    for (int i = 2; i <= n; i++) {\n        string cprod;\n        for (int j = 1; j < 10; j++) {\n            cprod += to_string(i * j);\n            if (cprod.size() == 9) {\n                vector<string> chars = split(cprod, \"\");\n                sort(chars.begin(), chars.end());\n                if (join(chars, \"\") == \"123456789\") {\n                    result = max(result, stoi(cprod));\n                    break;\n                }\n            } else if (cprod.size() > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "int integerRightTriangles(int n) {\n    int maxSol = 0;\n    int result = 0;\n    for (int p = 3; p <= n; p++) {\n        int sol = 0;\n        for (int a = 1; a < p / 2; a++) {\n            for (int b = a; b < p / 2; b++) {\n                int c = p - a - b;\n                if (a * a + b * b == c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "int champernowneConstant(int b) {\n    string s;\n    for (int i = 1; i < pow(b, 6); i++) {\n        s += to_string(i);\n    }\n    int result = 1;\n    for (int i = 0; i < 7; i++) {\n        result *= stoi(string(s[pow(b, i) - 1]));\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint pandigitalPrime(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            int length = si.size();\n            bool flag = true;\n            for (int j = 1; j <= length; j++) {\n                if (!si.find(to_string(j))) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "int codedTriangleNumbers(const vector<string>& words) {\n    int result = 0;\n    for (const string& word : words) {\n        int value = 0;\n        for (char c : word) {\n            value += int(c) - 64;\n        }\n        int n = int(sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result++;\n        }\n    }\n    return result;\n}",
                "vector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + string(s[0]) + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nint subStringDivisibility(int n) {\n    int result = 0;\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17};\n    string s;\n    for (int i = 0; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (const string& i : genPermutations(s)) {\n        bool flag = true;\n        for (int j = 1; j < n - 1; j++) {\n            if (stoi(i.substr(j, 3)) % primes[j - 1]!= 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += stoi(i);\n        }\n    }\n    return result;\n}",
                "int pentagonNumbers(int n) {\n    map<int, bool> pentagon;\n    for (int i = 1; i < n; i++) {\n        pentagon[i * (3 * i - 1) / 2] = true;\n    }\n    int result = -1;\n    for (const auto& [j, _] : pentagon) {\n        for (const auto& [k, _] : pentagon) {\n            if (pentagon[j + k] && pentagon[k - j]) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int triangularPentagonalAndHexagonal(int n) {\n    map<int, bool> ps;\n    int i = 1;\n    int c = int(0.5 * float(i) * (3 * float(i) - 1));\n    while (c < n) {\n        i++;\n        ps[c] = true;\n        c = int(0.5 * float(i) * (3 * float(i) - 1));\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    int result = -1;\n    while (c < n) {\n        i++;\n        if (ps[c]) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint goldbachsOtherConjecture(int n) {\n    int result = -1;\n    for (int i = 9999; i > n; i -= 2) {\n        int upper = int(sqrt(i / 2));\n        bool flag = false;\n        for (int j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "int primeFactors(int n) {\n    int num = n;\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= num) {\n        if (num % i!= 0) {\n            i++;\n        } else {\n            num /= i;\n            factors.push_back(i);\n        }\n    }\n    if (num > 1) {\n        factors.push_back(num);\n    }\n    unordered_set<int> s;\n    for (int v : factors) {\n        s.insert(v);\n    }\n    return s.size();\n}\n\nint distinctPrimesFactors(int n) {\n    for (int i = n; i < 1000000; i++) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "string selfPowers(int n) {\n    int digits[10] = {0};\n    for (int i = 1; i <= n; i++) {\n        int tempDigits[10] = {0};\n        tempDigits[0] = 1;\n        for (int j = 0; j < i; j++) {\n            int carry = 0;\n            for (int k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = tempDigits[k] / 10;\n                tempDigits[k] %= 10;\n            }\n        }\n        for (int j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    string result;\n    for (int i = 9; i >= 0; i--) {\n        result += to_string(digits[i]);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + string(s[0]) + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nstring primePermutations(int n) {\n    for (int i = n; i > 999; i--) {\n        if (isPrime(i)) {\n            vector<string> permutations = genPermutations(to_string(i));\n            map<int, bool> candidates;\n            for (const string& j : permutations) {\n                int candidate = stoi(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates[candidate] = true;\n                }\n            }\n            for (int m : candidates) {\n                if (candidates[m + (m - i)]) {\n                    return to_string(i) + to_string(m) + to_string(m + (m - i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "int consecutivePrimeSum(int limit) {\n    vector<bool> sieve(limit);\n    for (int i = 0; i < limit; i++) {\n        sieve[i] = true;\n    }\n    vector<int> primes;\n    for (int i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n            for (int j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    int maxLength = 0;\n    int maxPrime = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i + maxLength; j < primes.size(); j++) {\n            int s = 0;\n            for (int k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
            ],
            "csharp": [
                "class Global {\n    public static int MultiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int EvenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i!= 0) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i]!= s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int LargestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (IsPalindrome(prod.ToString()) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SmallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i!= 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int NthPrime(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (primes.Count < n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes[primes.Count - 1];\n    }\n}",
                "class Global {\n    public static int LargestProductInASeries(string s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.Length - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= int.Parse(s[i + j].ToString());\n            }\n            result = Math.Max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SpecialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int SummationOfPrimes(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (i <= n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        foreach (int prime in primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestProductInAGrid(IList<IList<int>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.Count - 3; i++) {\n            for (int j = 0; j < grid[i].Count - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid[i + k][j];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid[i][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid[i + k][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid[i + k][j + 3 - k];\n                }\n                result = Math.Max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int HighlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int)Math.Sqrt(result); j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string LargeSum(IList<string> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            foreach (string num in numbers) {\n                tmp += int.Parse(num[49 - i].ToString());\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i]!= 0) {\n                string result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += digits[j].ToString();\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int LongestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num!= 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LatticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][];\n        for (int i = 0; i <= m; i++) {\n            grid[i] = new int[n + 1];\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int PowerDigitSum(int n) {\n        IList<int> digits = new List<int> { 2 };\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            foreach (int j in digits) {\n                int temp = j * 2 + carry;\n                digits[digits.IndexOf(j)] = temp % 10;\n                carry = temp / 10;\n            }\n            if (carry!= 0) {\n                digits.Add(carry);\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string NumberToWords(int n) {\n        string[] ones = new string[] { \"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\n        string[] teens = new string[] { \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" };\n        string[] tens = new string[] { \"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            string suf = \"\";\n            if (n % 10!= 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int MaximumPathSumI(IList<IList<int>> triangle) {\n        IList<int> curr = new List<int>(triangle[triangle.Count - 1]);\n        for (int i = triangle.Count - 2; i >= 0; i--) {\n            IList<int> next = new List<int>(triangle[i]);\n            for (int j = 0; j < next.Count; j++) {\n                next[j] += Math.Max(curr[j], curr[j + 1]);\n            }\n            curr = next;\n        }\n        return curr[0];\n    }\n}",
                "class Global {\n    public static int CountingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count++;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int FactorialDigitSum(int n) {\n        IList<int> digits = new List<int> { 1 };\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                digits[j] = digits[j] * i + carry;\n                carry = digits[j] / 10;\n                digits[j] %= 10;\n            }\n            while (carry!= 0) {\n                digits.Add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int D(int n) {\n        int result = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i!= n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int AmicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = D(a);\n            if (a!= b && a == D(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NamesScores(IList<string> names, IList<string> queries) {\n        IList<string> sNames = slices.Clone(names);\n        slices.Sort(sNames);\n        int result = 0;\n        for (int i = 0; i < sNames.Count; i++) {\n            int x = 0;\n            foreach (char c in sNames[i]) {\n                x += int(c) - 64;\n            }\n            foreach (string query in queries) {\n                if (query == sNames[i]) {\n                    result += x * (i + 1);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i!= n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int NonAbundantSums(int n) {\n        IList<int> abundants = new List<int>();\n        for (int i = 12; i < n; i++) {\n            if (IsAbundant(i)) {\n                abundants.Add(i);\n            }\n        }\n        IDictionary<int, bool> abundantSums = new Dictionary<int, bool>();\n        foreach (int i in abundants) {\n            foreach (int j in abundants) {\n                abundantSums[i + j] = true;\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums[i]) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string LexicographicPermutations(int n) {\n        string result = \"\";\n        IList<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += digits[idx].ToString();\n            digits.RemoveAt(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NDigitFibonacciNumber(int n) {\n        IList<int> a = new List<int> { 1 };\n        IList<int> b = new List<int> { 1 };\n        int i = 2;\n        while (b.Count < n) {\n            int carry = 0;\n            IList<int> c = new List<int>(b);\n            for (int j = 0; j < b.Count; j++) {\n                if (j < a.Count) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry!= 0) {\n                b.Add(carry);\n            }\n            a = new List<int>(c);\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int ReciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            IList<int> remainders = new List<int>();\n            int remainder = 1;\n            while (remainder!= 0 &&!remainders.Contains(remainder)) {\n                remainders.Add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder!= 0) {\n                length = remainders.Count - remainders.IndexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int QuadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!IsPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x++;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NumberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DistinctPowers(int n) {\n        int result = 0;\n        IDictionary<string, bool> xs = new Dictionary<string, bool>();\n        for (int i = 2; i <= n; i++) {\n            IList<int> primes = new List<int> { 2, 3, 5, 7 };\n            IList<int> powers = new List<int> { 0, 0, 0, 0 };\n            int num = i;\n            for (int j = 0; j < primes.Count; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num!= 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                string pstr = string.Format(\"{0}-{1}-{2}-{3}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n                xs[pstr] = true;\n            }\n        }\n        result += xs.Count;\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * (int)Math.Pow(10, (double)n); i++) {\n            int digitsSum = 0;\n            foreach (char digit in i.ToString()) {\n                digitsSum += (int)Math.Pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int CoinSums(int n) {\n        int[] coins = new int[] { 1, 2, 5, 10, 20, 50, 100, 200 };\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        foreach (int coin in coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int PandigitalProducts(int n) {\n        IDictionary<int, bool> products = new Dictionary<int, bool>();\n        string s = \"\";\n        for (int i = 1; i <= n; i++) {\n            s += i.ToString();\n        }\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                char[] chars = (a.ToString() + b.ToString() + c.ToString()).ToCharArray();\n                Array.Sort(chars);\n                if (new string(chars) == s) {\n                    products[c] = true;\n                }\n            }\n        }\n        int result = 0;\n        foreach (int product in products.Keys) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b!= 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int DigitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            foreach (char digit in i.ToString()) {\n                int fact = 1;\n                for (int j = 1; j <= int(digit - '0'); j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int CircularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (IsPrime(i)) {\n                IDictionary<int, object> rotations = new Dictionary<int, object>();\n                string str = i.ToString();\n                for (int j = 0; j < str.Length; j++) {\n                    int x = int.Parse(str.Substring(j) + str.Substring(0, j));\n                    rotations[x] = null;\n                }\n                bool flag = true;\n                foreach (int x in rotations.Keys) {\n                    if (!IsPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i]!= s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int DoubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            string strI = i.ToString();\n            string binI = Convert.ToString(i, 2);\n            if (IsPalindrome(strI) && IsPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int TruncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                bool flag = true;\n                for (int j = 1; j < si.Length; j++) {\n                    int p1 = int.Parse(si.Substring(j));\n                    int p2 = int.Parse(si.Substring(0, si.Length - j));\n                    if (!IsPrime(p1) ||!IsPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            string cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += i * j;\n                if (cprod.Length == 9) {\n                    string[] chars = cprod.Split(\"\");\n                    Array.Sort(chars);\n                    if (string.Join(\"\", chars) == \"123456789\") {\n                        result = Math.Max(result, int.Parse(cprod));\n                        break;\n                    }\n                } else if (cprod.Length > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int IntegerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol++;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int ChampernowneConstant(int b) {\n        string s = \"\";\n        for (int i = 1; i < (int)Math.Pow(b, 6); i++) {\n            s += i.ToString();\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            int n = int.Parse(s[(int)Math.Pow(b, i) - 1].ToString());\n            result *= n;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int PandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                int length = si.Length;\n                bool flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.Contains(j.ToString())) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int CodedTriangleNumbers(IList<string> words) {\n        int result = 0;\n        foreach (string word in words) {\n            int value = 0;\n            foreach (char c in word) {\n                value += int(c) - 64;\n            }\n            int n = (int)Math.Sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int SubStringDivisibility(int n) {\n        int result = 0;\n        IList<int> primes = new List<int> { 2, 3, 5, 7, 11, 13, 17 };\n        string s = \"\";\n        for (int i = 0; i <= n; i++) {\n            s += i.ToString();\n        }\n        foreach (string i in GenPermutations(s)) {\n            bool flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (int.Parse(i.Substring(j, 3)) % primes[j - 1]!= 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += int.Parse(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PentagonNumbers(int n) {\n        IDictionary<int, bool> pentagon = new Dictionary<int, bool>();\n        for (int i = 1; i < n; i++) {\n            pentagon[i * (3 * i - 1) / 2] = true;\n        }\n        int result = -1;\n        foreach (int j in pentagon.Keys) {\n            foreach (int k in pentagon.Keys) {\n                if (pentagon[j + k] && pentagon[k - j]) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int TriangularPentagonalAndHexagonal(int n) {\n        IDictionary<int, bool> ps = new Dictionary<int, bool>();\n        int i = 1;\n        int c = (int)(0.5 * (i * (3 * i - 1)));\n        while (c < n) {\n            i++;\n            ps[c] = true;\n            c = (int)(0.5 * (i * (3 * i - 1)));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i++;\n            if (ps[c]) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int GoldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i > n; i -= 2) {\n            int upper = (int)Math.Sqrt(i / 2);\n            bool flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (IsPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PrimeFactors(int n) {\n        int num = n;\n        IList<int> factors = new List<int>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i!= 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.Add(i);\n            }\n        }\n        if (num > 1) {\n            factors.Add(num);\n        }\n        IDictionary<int, bool> s = new Dictionary<int, bool>();\n        foreach (int v in factors) {\n            s[v] = true;\n        }\n        return s.Count;\n    }\n\n    public static int DistinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string SelfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        string result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += digits[i].ToString();\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static string PrimePermutations(int n) {\n        for (int i = n; i > 999; i--) {\n            if (IsPrime(i)) {\n                IList<string> permutations = GenPermutations(i.ToString());\n                IDictionary<int, bool> candidates = new Dictionary<int, bool>();\n                foreach (string j in permutations) {\n                    int candidate = int.Parse(j);\n                    if (candidate > i && IsPrime(candidate)) {\n                        candidates[candidate] = true;\n                    }\n                }\n                foreach (int m in candidates.Keys) {\n                    if (candidates[m + (m - i)]) {\n                        return i.ToString() + m.ToString() + (m + (m - i)).ToString();\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int ConsecutivePrimeSum(int limit) {\n        bool[] sieve = new bool[limit];\n        for (int i = 0; i < sieve.Length; i++) {\n            sieve[i] = true;\n        }\n        IList<int> primes = new List<int>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.Add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.Count; i++) {\n            for (int j = i + maxLength; j < primes.Count; j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes[k];\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
            ],
            "java": [
                "class Global {\n    public static int multiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int evenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i!= 0) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i)!= s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int largestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (isPalindrome(Integer.toString(prod)) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int smallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i!= 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int sumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int nthPrime(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (primes.size() < n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes.get(primes.size() - 1);\n    }\n}",
                "class Global {\n    public static int largestProductInASeries(String s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.length() - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= s.charAt(i + j) - '0';\n            }\n            result = Math.max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int specialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int summationOfPrimes(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (i <= n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        for (int prime : primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestProductInAGrid(List<List<Integer>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.size() - 3; i++) {\n            for (int j = 0; j < grid.get(i).size() - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid.get(i + k).get(j);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid.get(i).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid.get(i + k).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid.get(i + k).get(j + 3 - k);\n                }\n                result = Math.max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int highlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int) Math.sqrt(result); j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String largeSum(List<String> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            for (String num : numbers) {\n                tmp += num.charAt(49 - i) - '0';\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i]!= 0) {\n                String result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += digits[j];\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int longestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num!= 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int latticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int powerDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(2);\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                int temp = digits.get(j)*2 + carry;\n                digits.set(j, temp % 10);\n                carry = temp / 10;\n            }\n            if (carry!= 0) {\n                digits.add(carry);\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String numberToWords(int n) {\n        String[] ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        String[] teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        String[] tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            String suf = \"\";\n            if (n % 10!= 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int maximumPathSumI(List<List<Integer>> triangle) {\n        List<Integer> curr = new ArrayList<>(triangle.get(triangle.size() - 1));\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            List<Integer> next = new ArrayList<>(triangle.get(i));\n            for (int j = 0; j < next.size(); j++) {\n                next.set(j, next.get(j) + Math.max(curr.get(j), curr.get(j + 1)));\n            }\n            curr = next;\n        }\n        return curr.get(0);\n    }\n}",
                "class Global {\n    public static int countingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count++;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int factorialDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(1);\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                digits.set(j, digits.get(j) * i + carry);\n                carry = digits.get(j) / 10;\n                digits.set(j, digits.get(j) % 10);\n            }\n            while (carry!= 0) {\n                digits.add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int d(int n) {\n        int result = 1;\n        for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i!= n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int amicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = d(a);\n            if (a!= b && a == d(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int namesScores(List<String> names, List<String> queries) {\n        List<String> sNames = slices.Clone(names);\n        slices.Sort(sNames);\n        int result = 0;\n        for (int i = 0; i < sNames.size(); i++) {\n            int x = 0;\n            for (char c : sNames.get(i).toCharArray()) {\n                x += c - 64;\n            }\n            for (String query : queries) {\n                if (query.equals(sNames.get(i))) {\n                    result += x * (i + 1);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i!= n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int nonAbundantSums(int n) {\n        List<Integer> abundants = new ArrayList<>();\n        for (int i = 12; i < n; i++) {\n            if (isAbundant(i)) {\n                abundants.add(i);\n            }\n        }\n        Map<Integer, Boolean> abundantSums = new HashMap<>();\n        for (int i : abundants) {\n            for (int j : abundants) {\n                abundantSums.put(i + j, true);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.containsKey(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String lexicographicPermutations(int n) {\n        String result = \"\";\n        List<Integer> digits = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += digits.get(idx);\n            digits = digits.subList(0, idx) + digits.subList(idx + 1, digits.size());\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int nDigitFibonacciNumber(int n) {\n        int[] a = {1};\n        int[] b = {1};\n        int i = 2;\n        while (b.length < n) {\n            int carry = 0;\n            int[] c = new int[b.length];\n            System.arraycopy(b, 0, c, 0, b.length);\n            for (int j = 0; j < b.length; j++) {\n                if (j < a.length) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry!= 0) {\n                b = Arrays.copyOf(b, b.length + 1);\n                b[b.length - 1] = carry;\n            }\n            a = new int[c.length];\n            System.arraycopy(c, 0, a, 0, c.length);\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int reciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            List<Integer> remainders = new ArrayList<>();\n            int remainder = 1;\n            while (remainder!= 0 &&!remainders.contains(remainder)) {\n                remainders.add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder!= 0) {\n                length = remainders.size() - remainders.indexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int quadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!isPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x++;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int numberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int distinctPowers(int n) {\n        int result = 0;\n        Map<String, Boolean> xs = new HashMap<>();\n        for (int i = 2; i <= n; i++) {\n            int[] primes = {2, 3, 5, 7};\n            int[] powers = {0, 0, 0, 0};\n            int num = i;\n            for (int j = 0; j < primes.length; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num!= 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                String pstr = String.format(\"%d-%d-%d-%d\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n                xs.put(pstr, true);\n            }\n        }\n        result += xs.size();\n        return result;\n    }\n}",
                "class Global {\n    public static int digitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * (int) Math.pow(10, n); i++) {\n            int digitsSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                digitsSum += (int) Math.pow(Integer.parseInt(String.valueOf(digit)), n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int coinSums(int n) {\n        int[] coins = {1, 2, 5, 10, 20, 50, 100, 200};\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int pandigitalProducts(int n) {\n        Map<Integer, Boolean> products = new HashMap<>();\n        String s = \"\";\n        for (int i = 1; i <= n; i++) {\n            s += Integer.toString(i);\n        }\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                char[] chars = (Integer.toString(a) + Integer.toString(b) + Integer.toString(c)).toCharArray();\n                Arrays.sort(chars);\n                if (new String(chars).equals(s)) {\n                    products.put(c, true);\n                }\n            }\n        }\n        int result = 0;\n        for (Integer product : products.keySet()) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int digitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b!= 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int digitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                int fact = 1;\n                for (int j = 1; j <= digit - '0'; j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int circularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                Map<Integer, Void> rotations = new HashMap<>();\n                String str = Integer.toString(i);\n                for (int j = 0; j < str.length(); j++) {\n                    int x = Integer.parseInt(str.substring(j) + str.substring(0, j));\n                    rotations.put(x, null);\n                }\n                boolean flag = true;\n                for (int x : rotations.keySet()) {\n                    if (!isPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i)!= s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int doubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            String strI = Integer.toString(i);\n            String binI = Integer.toBinaryString(i);\n            if (isPalindrome(strI) && isPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int truncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (isPrime(i)) {\n                String si = Integer.toString(i);\n                boolean flag = true;\n                for (int j = 1; j < si.length(); j++) {\n                    int p1 = Integer.parseInt(si.substring(j));\n                    int p2 = Integer.parseInt(si.substring(0, si.length() - j));\n                    if (!isPrime(p1) ||!isPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            String cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += Integer.toString(i * j);\n                if (cprod.length() == 9) {\n                    String[] chars = cprod.split(\"\");\n                    Arrays.sort(chars);\n                    if (String.join(\"\", chars).equals(\"123456789\")) {\n                        result = Math.max(result, Integer.parseInt(cprod));\n                        break;\n                    }\n                } else if (cprod.length() > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int integerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol++;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int champernowneConstant(int b) {\n        String s = \"\";\n        for (int i = 1; i < (int) Math.pow(b, 6); i++) {\n            s += Integer.toString(i);\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            int n = Integer.parseInt(String.valueOf(s.charAt((int) Math.pow(b, i) - 1)));\n            result *= n;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int pandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (isPrime(i)) {\n                String si = Integer.toString(i);\n                int length = si.length();\n                boolean flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.contains(Integer.toString(j))) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int codedTriangleNumbers(List<String> words) {\n        int result = 0;\n        for (String word : words) {\n            int value = 0;\n            for (char c : word.toCharArray()) {\n                value += c - 'A' + 1;\n            }\n            int n = (int) Math.sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return Arrays.asList(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.charAt(0) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int subStringDivisibility(int n) {\n        int result = 0;\n        int[] primes = {2, 3, 5, 7, 11, 13, 17};\n        String s = \"\";\n        for (int i = 0; i <= n; i++) {\n            s += Integer.toString(i);\n        }\n        for (String i : genPermutations(s)) {\n            boolean flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (Integer.parseInt(i.substring(j, j + 3)) % primes[j - 1]!= 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += Integer.parseInt(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pentagonNumbers(int n) {\n        Map<Integer, Boolean> pentagon = new HashMap<>();\n        for (int i = 1; i < n; i++) {\n            pentagon.put(i * (3 * i - 1) / 2, true);\n        }\n        int result = -1;\n        for (int j : pentagon.keySet()) {\n            for (int k : pentagon.keySet()) {\n                if (pentagon.get(j + k) && pentagon.get(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int triangularPentagonalAndHexagonal(int n) {\n        Map<Integer, Boolean> ps = new HashMap<>();\n        int i = 1;\n        int c = (int) (0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i++;\n            ps.put(c, true);\n            c = (int) (0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i++;\n            if (ps.containsKey(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int goldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i > n; i -= 2) {\n            int upper = (int) Math.sqrt(i / 2);\n            boolean flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (isPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int primeFactors(int n) {\n        int num = n;\n        List<Integer> factors = new ArrayList<>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i!= 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.add(i);\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        Map<Integer, Boolean> s = new HashMap<>();\n        for (int v : factors) {\n            s.put(v, true);\n        }\n        return s.size();\n    }\n\n    public static int distinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String selfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        String result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += Integer.toString(digits[i]);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int) Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return Arrays.asList(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.charAt(0) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static String primePermutations(int n) {\n        for (int i = n; i > 999; i--) {\n            if (isPrime(i)) {\n                List<String> permutations = genPermutations(Integer.toString(i));\n                Map<Integer, Boolean> candidates = new HashMap<>();\n                for (String j : permutations) {\n                    int candidate = Integer.parseInt(j);\n                    if (candidate > i && isPrime(candidate)) {\n                        candidates.put(candidate, true);\n                    }\n                }\n                for (int m : candidates.keySet()) {\n                    if (candidates.get(m + (m - i))) {\n                        return Integer.toString(i) + Integer.toString(m) + Integer.toString(m + (m - i));\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int consecutivePrimeSum(int limit) {\n        boolean[] sieve = new boolean[limit];\n        for (int i = 0; i < limit; i++) {\n            sieve[i] = true;\n        }\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + maxLength; j < primes.size(); j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes.get(k);\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
            ],
            "javascript": [
                "const multiplesOf3And5 = (n) => {\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const evenFibonacciNumbers = (n) => {\n    let result = 0;\n    let a = 1;\n    let b = 2;\n    while (a < n) {\n        if (a % 2 === 0) {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "const largestPrimeFactor = (n) => {\n    let result = n;\n    let i = 2;\n    while (i * i <= result) {\n        if (result % i!== 0) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i]!== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst largestPalindromeProduct = (n) => {\n    let result = 0;\n    for (let i = 100; i < 1000; i++) {\n        for (let j = i; j < 1000; j++) {\n            let prod = i * j;\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "const smallestMultiple = (n) => {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        if (result % i!== 0) {\n            for (let j = 1; j <= n; j++) {\n                if ((result * j) % i === 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const sumSquareDifference = (n) => {\n    let sqrSum = 0;\n    let numSum = 0;\n    for (let i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "const nthPrime = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (primes.length < n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.length - 1];\n}",
                "const largestProductInASeries = (s, k) => {\n    let result = 0;\n    for (let i = 0; i < s.length - k; i++) {\n        let product = 1;\n        for (let j = 0; j < k; j++) {\n            product *= parseInt(s[i + j])\n        }\n        result = Math.max(result, product);\n    }\n    return result;\n}",
                "const specialPythagoreanTriplet = (n) => {\n    for (let a = 1; a < n; a++) {\n        for (let b = a; b < n; b++) {\n            let c = n - a - b;\n            if (a * a + b * b === c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "const summationOfPrimes = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (i <= n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let result = 0;\n    for (let prime of primes) {\n        result += prime;\n    }\n    return result;\n}",
                "const largestProductInAGrid = (grid) => {\n    let result = 0;\n    for (let i = 0; i < grid.length - 3; i++) {\n        for (let j = 0; j < grid[i].length - 3; j++) {\n            let p1 = 1;\n            let p2 = 1;\n            let p3 = 1;\n            let p4 = 1;\n            for (let k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (let k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = Math.max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "const highlyDivisibleTriangularNumber = (n) => {\n    for (let i = 1; i < 100000000; i++) {\n        let result = i * (i + 1) / 2;\n        let count = 0;\n        for (let j = 1; j <= Math.sqrt(result); j++) {\n            if (result % j === 0) {\n                count += 2;\n            }\n            if (j * j === result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "const largeSum = (numbers) => {\n    let digits = new Array(60).fill(0);\n    for (let i = 0; i < 50; i++) {\n        let tmp = 0;\n        for (let num of numbers) {\n            tmp += parseInt(num[49 - i]);\n        }\n        for (let j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if (tmp === 0) {\n                break;\n            }\n        }\n    }\n    for (let i = 59; i >= 0; i--) {\n        if (digits[i]!== 0) {\n            let result = \"\";\n            for (let j = i; j > i - 10; j--) {\n                result += digits[j].toString();\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
                "const longestCollatzSequence = (n) => {\n    let longest = 0;\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let chain = 1;\n        let num = i;\n        while (num!== 1) {\n            if (num % 2 === 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const latticePaths = (m, n) => {\n    let grid = [];\n    for (let i = 0; i <= m; i++) {\n        grid[i] = [];\n        grid[i][0] = 1;\n    }\n    for (let j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "const powerDigitSum = (n) => {\n    let digits = [2];\n    for (let i = 1; i < n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            let temp = digits[j]*2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry!== 0) {\n            digits.push(carry);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const numberToWords = (n) => {\n    const ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    const teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    const tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if (n === 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 === 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        let suf = \"\";\n        if (n % 10!== 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "const maximumPathSumI = (triangle) => {\n    let curr = triangle[triangle.length - 1].slice();\n    for (let i = triangle.length - 2; i >= 0; i--) {\n        let next = triangle[i].slice();\n        for (let j = 0; j < next.length; j++) {\n            next[j] += Math.max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "const countingSundays = (y1, y2) => {\n    let day = 0;\n    let count = 0;\n    for (let year = 1900; year <= y2; year++) {\n        for (let month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 === 6) {\n                count++;\n            }\n            if (month === 4 || month === 6 || month === 9 || month === 11) {\n                day += 30;\n            } else if (month === 2) {\n                if (year % 4 === 0 && (year % 100!== 0 || year % 400 === 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "const factorialDigitSum = (n) => {\n    let digits = [1];\n    for (let i = 1; i <= n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = Math.floor(digits[j] / 10);\n            digits[j] %= 10;\n        }\n        while (carry!= 0) {\n            digits.push(carry % 10);\n            carry = Math.floor(carry / 10);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const d = (n) => {\n    let result = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            result += i;\n            if (i!== n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nconst amicableNumbers = (n) => {\n    let result = 0;\n    for (let a = 2; a < n; a++) {\n        let b = d(a);\n        if (a!== b && a === d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "const namesScores = (names, queries) => {\n    let sNames = slices.Clone(names);\n    slices.Sort(sNames);\n    let result = 0;\n    for (let i = 0; i < sNames.length; i++) {\n        let x = 0;\n        for (let c of sNames[i]) {\n            x += c.charCodeAt(0) - 64;\n        }\n        for (let query of queries) {\n            if (query === sNames[i]) {\n                result += x * (i + 1);\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "const isAbundant = (n) => {\n    if (n < 12) {\n        return false;\n    }\n    let sumDivisors = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            sumDivisors += i;\n            if (i!== n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nconst nonAbundantSums = (n) => {\n    let abundants = [];\n    for (let i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push(i);\n        }\n    }\n    let abundantSums = {};\n    for (let i of abundants) {\n        for (let j of abundants) {\n            abundantSums[i + j] = true;\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!abundantSums[i]) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const lexicographicPermutations = (n) => {\n    let result = \"\";\n    let digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let x = n - 1;\n    for (let i = 10; i > 0; i--) {\n        let fact = 1;\n        for (let j = 1; j < i; j++) {\n            fact *= j;\n        }\n        let idx = Math.floor(x / fact);\n        result += digits[idx];\n        digits = digits.slice(0, idx).concat(digits.slice(idx + 1));\n        x -= idx * fact;\n    }\n    return result;\n}",
                "const nDigitFibonacciNumber = (n) => {\n    let a = [1];\n    let b = [1];\n    let i = 2;\n    while (b.length < n) {\n        let carry = 0;\n        let c = [...b];\n        for (let j = 0; j < b.length; j++) {\n            if (j < a.length) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry!== 0) {\n            b.push(carry);\n        }\n        a = [...c];\n        i = i + 1;\n    }\n    return i;\n}",
                "const reciprocalCycles = (n) => {\n    let result = 0;\n    let maxLength = 0;\n    for (let i = 1; i < n; i++) {\n        let remainders = [];\n        let remainder = 1;\n        while (remainder!== 0 &&!remainders.includes(remainder)) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = 0;\n        if (remainder!== 0) {\n            length = remainders.length - remainders.indexOf(remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst quadraticPrimes = (n) => {\n    let maxPrimes = 0;\n    let result = 0;\n    for (let a = -n + 1; a < n; a += 2) {\n        for (let b = -n + 1; b < n; b += 2) {\n            let x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "const numberSpiralDiagonals = (n) => {\n    let result = 1;\n    for (let i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "const distinctPowers = (n) => {\n    let result = 0;\n    let xs = new Map();\n    for (let i = 2; i <= n; i++) {\n        let primes = [2, 3, 5, 7];\n        let powers = [0, 0, 0, 0];\n        let num = i;\n        for (let j = 0; j < primes.length; j++) {\n            while (num % primes[j] === 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num!== 1) {\n            result += n - 1;\n            continue;\n        }\n        for (let j = 2; j <= n; j++) {\n            let pstr = `${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}`;\n            xs.set(pstr, true);\n        }\n    }\n    result += xs.size;\n    return result;\n}",
                "const digitNthPowers = (n) => {\n    let result = 0;\n    for (let i = 2; i < 4 * Math.pow(10, n); i++) {\n        let digitsSum = 0;\n        for (let digit of i.toString()) {\n            digitsSum += Math.pow(parseInt(digit), n);\n        }\n        if (i === digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const coinSums = (n) => {\n    const coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    const ways = Array(n + 1).fill(0);\n    ways[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "const pandigitalProducts = (n) => {\n    let products = {};\n    let s = \"\";\n    for (let i = 1; i <= n; i++) {\n        s += i;\n    }\n    for (let a = 1; a < 100; a++) {\n        for (let b = 1; b < 10000; b++) {\n            let c = a * b;\n            let chars = s.split(\"\").map(c => c.charCodeAt(0));\n            chars.sort((a, b) => a - b);\n            if (chars.join(\"\") === s) {\n                products[c] = true;\n            }\n        }\n    }\n    let result = 0;\n    for (let product of Object.keys(products)) {\n        result += parseInt(product);\n    }\n    return result;\n}",
                "const digitCancelingFractions = (m) => {\n    let numer = 1;\n    let denom = 1;\n    for (let d = 10; d < m; d++) {\n        for (let n = 10; n < d; n++) {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let a = numer;\n    let b = denom;\n    while (b!= 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return denom / a;\n}",
                "const digitFactorials = (n) => {\n    let result = 0;\n    for (let i = 3; i < n; i++) {\n        let factSum = 0;\n        for (let digit of parseInt(i).toString()) {\n            let fact = 1;\n            for (let j = 1; j <= parseInt(digit); j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i === factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst circularPrimes = (n) => {\n    let count = 0;\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            let rotations = {};\n            let str = i.toString();\n            for (let j = 0; j < str.length; j++) {\n                let x = parseInt(str.substring(j) + str.substring(0, j));\n                rotations[x] = true;\n            }\n            let flag = true;\n            for (let x in rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i]!== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst doubleBasePalindromes = (n) => {\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let strI = i.toString();\n        let binI = i.toString(2);\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst truncatablePrimes = (n) => {\n    let result = 0;\n    for (let i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            let si = i.toString();\n            let flag = true;\n            for (let j = 1; j < si.length; j++) {\n                let p1 = parseInt(si.substring(j));\n                let p2 = parseInt(si.substring(0, si.length - j));\n                if (!isPrime(p1) ||!isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "const pandigitalMultiples = (n) => {\n    let result = -1;\n    for (let i = 2; i <= n; i++) {\n        let cprod = \"\";\n        for (let j = 1; j < 10; j++) {\n            cprod += i * j;\n            if (cprod.length === 9) {\n                let chars = cprod.split(\"\");\n                chars.sort();\n                if (chars.join(\"\") === \"123456789\") {\n                    cprodInt = parseInt(cprod);\n                    result = Math.max(result, cprodInt);\n                    break;\n                }\n            } else if (cprod.length > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "const integerRightTriangles = (n) => {\n    let maxSol = 0;\n    let result = 0;\n    for (let p = 3; p <= n; p++) {\n        let sol = 0;\n        for (let a = 1; a < p / 2; a++) {\n            for (let b = a; b < p / 2; b++) {\n                let c = p - a - b;\n                if (a * a + b * b === c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "const champernowneConstant = (b) => {\n    let s = \"\";\n    for (let i = 1; i < Math.pow(b, 6); i++) {\n        s += i;\n    }\n    let result = 1;\n    for (let i = 0; i < 7; i++) {\n        let n = parseInt(s[Math.pow(b, i) - 1]);\n        result *= n;\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst pandigitalPrime = (n) => {\n    for (let i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            let si = i.toString();\n            let length = si.length;\n            let flag = true;\n            for (let j = 1; j <= length; j++) {\n                if (!si.includes(j.toString())) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "const codedTriangleNumbers = (words) => {\n    let result = 0;\n    for (let word of words) {\n        let value = 0;\n        for (let c of word) {\n            value += c.charCodeAt(0) - 64;\n        }\n        let n = Math.floor(Math.sqrt(value * 2));\n        if (n * (n + 1) === value * 2) {\n            result++;\n        }\n    }\n    return result;\n}",
                "const genPermutations = (s) => {\n    if (s.length <= 1) {\n        return [s];\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s[0] + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst subStringDivisibility = (n) => {\n    let result = 0;\n    let primes = [2, 3, 5, 7, 11, 13, 17];\n    let s = \"\";\n    for (let i = 0; i <= n; i++) {\n        s += i;\n    }\n    for (let i of genPermutations(s)) {\n        let flag = true;\n        for (let j = 1; j < n - 1; j++) {\n            if (parseInt(i.substring(j, j + 3)) % primes[j - 1]!== 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += parseInt(i);\n        }\n    }\n    return result;\n}",
                "const pentagonNumbers = (n) => {\n    let pentagon = {};\n    for (let i = 1; i < n; i++) {\n        pentagon[i * (3 * i - 1) / 2] = true;\n    }\n    let result = -1;\n    for (let j in pentagon) {\n        for (let k in pentagon) {\n            if (pentagon[j + k] && pentagon[k - j]) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const triangularPentagonalAndHexagonal = (n) => {\n    let ps = new Map();\n    let i = 1;\n    let c = Math.floor(0.5 * i * (3 * i - 1));\n    while (c < n) {\n        i++;\n        ps.set(c, true);\n        c = Math.floor(0.5 * i * (3 * i - 1));\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let result = -1;\n    while (c < n) {\n        i++;\n        if (ps.has(c)) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst goldbachsOtherConjecture = (n) => {\n    let result = -1;\n    for (let i = 9999; i > n; i -= 2) {\n        let upper = Math.sqrt(i / 2);\n        let flag = false;\n        for (let j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "const primeFactors = (n) => {\n    let num = n;\n    let factors = [];\n    let i = 2;\n    while (i * i <= num) {\n        if (num % i!== 0) {\n            i++;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if (num > 1) {\n        factors.push(num);\n    }\n    let s = new Map();\n    for (let v of factors) {\n        s.set(v, true);\n    }\n    return s.size;\n}\n\nconst distinctPrimesFactors = (n) => {\n    for (let i = n; i < 1000000; i++) {\n        if (primeFactors(i) === 4 && primeFactors(i + 1) === 4 && primeFactors(i + 2) === 4 && primeFactors(i + 3) === 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "const selfPowers = (n) => {\n    let digits = [10];\n    for (let i = 1; i <= n; i++) {\n        let tempDigits = [10];\n        tempDigits[0] = 1;\n        for (let j = 0; j < i; j++) {\n            let carry = 0;\n            for (let k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = tempDigits[k] / 10;\n                tempDigits[k] %= 10;\n            }\n        }\n        for (let j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let result = \"\";\n    for (let i = 9; i >= 0; i--) {\n        result += digits[i].toString();\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst genPermutations = (s) => {\n    if (s.length <= 1) {\n        return [s];\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s[0] + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst primePermutations = (n) => {\n    for (let i = n; i > 999; i--) {\n        if (isPrime(i)) {\n            let permutations = genPermutations(i.toString());\n            let candidates = {};\n            for (let j of permutations) {\n                let candidate = parseInt(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates[candidate] = true;\n                }\n            }\n            for (let m in candidates) {\n                if (candidates[m + (m - i)]) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString();\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "const consecutivePrimeSum = (limit) => {\n    let sieve = new Array(limit).fill(true);\n    let primes = [];\n    for (let i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push(i);\n            for (let j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    let maxLength = 0;\n    let maxPrime = 0;\n    for (let i = 0; i < primes.length; i++) {\n        for (let j = i + maxLength; j < primes.length; j++) {\n            let s = 0;\n            for (let k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
            ],
            "kotlin": [
                "fun multiplesOf3And5(n: Int): Int {\n    var result = 0\n    for (i in 0 until n) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun evenFibonacciNumbers(n: Int): Int {\n    var result = 0\n    var a = 1\n    var b = 2\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a\n        }\n        val tmp = a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
                "fun largestPrimeFactor(n: Int): Int {\n    var result = n\n    var i = 2\n    while (i * i <= result) {\n        if (result % i!= 0) {\n            i++\n        } else {\n            result /= i\n        }\n    }\n    return result\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i]!= s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun largestPalindromeProduct(n: Int): Int {\n    var result = 0\n    for (i in 100..1000) {\n        for (j in i..1000) {\n            val prod = i * j\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
                "fun smallestMultiple(n: Int): Int {\n    var result = 1\n    for (i in 1..n) {\n        if (result % i!= 0) {\n            for (j in 1..n) {\n                if (result * j % i == 0) {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun sumSquareDifference(n: Int): Int {\n    var sqrSum = 0\n    var numSum = 0\n    for (i in 1..n) {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
                "fun nthPrime(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (primes.size < n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes[primes.size - 1]\n}",
                "fun largestProductInASeries(s: String, k: Int): Int {\n    var result = 0\n    for (i in 0 until s.length - k) {\n        var product = 1\n        for (j in 0 until k) {\n            product *= s[i + j].toString().toInt()\n        }\n        result = max(result, product)\n    }\n    return result\n}",
                "fun specialPythagoreanTriplet(n: Int): Int {\n    for (a in 1 until n) {\n        for (b in a until n) {\n            val c = n - a - b\n            if a * a + b * b == c * c {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
                "fun summationOfPrimes(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (i <= n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if p * p > i {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    var result = 0\n    for (prime in primes) {\n        result += prime\n    }\n    return result\n}",
                "fun largestProductInAGrid(grid: List<List<Int>>): Int {\n    var result = 0\n    for (i in 0 until grid.size - 3) {\n        for (j in 0 until grid[i].size - 3) {\n            val p1 = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]\n            val p2 = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]\n            val p3 = grid[i][j] * grid[i + 1][j + 1] * grid[i + 2][j + 2] * grid[i + 3][j + 3]\n            val p4 = grid[i][j] * grid[i + 1][j + 2] * grid[i + 2][j + 1] * grid[i + 3][j]\n            result = max(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
                "fun highlyDivisibleTriangularNumber(n: Int): Int {\n    for (i in 1..100000000) {\n        val result = i * (i + 1) / 2\n        var count = 0\n        for (j in 1..sqrt(result.toDouble()).toInt()) {\n            if result % j == 0 {\n                count += 2\n            }\n            if j * j == result {\n                count -= 1\n            }\n        }\n        if count > n {\n            return result\n        }\n    }\n    return -1\n}",
                "fun largeSum(numbers: List<String>): String {\n    val digits = IntArray(60)\n    for (i in 0 until 50) {\n        var tmp = 0\n        for (num in numbers) {\n            tmp += num[49 - i].toInt() - '0'.toInt()\n        }\n        for (j in i until 60) {\n            digits[j] += tmp % 10\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if tmp == 0 {\n                break\n            }\n        }\n    }\n    for (i in 59 downTo 0) {\n        if digits[i]!= 0 {\n            var result = \"\"\n            for (j in i downTo i - 10 + 1) {\n                result += digits[j].toString()\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
                "fun longestCollatzSequence(n: Int): Int {\n    var longest = 0\n    var result = 0\n    for (i in 1 until n) {\n        var chain = 1\n        var num = i\n        while (num!= 1) {\n            if (num % 2 == 0) {\n                num /= 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain++\n        }\n        if (chain > longest) {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
                "fun latticePaths(m: Int, n: Int): Int {\n    val grid = Array(m + 1) { IntArray(n + 1) }\n    for (i in 0..m) {\n        grid[i][0] = 1\n    }\n    for (j in 0..n) {\n        grid[0][j] = 1\n    }\n    for (i in 1..m) {\n        for (j in 1..n) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
                "fun powerDigitSum(n: Int): Int {\n    var digits = listOf(2)\n    for (i in 1 until n) {\n        var carry = 0\n        for (j in digits.indices) {\n            val temp = digits[j] * 2 + carry\n            digits = digits.toMutableList().apply {\n                this[j] = temp % 10\n                carry = temp / 10\n            }\n        }\n        if (carry!= 0) {\n            digits = digits.toMutableList().apply {\n                this.add(carry)\n            }\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun numberToWords(n: Int): String {\n    val ones = arrayOf(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val teens = arrayOf(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n    val tens = arrayOf(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n    return when {\n        n == 1000 -> \"one thousand\"\n        n >= 100 -> {\n            val hundreds = ones[n / 100] + \" hundred\"\n            if (n % 100 == 0) {\n                hundreds\n            } else {\n                hundreds + \" and \" + numberToWords(n % 100)\n            }\n        }\n        n >= 20 -> tens[n / 10] + if (n % 10!= 0) \" \" + ones[n % 10] else \"\"\n        n >= 10 -> teens[n - 10]\n        else -> ones[n]\n    }\n}",
                "fun maximumPathSumI(triangle: List<List<Int>>): Int {\n    val curr = triangle[triangle.size - 1].toMutableList()\n    for (i in triangle.size - 2 downTo 0) {\n        val next = triangle[i].toMutableList()\n        for (j in 0 until next.size) {\n            next[j] += max(curr[j], curr[j + 1])\n        }\n        curr = next\n    }\n    return curr[0]\n}",
                "fun countingSundays(y1: Int, y2: Int): Int {\n    var day = 0\n    var count = 0\n    for (year in 1900..y2) {\n        for (month in 1..12) {\n            if (year >= y1 && day % 7 == 6) {\n                count++\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
                "fun factorialDigitSum(n: Int): Int {\n    var digits = listOf(1)\n    for (i in 1..n) {\n        var carry = 0\n        for (j in digits.indices) {\n            digits = digits.toMutableList().apply {\n                this[j] = this[j] * i + carry\n                carry = this[j] / 10\n                this[j] %= 10\n            }\n        }\n        while (carry!= 0) {\n            digits = digits.toMutableList().apply {\n                this.add(carry % 10)\n                carry /= 10\n            }\n        }\n    }\n    return digits.sum()\n}",
                "fun d(n: Int): Int {\n    var result = 1\n    for (i in 2..sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            result += i\n            if (i!= n / i) {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfun amicableNumbers(n: Int): Int {\n    var result = 0\n    for (a in 2 until n) {\n        val b = d(a)\n        if (a!= b && a == d(b)) {\n            result += a\n        }\n    }\n    return result\n}",
                "fun namesScores(names: List<String>, queries: List<String>): Int {\n    val sNames = names.toMutableList()\n    sNames.sort()\n    var result = 0\n    for (i in sNames.indices) {\n        var x = 0\n        for (c in sNames[i]) {\n            x += c - 'A' + 1\n        }\n        for (query in queries) {\n            if (query == sNames[i]) {\n                result += x * (i + 1)\n                break\n            }\n        }\n    }\n    return result\n}",
                "fun isAbundant(n: Int): Boolean {\n    if (n < 12) {\n        return false\n    }\n    var sumDivisors = 1\n    for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            sumDivisors += i\n            if (i!= n / i) {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfun nonAbundantSums(n: Int): Int {\n    val abundants = mutableListOf<Int>()\n    for (i in 12 until n) {\n        if (isAbundant(i)) {\n            abundants.add(i)\n        }\n    }\n    val abundantSums = mutableMapOf<Int, Boolean>()\n    for (i in abundants) {\n        for (j in abundants) {\n            abundantSums[i + j] = true\n        }\n    }\n    var result = 0\n    for (i in 0 until n) {\n        if (!abundantSums[i]) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun lexicographicPermutations(n: Int): String {\n    val result = StringBuilder()\n    val digits = listOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n    var x = n - 1\n    for (i in 10 downTo 1) {\n        var fact = 1\n        for (j in 1 until i) {\n            fact *= j\n        }\n        val idx = x / fact\n        result.append(digits[idx])\n        digits.removeAt(idx)\n        x -= idx * fact\n    }\n    return result.toString()\n}",
                "fun nDigitFibonacciNumber(n: Int): Int {\n    var a = listOf(1)\n    var b = listOf(1)\n    var i = 2\n    while (b.size < n) {\n        var carry = 0\n        val c = b.toMutableList()\n        for (j in 0 until b.size) {\n            if (j < a.size) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if (carry!= 0) {\n            b.add(carry)\n        }\n        a = c.toMutableList()\n        i++\n    }\n    return i\n}",
                "fun reciprocalCycles(n: Int): Int {\n    var result = 0\n    var maxLength = 0\n    for (i in 1 until n) {\n        val remainders = mutableListOf<Int>()\n        var remainder = 1\n        while (remainder!= 0 &&!remainders.contains(remainder)) {\n            remainders.add(remainder)\n            remainder = (remainder * 10) % i\n        }\n        val length = if (remainder!= 0) remainders.size - remainders.indexOf(remainder) else 0\n        if (length > maxLength) {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun quadraticPrimes(n: Int): Int {\n    var maxPrimes = 0\n    var result = 0\n    for (a in -n + 1..n step 2) {\n        for (b in -n + 1..n step 2) {\n            var x = 0\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break\n                }\n                x++\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
                "fun numberSpiralDiagonals(n: Int): Int {\n    var result = 1\n    for (i in 3 until n step 2) {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
                "fun distinctPowers(n: Int): Int {\n    var result = 0\n    val xs = mutableMapOf<String, Boolean>()\n    for (i in 2..n) {\n        val primes = listOf(2, 3, 5, 7)\n        val powers = listOf(0, 0, 0, 0)\n        var num = i\n        for (j in 0 until primes.size) {\n            while (num % primes[j] == 0) {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if (num!= 1) {\n            result += n - 1\n            continue\n        }\n        for (j in 2..n) {\n            val pstr = \"${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}\"\n            xs[pstr] = true\n        }\n    }\n    result += xs.size\n    return result\n}",
                "fun digitNthPowers(n: Int): Int {\n    var result = 0\n    for (i in 2..4 * 10.0.pow(n).toInt()) {\n        var digitsSum = 0\n        for (digit in i.toString()) {\n            digitsSum += digit.toInt().toDouble().pow(n).toInt()\n        }\n        if (i == digitsSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun coinSums(n: Int): Int {\n    val coins = listOf(1, 2, 5, 10, 20, 50, 100, 200)\n    val ways = IntArray(n + 1)\n    ways[0] = 1\n    for (coin in coins) {\n        for (i in coin until n + 1) {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
                "fun pandigitalProducts(n: Int): Int {\n    val products = mutableMapOf<Int, Boolean>()\n    val s = (1..n).joinToString(\"\")\n    for (a in 1..99) {\n        for (b in 1..9999) {\n            val c = a * b\n            val chars = chars(a, b, c)\n            if chars == s {\n                products[c] = true\n            }\n        }\n    }\n    var result = 0\n    for (product in products) {\n        result += product\n    }\n    return result\n}\n\nfun chars(a: Int, b: Int, c: Int): String {\n    return chars(a).chars(b).chars(c)\n}\n\nfun chars(a: Int, b: Int): String {\n    return chars(a).chars(b)\n}\n\nfun chars(a: Int): String {\n    return chars(a).chars()\n}\n\nfun chars(a: Int): CharArray {\n    return a.toString().toCharArray()\n}",
                "fun digitCancelingFractions(m: Int): Int {\n    var numer = 1\n    var denom = 1\n    for (d in 10 until m) {\n        for (n in 10 until d) {\n            val n0 = n % 10\n            val n1 = n / 10\n            val d0 = d % 10\n            val d1 = d / 10\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    var a = numer\n    var b = denom\n    while (b!= 0) {\n        val temp = b\n        b = a % b\n        a = temp\n    }\n    return denom / a\n}",
                "fun digitFactorials(n: Int): Int {\n    var result = 0\n    for (i in 3 until n) {\n        var factSum = 0\n        for (digit in i.toString()) {\n            var fact = 1\n            for (j in 1..(digit - '0').toInt()) {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if (i == factSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun circularPrimes(n: Int): Int {\n    var count = 0\n    for (i in 2 until n) {\n        if (isPrime(i)) {\n            val rotations = mutableMapOf<Int, Unit>()\n            val str = i.toString()\n            for (j in 0 until str.length) {\n                val x = str.substring(j) + str.substring(0, j)\n                rotations[x.toInt()] = Unit\n            }\n            var flag = true\n            for (x in rotations.keys) {\n                if (!isPrime(x)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                count++\n            }\n        }\n    }\n    return count\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i]!= s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun doubleBasePalindromes(n: Int): Int {\n    var result = 0\n    for (i in 1 until n) {\n        val strI = i.toString()\n        val binI = i.toString(2)\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun truncatablePrimes(n: Int): Int {\n    var result = 0\n    for (i in 10 until n) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            var flag = true\n            for (j in 1 until si.length) {\n                val p1 = si.substring(j).toInt()\n                val p2 = si.substring(0, si.length - j).toInt()\n                if (!isPrime(p1) ||!isPrime(p2)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                result += i\n            }\n        }\n    }\n    return result\n}",
                "fun pandigitalMultiples(n: Int): Int {\n    var result = -1\n    for (i in 2..n) {\n        var cprod = \"\"\n        for (j in 1..9) {\n            cprod += (i * j).toString()\n            if (cprod.length == 9) {\n                val chars = cprod.split(\"\")\n                chars.sort()\n                if (chars.joinToString(\"\") == \"123456789\") {\n                    result = max(result, cprod.toInt())\n                    break\n                }\n            } else if (cprod.length > 9) {\n                break\n            }\n        }\n    }\n    return result\n}",
                "fun integerRightTriangles(n: Int): Int {\n    var maxSol = 0\n    var result = 0\n    for (p in 3..n) {\n        var sol = 0\n        for (a in 1 until p / 2) {\n            for (b in a until p / 2) {\n                val c = p - a - b\n                if a * a + b * b == c * c {\n                    sol++\n                }\n            }\n        }\n        if sol > maxSol {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
                "fun champernowneConstant(b: Int): Int {\n    var s = \"\"\n    for (i in 1 until Math.pow(b.toDouble(), 6).toInt()) {\n        s += i.toString()\n    }\n    var result = 1\n    for (i in 0 until 7) {\n        result *= s[Math.pow(b.toDouble(), i.toDouble()).toInt() - 1].toString().toInt()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun pandigitalPrime(n: Int): Int {\n    for (i in n downTo 1) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            val length = si.length\n            var flag = true\n            for (j in 1..length) {\n                if (!si.contains(j.toString())) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                return i\n            }\n        }\n    }\n    return -1\n}",
                "fun codedTriangleNumbers(words: List<String>): Int {\n    var result = 0\n    for (word in words) {\n        var value = 0\n        for (c in word) {\n            value += c.toInt() - 64\n        }\n        val n = kotlin.math.sqrt(value * 2.0).toInt()\n        if (n * (n + 1) == value * 2) {\n            result++\n        }\n    }\n    return result\n}",
                "fun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun subStringDivisibility(n: Int): Int {\n    var result = 0\n    val primes = listOf(2, 3, 5, 7, 11, 13, 17)\n    var s = \"\"\n    for (i in 0..n) {\n        s += i.toString()\n    }\n    for (i in genPermutations(s)) {\n        var flag = true\n        for (j in 1 until n - 1) {\n            if (n, _) in i.substring(j, j + 3).toInt() % primes[j - 1]!= 0) {\n                flag = false\n                break\n            }\n        }\n        if (flag) {\n            result += i.toInt()\n        }\n    }\n    return result\n}",
                "fun pentagonNumbers(n: Int): Int {\n    val pentagon = mutableMapOf<Int, Boolean>()\n    for (i in 1 until n) {\n        pentagon[i * (3 * i - 1) / 2] = true\n    }\n    var result = -1\n    for (j in pentagon.keys) {\n        for (k in pentagon.keys) {\n            if pentagon[j + k] == true && pentagon[k - j] == true {\n                if result == -1 || k - j < result {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun triangularPentagonalAndHexagonal(n: Int): Int {\n    val ps = mutableMapOf<Int, Boolean>()\n    var i = 1\n    var c = (i * (3 * i - 1)) / 2\n    while (c < n) {\n        i++\n        ps[c] = true\n        c = (i * (3 * i - 1)) / 2\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    var result = -1\n    while (c < n) {\n        i++\n        if (ps[c]) {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..(n / 2).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun goldbachsOtherConjecture(n: Int): Int {\n    var result = -1\n    for (i in 9999 downTo n step 2) {\n        val upper = (i / 2).toInt()\n        var flag = false\n        for (j in 0..upper) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true\n                break\n            }\n        }\n        if (!flag) {\n            result = i\n        }\n    }\n    return result\n}",
                "fun primeFactors(n: Int): Int {\n    var num = n\n    val factors = mutableListOf<Int>()\n    var i = 2\n    while (i * i <= num) {\n        if (num % i!= 0) {\n            i++\n        } else {\n            num /= i\n            factors.add(i)\n        }\n    }\n    if (num > 1) {\n        factors.add(num)\n    }\n    val s = mutableMapOf<Int, Boolean>()\n    for (v in factors) {\n        s[v] = true\n    }\n    return s.size\n}\n\nfun distinctPrimesFactors(n: Int): Int {\n    for (i in n until 1000000) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i\n        }\n    }\n    return -1\n}",
                "fun selfPowers(n: Int): String {\n    val digits = IntArray(10)\n    for (i in 1..n) {\n        val tempDigits = IntArray(10)\n        tempDigits[0] = 1\n        for (j in 0 until i) {\n            var carry = 0\n            for (k in 0 until 10) {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for (j in 0 until 10) {\n            digits[j] += tempDigits[j]\n            if digits[j] >= 10 {\n                digits[j] -= 10\n                if j < 9 {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    var result = \"\"\n    for (i in 9 downTo 0) {\n        result += digits[i].toString()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..Math.sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun primePermutations(n: Int): String {\n    for (i in n downTo 999) {\n        if (isPrime(i)) {\n            val permutations = genPermutations(i.toString())\n            val candidates = mutableMapOf<Int, Boolean>()\n            for (j in permutations) {\n                val candidate = j.toInt()\n                if (candidate > i && isPrime(candidate)) {\n                    candidates[candidate] = true\n                }\n            }\n            for (m in candidates.keys) {\n                if (candidates[m + (m - i)] == true) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString()\n                }\n            }\n        }\n    }\n    return \"\"\n}",
                "fun consecutivePrimeSum(limit: Int): Int {\n    val sieve = BooleanArray(limit) { true }\n    val primes = mutableListOf<Int>()\n    for (i in 2 until limit) {\n        if (sieve[i]) {\n            primes.add(i)\n            for (j in i * 2 until limit step i) {\n                sieve[j] = false\n            }\n        }\n    }\n    var maxLength = 0\n    var maxPrime = 0\n    for (i in 0 until primes.size) {\n        for (j in i + maxLength until primes.size) {\n            var s = 0\n            for (k in i until j) {\n                s += primes[k]\n            }\n            if (s >= limit) {\n                break\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
            ],
            "php": [
                "function multiplesOf3And5($n) {\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 3 === 0 || $i % 5 === 0) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function evenFibonacciNumbers($n) {\n    $result = 0;\n    $a = 1;\n    $b = 2;\n    while ($a < $n) {\n        if ($a % 2 === 0) {\n            $result += $a;\n        }\n        $tmp = $a;\n        $a = $b;\n        $b = $tmp + $b;\n    }\n    return $result;\n}",
                "function largestPrimeFactor($n) {\n    $result = $n;\n    $i = 2;\n    while ($i * $i <= $result) {\n        if ($result % $i!== 0) {\n            $i += 1;\n        } else {\n            $result /= $i;\n        }\n    }\n    return $result;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i]!== $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction largestPalindromeProduct($n) {\n    $result = 0;\n    for ($i = 100; $i < 1000; $i++) {\n        for ($j = $i; $j < 1000; $j++) {\n            $prod = $i * $j;\n            if (isPalindrome(strval($prod)) && $prod > $result && $prod < $n) {\n                $result = $prod;\n            }\n        }\n    }\n    return $result;\n}",
                "function smallestMultiple($n) {\n    $result = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($result % $i!== 0) {\n            for ($j = 1; $j <= $n; $j++) {\n                if (($result * $j) % $i === 0) {\n                    $result *= $j;\n                    break;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function sumSquareDifference($n) {\n    $sqrSum = 0;\n    $numSum = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $sqrSum += $i * $i;\n        $numSum += $i;\n    }\n    return $numSum * $numSum - $sqrSum;\n}",
                "function nthPrime($n) {\n    $primes = [2];\n    $i = 3;\n    while (count($primes) < $n) {\n        foreach ($primes as $p) {\n            if ($i % $p === 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    return $primes[count($primes) - 1];\n}",
                "function largestProductInASeries($s, $k) {\n    $result = 0;\n    for ($i = 0; $i < strlen($s) - $k; $i++) {\n        $product = 1;\n        for ($j = 0; $j < $k; $j++) {\n            $product *= intval($s[$i + $j] - '0');\n        }\n        $result = max($result, $product);\n    }\n    return $result;\n}",
                "function specialPythagoreanTriplet($n) {\n    for ($a = 1; $a < $n; $a++) {\n        for ($b = $a; $b < $n; $b++) {\n            $c = $n - $a - $b;\n            if ($a * $a + $b * $b === $c * $c) {\n                return $a * $b * $c;\n            }\n        }\n    }\n    return -1;\n}",
                "function summationOfPrimes($n) {\n    $primes = [2];\n    $i = 3;\n    while ($i <= $n) {\n        foreach ($primes as $p) {\n            if ($i % $p === 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    $result = 0;\n    foreach ($primes as $prime) {\n        $result += $prime;\n    }\n    return $result;\n}",
                "function largestProductInAGrid($grid) {\n    $result = 0;\n    for ($i = 0; $i < count($grid) - 3; $i++) {\n        for ($j = 0; $j < count($grid[$i]) - 3; $j++) {\n            $p1 = 1;\n            $p2 = 1;\n            $p3 = 1;\n            $p4 = 1;\n            for ($k = 0; $k < 4; $k++) {\n                $p1 *= $grid[$i + $k][$j];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p2 *= $grid[$i][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p3 *= $grid[$i + $k][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p4 *= $grid[$i + $k][$j + 3 - $k];\n            }\n            $result = max($result, $p1, $p2, $p3, $p4);\n        }\n    }\n    return $result;\n}",
                "function highlyDivisibleTriangularNumber($n) {\n    for ($i = 1; $i < 100000000; $i++) {\n        $result = $i * ($i + 1) / 2;\n        $count = 0;\n        for ($j = 1; $j <= intval(sqrt($result)); $j++) {\n            if ($result % $j === 0) {\n                $count += 2;\n            }\n            if ($j * $j === $result) {\n                $count -= 1;\n            }\n        }\n        if ($count > $n) {\n            return $result;\n        }\n    }\n    return -1;\n}",
                "function largeSum($numbers) {\n    $digits = array_fill(0, 60, 0);\n    for ($i = 0; $i < 50; $i++) {\n        $tmp = 0;\n        foreach ($numbers as $num) {\n            $tmp += intval(substr($num, 49 - $i));\n        }\n        for ($j = $i; $j < 60; $j++) {\n            $digits[$j] += $tmp % 10;\n            if ($digits[$j] >= 10) {\n                $digits[$j + 1] += $digits[$j] / 10;\n                $digits[$j] %= 10;\n            }\n            $tmp /= 10;\n            if ($tmp == 0) {\n                break;\n            }\n        }\n    }\n    for ($i = 59; $i >= 0; $i--) {\n        if ($digits[$i]!= 0) {\n            $result = \"\";\n            for ($j = $i; $j > $i - 10; $j--) {\n                $result.= strval($digits[$j]);\n            }\n            return $result;\n        }\n    }\n    return \"\";\n}",
                "function longestCollatzSequence($n) {\n    $longest = 0;\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $chain = 1;\n        $num = $i;\n        while ($num!== 1) {\n            if ($num % 2 === 0) {\n                $num = $num / 2;\n            } else {\n                $num = 3 * $num + 1;\n            }\n            $chain++;\n        }\n        if ($chain > $longest) {\n            $longest = $chain;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function latticePaths($m, $n) {\n    $grid = [];\n    for ($i = 0; $i <= $m; $i++) {\n        $grid[$i] = [];\n        for ($j = 0; $j <= $n; $j++) {\n            $grid[$i][$j] = 0;\n        }\n    }\n    $grid[0][0] = 1;\n    for ($i = 1; $i <= $m; $i++) {\n        $grid[$i][0] = 1;\n    }\n    for ($j = 1; $j <= $n; $j++) {\n        $grid[0][$j] = 1;\n    }\n    for ($i = 1; $i <= $m; $i++) {\n        for ($j = 1; $j <= $n; $j++) {\n            $grid[$i][$j] = $grid[$i - 1][$j] + $grid[$i][$j - 1];\n        }\n    }\n    return $grid[$m][$n];\n}",
                "function powerDigitSum($n) {\n    $digits = [2];\n    for ($i = 1; $i < $n; $i++) {\n        $carry = 0;\n        foreach ($digits as $j => $digit) {\n            $temp = $digit * 2 + $carry;\n            $digits[$j] = $temp % 10;\n            $carry = $temp / 10;\n        }\n        if ($carry!= 0) {\n            array_push($digits, $carry);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function numberToWords($n) {\n    $ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    $teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    $tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if ($n === 1000) {\n        return \"one thousand\";\n    } else if ($n >= 100) {\n        if ($n % 100 === 0) {\n            return $ones[$n / 100]. \" hundred\";\n        } else {\n            return $ones[$n / 100]. \" hundred and \". numberToWords($n % 100);\n        }\n    } else if ($n >= 20) {\n        $suf = \"\";\n        if ($n % 10!== 0) {\n            $suf = \" \". $ones[$n % 10];\n        }\n        return $tens[$n / 10]. $suf;\n    } else if ($n >= 10) {\n        return $teens[$n - 10];\n    } else {\n        return $ones[$n];\n    }\n}",
                "function maximumPathSumI($triangle) {\n    $curr = array_slice($triangle[count($triangle) - 1], 0);\n    for ($i = count($triangle) - 2; $i >= 0; $i--) {\n        $next = array_slice($triangle[$i], 0);\n        for ($j = 0; $j < count($next); $j++) {\n            $next[$j] += max($curr[$j], $curr[$j + 1]);\n        }\n        $curr = $next;\n    }\n    return $curr[0];\n}",
                "function countingSundays($y1, $y2) {\n    $day = 0;\n    $count = 0;\n    for ($year = 1900; $year <= $y2; $year++) {\n        for ($month = 1; $month <= 12; $month++) {\n            if ($year >= $y1 && $day % 7 === 6) {\n                $count++;\n            }\n            if ($month === 4 || $month === 6 || $month === 9 || $month === 11) {\n                $day += 30;\n            } elseif ($month === 2) {\n                if ($year % 4 === 0 && ($year % 100!== 0 || $year % 400 === 0)) {\n                    $day += 29;\n                } else {\n                    $day += 28;\n                }\n            } else {\n                $day += 31;\n            }\n        }\n    }\n    return $count;\n}",
                "function factorialDigitSum($n) {\n    $digits = [1];\n    for ($i = 1; $i <= $n; $i++) {\n        $carry = 0;\n        foreach ($digits as $j => $digit) {\n            $digits[$j] = $digit * $i + $carry;\n            $carry = intval($digits[$j] / 10);\n            $digits[$j] %= 10;\n        }\n        while ($carry!= 0) {\n            array_push($digits, $carry % 10);\n            $carry = intval($carry / 10);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function d($n) {\n    $result = 1;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i === 0) {\n            $result += $i;\n            if ($i!== $n / $i) {\n                $result += $n / $i;\n            }\n        }\n    }\n    return $result;\n}\n\nfunction amicableNumbers($n) {\n    $result = 0;\n    for ($a = 2; $a < $n; $a++) {\n        $b = d($a);\n        if ($a!== $b && $a === d($b)) {\n            $result += $a;\n        }\n    }\n    return $result;\n}",
                "function namesScores($names, $queries) {\n    $sNames = clone $names;\n    sort($sNames);\n    $result = 0;\n    for ($i = 0; $i < count($sNames); $i++) {\n        $x = 0;\n        foreach (str_split($sNames[$i]) as $c) {\n            $x += ord($c) - 64;\n        }\n        foreach ($queries as $query) {\n            if ($query === $sNames[$i]) {\n                $result += $x * ($i + 1);\n                break;\n            }\n        }\n    }\n    return $result;\n}",
                "function isAbundant($n) {\n    if ($n < 12) {\n        return false;\n    }\n    $sumDivisors = 1;\n    for ($i = 2; $i <= intval(sqrt($n)); $i++) {\n        if ($n % $i === 0) {\n            $sumDivisors += $i;\n            if ($i!== $n / $i) {\n                $sumDivisors += $n / $i;\n            }\n        }\n    }\n    return $sumDivisors > $n;\n}\n\nfunction nonAbundantSums($n) {\n    $abundants = [];\n    for ($i = 12; $i < $n; $i++) {\n        if (isAbundant($i)) {\n            array_push($abundants, $i);\n        }\n    }\n    $abundantSums = [];\n    for ($i = 0; $i < count($abundants); $i++) {\n        for ($j = 0; $j < count($abundants); $j++) {\n            $abundantSums[$abundants[$i] + $abundants[$j]] = true;\n        }\n    }\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!isset($abundantSums[$i])) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function lexicographicPermutations($n) {\n    $result = \"\";\n    $digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    $x = $n - 1;\n    for ($i = 10; $i > 0; $i--) {\n        $fact = 1;\n        for ($j = 1; $j < $i; $j++) {\n            $fact *= $j;\n        }\n        $idx = $x / $fact;\n        $result.= strval($digits[$idx]);\n        $digits = array_merge(array_slice($digits, 0, $idx), array_slice($digits, $idx + 1));\n        $x -= $idx * $fact;\n    }\n    return $result;\n}",
                "function nDigitFibonacciNumber($n) {\n    $a = [1];\n    $b = [1];\n    $i = 2;\n    while (count($b) < $n) {\n        $carry = 0;\n        $c = $b;\n        $b = [];\n        foreach ($c as $j => $v) {\n            if (isset($a[$j])) {\n                $b[$j] = $a[$j] + $v + $carry;\n            } else {\n                $b[$j] = $v + $carry;\n            }\n            $carry = $b[$j] / 10;\n            $b[$j] = $b[$j] % 10;\n        }\n        if ($carry!= 0) {\n            array_push($b, $carry);\n        }\n        $a = $c;\n        $i = $i + 1;\n    }\n    return $i;\n}",
                "function reciprocalCycles($n) {\n    $result = 0;\n    $maxLength = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $remainders = [];\n        $remainder = 1;\n        while ($remainder!== 0 &&!in_array($remainder, $remainders)) {\n            array_push($remainders, $remainder);\n            $remainder = ($remainder * 10) % $i;\n        }\n        $length = 0;\n        if ($remainder!== 0) {\n            $length = count($remainders) - array_search($remainder, $remainders);\n        }\n        if ($length > $maxLength) {\n            $maxLength = $length;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction quadraticPrimes($n) {\n    $maxPrimes = 0;\n    $result = 0;\n    for ($a = -$n + 1; $a < $n; $a += 2) {\n        for ($b = -$n + 1; $b < $n; $b += 2) {\n            $x = 0;\n            while (true) {\n                if ($x * $x + $a * $x + $b < 2) {\n                    break;\n                }\n                if (!isPrime($x * $x + $a * $x + $b)) {\n                    break;\n                }\n                $x++;\n            }\n            if ($x > $maxPrimes) {\n                $maxPrimes = $x;\n                $result = $a * $b;\n            }\n        }\n    }\n    return $result;\n}",
                "function numberSpiralDiagonals($n) {\n    $result = 1;\n    for ($i = 3; $i <= $n; $i += 2) {\n        $result += 4 * $i * $i - 6 * $i + 6;\n    }\n    return $result;\n}",
                "function distinctPowers($n) {\n    $result = 0;\n    $xs = [];\n    for ($i = 2; $i <= $n; $i++) {\n        $primes = [2, 3, 5, 7];\n        $powers = [0, 0, 0, 0];\n        $num = $i;\n        for ($j = 0; $j < count($primes); $j++) {\n            while ($num % $primes[$j] === 0) {\n                $num /= $primes[$j];\n                $powers[$j] += 1;\n            }\n        }\n        if ($num!== 1) {\n            $result += $n - 1;\n            continue;\n        }\n        for ($j = 2; $j <= $n; $j++) {\n            $pstr = sprintf(\"%d-%d-%d-%d\", $powers[0] * $j, $powers[1] * $j, $powers[2] * $j, $powers[3] * $j);\n            $xs[$pstr] = true;\n        }\n    }\n    $result += count($xs);\n    return $result;\n}",
                "function digitNthPowers($n) {\n    $result = 0;\n    for ($i = 2; $i < 4 * pow(10, $n); $i++) {\n        $digitsSum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $digitInt = intval($digit);\n            $digitsSum += pow($digitInt, $n);\n        }\n        if ($i === $digitsSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function coinSums($n) {\n    $coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    $ways = array_fill(0, $n + 1, 0);\n    $ways[0] = 1;\n    foreach ($coins as $coin) {\n        for ($i = $coin; $i <= $n; $i++) {\n            $ways[$i] += $ways[$i - $coin];\n        }\n    }\n    return $ways[$n];\n}",
                "function pandigitalProducts($n) {\n    $products = [];\n    $s = \"\";\n    for ($i = 1; $i <= $n; $i++) {\n        $s.= strval($i);\n    }\n    for ($a = 1; $a < 100; $a++) {\n        for ($b = 1; $b < 10000; $b++) {\n            $c = $a * $b;\n            $chars = str_split(strval($a). strval($b). strval($c));\n            sort($chars);\n            if (implode(\"\", $chars) === $s) {\n                $products[$c] = true;\n            }\n        }\n    }\n    $result = 0;\n    foreach ($products as $product) {\n        $result += $product;\n    }\n    return $result;\n}",
                "function digitCancelingFractions($m) {\n    $numer = 1;\n    $denom = 1;\n    for ($d = 10; $d < $m; $d++) {\n        for ($n = 10; $n < $d; $n++) {\n            $n0 = $n % 10;\n            $n1 = $n / 10;\n            $d0 = $d % 10;\n            $d1 = $d / 10;\n            if (($n1 == $d0 && $n0 * $d == $n * $d1) || ($n0 == $d1 && $n1 * $d == $n * $d0)) {\n                $numer *= $n;\n                $denom *= $d;\n            }\n        }\n    }\n    $a = $numer;\n    $b = $denom;\n    while ($b!= 0) {\n        $temp = $b;\n        $b = $a % $b;\n        $a = $temp;\n    }\n    return $denom / $a;\n}",
                "function digitFactorials($n) {\n    $result = 0;\n    for ($i = 3; $i < $n; $i++) {\n        $factSum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $fact = 1;\n            for ($j = 1; $j <= intval($digit); $j++) {\n                $fact *= $j;\n            }\n            $factSum += $fact;\n        }\n        if ($i == $factSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction circularPrimes($n) {\n    $count = 0;\n    for ($i = 2; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $rotations = [];\n            $str = strval($i);\n            for ($j = 0; $j < strlen($str); $j++) {\n                $x = intval(substr($str, $j). substr($str, 0, $j));\n                $rotations[$x] = true;\n            }\n            $flag = true;\n            foreach ($rotations as $x => $v) {\n                if (!isPrime($x)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i]!== $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction doubleBasePalindromes($n) {\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $strI = strval($i);\n        $binI = decbin($i);\n        if (isPalindrome($strI) && isPalindrome($binI)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction truncatablePrimes($n) {\n    $result = 0;\n    for ($i = 10; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $flag = true;\n            for ($j = 1; $j < strlen($si); $j++) {\n                $p1 = intval(substr($si, $j));\n                $p2 = intval(substr($si, 0, strlen($si) - $j));\n                if (!isPrime($p1) ||!isPrime($p2)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $result += $i;\n            }\n        }\n    }\n    return $result;\n}",
                "function pandigitalMultiples($n) {\n    $result = -1;\n    for ($i = 2; $i <= $n; $i++) {\n        $cprod = \"\";\n        for ($j = 1; $j < 10; $j++) {\n            $cprod.= strval($i * $j);\n            if (strlen($cprod) === 9) {\n                $chars = explode(\"\", $cprod);\n                sort($chars);\n                if (implode(\"\", $chars) === \"123456789\") {\n                    $cprodInt = intval($cprod);\n                    $result = max($result, $cprodInt);\n                    break;\n                }\n            } else if (strlen($cprod) > 9) {\n                break;\n            }\n        }\n    }\n    return $result;\n}",
                "function integerRightTriangles($n) {\n    $maxSol = 0;\n    $result = 0;\n    for ($p = 3; $p <= $n; $p++) {\n        $sol = 0;\n        for ($a = 1; $a < $p / 2; $a++) {\n            for ($b = $a; $b < $p / 2; $b++) {\n                $c = $p - $a - $b;\n                if ($a * $a + $b * $b == $c * $c) {\n                    $sol++;\n                }\n            }\n        }\n        if ($sol > $maxSol) {\n            $maxSol = $sol;\n            $result = $p;\n        }\n    }\n    return $result;\n}",
                "function champernowneConstant($b) {\n    $s = \"\";\n    for ($i = 1; $i < pow($b, 6); $i++) {\n        $s.= strval($i);\n    }\n    $result = 1;\n    for ($i = 0; $i < 7; $i++) {\n        $n = intval(substr($s, pow($b, $i) - 1, 1));\n        $result *= $n;\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction pandigitalPrime($n) {\n    for ($i = $n - 1; $i > 0; $i--) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $length = strlen($si);\n            $flag = true;\n            for ($j = 1; $j <= $length; $j++) {\n                if (!strstr($si, strval($j))) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                return $i;\n            }\n        }\n    }\n    return -1;\n}",
                "function codedTriangleNumbers($words) {\n    $result = 0;\n    foreach ($words as $word) {\n        $value = 0;\n        foreach (str_split($word) as $c) {\n            $value += ord($c) - 64;\n        }\n        $n = intval(sqrt($value * 2));\n        if ($n * ($n + 1) === $value * 2) {\n            $result++;\n        }\n    }\n    return $result;\n}",
                "function genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return [$s];\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, $perm. substr($s, 0, $i). $s[0]. substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction subStringDivisibility($n) {\n    $result = 0;\n    $primes = [2, 3, 5, 7, 11, 13, 17];\n    $s = \"\";\n    for ($i = 0; $i <= $n; $i++) {\n        $s.= strval($i);\n    }\n    foreach (genPermutations($s) as $i) {\n        $flag = true;\n        for ($j = 1; $j < $n - 1; $j++) {\n            if (intval(substr($i, $j, 3)) % $primes[$j - 1]!== 0) {\n                $flag = false;\n                break;\n            }\n        }\n        if ($flag) {\n            $result += intval($i);\n        }\n    }\n    return $result;\n}",
                "function pentagonNumbers($n) {\n    $pentagon = [];\n    for ($i = 1; $i < $n; $i++) {\n        $pentagon[$i * ($i * 3 - 1) / 2] = true;\n    }\n    $result = -1;\n    foreach ($pentagon as $j => $v) {\n        foreach ($pentagon as $k => $v) {\n            if ($pentagon[$j + $k] && $pentagon[$k - $j]) {\n                if ($result === -1 || $k - $j < $result) {\n                    $result = $k - $j;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function triangularPentagonalAndHexagonal($n) {\n    $ps = [];\n    $i = 1;\n    $c = intval(0.5 * $i * (3 * $i - 1));\n    while ($c < $n) {\n        $i++;\n        $ps[$c] = true;\n        $c = intval(0.5 * $i * (3 * $i - 1));\n    }\n    $i = 1;\n    $c = $i * (2 * $i - 1);\n    $result = -1;\n    while ($c < $n) {\n        $i++;\n        if (isset($ps[$c])) {\n            $result = $c;\n        }\n        $c = $i * (2 * $i - 1);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction goldbachsOtherConjecture($n) {\n    $result = -1;\n    for ($i = 9999; $i > $n; $i -= 2) {\n        $upper = intval(sqrt($i / 2));\n        $flag = false;\n        for ($j = 0; $j <= $upper; $j++) {\n            if (isPrime($i - 2 * $j * $j)) {\n                $flag = true;\n                break;\n            }\n        }\n        if (!$flag) {\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function primeFactors($n) {\n    $num = $n;\n    $factors = [];\n    $i = 2;\n    while ($i * $i <= $num) {\n        if ($num % $i!== 0) {\n            $i++;\n        } else {\n            $num /= $i;\n            array_push($factors, $i);\n        }\n    }\n    if ($num > 1) {\n        array_push($factors, $num);\n    }\n    $s = [];\n    foreach ($factors as $v) {\n        $s[$v] = true;\n    }\n    return count($s);\n}\n\nfunction distinctPrimesFactors($n) {\n    for ($i = $n; $i < 1000000; $i++) {\n        if (primeFactors($i) === 4 && primeFactors($i + 1) === 4 && primeFactors($i + 2) === 4 && primeFactors($i + 3) === 4) {\n            return $i;\n        }\n    }\n    return -1;\n}",
                "function selfPowers($n) {\n    $digits = [10];\n    for ($i = 1; $i <= $n; $i++) {\n        $tempDigits = [10];\n        $tempDigits[0] = 1;\n        for ($j = 0; $j < $i; $j++) {\n            $carry = 0;\n            for ($k = 0; $k < 10; $k++) {\n                $tempDigits[$k] = $tempDigits[$k] * $i + $carry;\n                $carry = $tempDigits[$k] / 10;\n                $tempDigits[$k] %= 10;\n            }\n        }\n        for ($j = 0; $j < 10; $j++) {\n            $digits[$j] += $tempDigits[$j];\n            if ($digits[$j] >= 10) {\n                $digits[$j] -= 10;\n                if ($j < 9) {\n                    $digits[$j + 1] += 1;\n                }\n            }\n        }\n    }\n    $result = \"\";\n    for ($i = 9; $i >= 0; $i--) {\n        $result.= strval($digits[$i]);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return [$s];\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, $perm. substr($s, 0, $i). substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction primePermutations($n) {\n    for ($i = $n; $i > 999; $i--) {\n        if (isPrime($i)) {\n            $permutations = genPermutations(strval($i));\n            $candidates = [];\n            foreach ($permutations as $j) {\n                $candidate = intval($j);\n                if ($candidate > $i && isPrime($candidate)) {\n                    $candidates[$candidate] = true;\n                }\n            }\n            foreach ($candidates as $m => $v) {\n                if ($candidates[$m + ($m - $i)]) {\n                    return strval($i). strval($m). strval($m + ($m - $i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "function consecutivePrimeSum($limit) {\n    $sieve = array_fill(0, $limit, true);\n    $primes = [];\n    for ($i = 2; $i < $limit; $i++) {\n        if ($sieve[$i]) {\n            array_push($primes, $i);\n            for ($j = $i * 2; $j < $limit; $j += $i) {\n                $sieve[$j] = false;\n            }\n        }\n    }\n    $maxLength = 0;\n    $maxPrime = 0;\n    for ($i = 0; $i < count($primes); $i++) {\n        for ($j = $i + $maxLength; $j < count($primes); $j++) {\n            $s = 0;\n            for ($k = $i; $k < $j; $k++) {\n                $s += $primes[$k];\n            }\n            if ($s >= $limit) {\n                break;\n            }\n            if ($sieve[$s] && $j - $i > $maxLength) {\n                $maxLength = $j - $i;\n                $maxPrime = $s;\n            }\n        }\n    }\n    return $maxPrime;\n}"
            ],
            "python": [
                "def multiples_of_3_and_5(n: int) -> int:\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result",
                "def even_fibonacci_numbers(n: int) -> int:\n    result = 0\n    a = 1\n    b = 2\n    while a < n:\n        if a % 2 == 0:\n            result += a\n        tmp = a\n        a = b\n        b = tmp + b\n    return result",
                "def largest_prime_factor(n: int) -> int:\n    result = n\n    i = 2\n    while i * i <= result:\n        if result % i!= 0:\n            i += 1\n        else:\n            result //= i\n    return result",
                "def is_palindrome(s: str) -> bool:\n    for i in range(len(s) // 2):\n        if s[i]!= s[len(s) - i - 1]:\n            return False\n    return True\n\ndef largest_palindrome_product(n: int) -> int:\n    result = 0\n    for i in range(100, 1000):\n        for j in range(i, 1000):\n            prod = i * j\n            if is_palindrome(str(prod)) and prod > result and prod < n:\n                result = prod\n    return result",
                "def smallest_multiple(n: int) -> int:\n    result = 1\n    for i in range(1, n + 1):\n        if result % i!= 0:\n            for j in range(1, n + 1):\n                if (result * j) % i == 0:\n                    result *= j\n                    break\n    return result",
                "def sum_square_difference(n: int) -> int:\n    sqr_sum = 0\n    num_sum = 0\n    for i in range(1, n + 1):\n        sqr_sum += i * i\n        num_sum += i\n    return num_sum * num_sum - sqr_sum",
                "def nth_prime(n: int) -> int:\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for p in primes:\n            if i % p == 0:\n                break\n            if p * p > i:\n                primes.append(i)\n                break\n        i += 2\n    return primes[len(primes) - 1]",
                "def largest_product_in_a_series(s: str, k: int) -> int:\n    result = 0\n    for i in range(len(s) - k):\n        product = 1\n        for j in range(k):\n            product *= int(s[i + j])\n        result = max(result, product)\n    return result",
                "def special_pythagorean_triplet(n: int) -> int:\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - a - b\n            if a * a + b * b == c * c:\n                return a * b * c\n    return -1",
                "def summation_of_primes(n: int) -> int:\n    primes = [2]\n    i = 3\n    while i <= n:\n        for p in primes:\n            if i % p == 0:\n                break\n            if p * p > i:\n                primes.append(i)\n                break\n        i += 2\n    result = 0\n    for prime in primes:\n        result += prime\n    return result",
                "def largest_product_in_a_grid(grid: list[list[int]]) -> int:\n    result = 0\n    for i in range(len(grid) - 3):\n        for j in range(len(grid[i]) - 3):\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            for k in range(4):\n                p1 *= grid[i + k][j]\n            for k in range(4):\n                p2 *= grid[i][j + k]\n            for k in range(4):\n                p3 *= grid[i + k][j + k]\n            for k in range(4):\n                p4 *= grid[i + k][j + 3 - k]\n            result = max(result, p1, p2, p3, p4)\n    return result",
                "def highly_divisible_triangular_number(n: int) -> int:\n    for i in range(1, 100000000):\n        result = i * (i + 1) // 2\n        count = 0\n        for j in range(1, int(math.sqrt(result)) + 1):\n            if result % j == 0:\n                count += 2\n            if j * j == result:\n                count -= 1\n        if count > n:\n            return result\n    return -1",
                "def large_sum(numbers: list[str]) -> str:\n    digits = [0] * 60\n    for i in range(50):\n        tmp = 0\n        for num in numbers:\n            tmp += int(num[49 - i])\n        for j in range(i, 60):\n            digits[j] += tmp % 10\n            if digits[j] >= 10:\n                digits[j + 1] += digits[j] // 10\n                digits[j] %= 10\n            tmp //= 10\n            if tmp == 0:\n                break\n    for i in range(59, -1, -1):\n        if digits[i]!= 0:\n            result = \"\"\n            for j in range(i, i - 10, -1):\n                result += str(digits[j])\n            return result\n    return \"\"",
                "def longest_collatz_sequence(n: int) -> int:\n    longest = 0\n    result = 0\n    for i in range(1, n):\n        chain = 1\n        num = i\n        for num!= 1:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = 3 * num + 1\n            chain += 1\n        if chain > longest:\n            longest = chain\n            result = i\n    return result",
                "def lattice_paths(m: int, n: int) -> int:\n    grid = [[1] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n    return grid[m][n]",
                "def power_digit_sum(n: int) -> int:\n    digits = [2]\n    for i in range(1, n):\n        carry = 0\n        for j in range(len(digits)):\n            temp = digits[j]*2 + carry\n            digits[j] = temp % 10\n            carry = temp // 10\n        if carry!= 0:\n            digits.append(carry)\n    result = 0\n    for digit in digits:\n        result += digit\n    return result",
                "def number_to_words(n: int) -> str:\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000:\n        return \"one thousand\"\n    elif n >= 100:\n        if n % 100 == 0:\n            return ones[n // 100] + \" hundred\"\n        else:\n            return ones[n // 100] + \" hundred and \" + number_to_words(n % 100)\n    elif n >= 20:\n        suf = \"\"\n        if n % 10!= 0:\n            suf = \" \" + ones[n % 10]\n        return tens[n // 10] + suf\n    elif n >= 10:\n        return teens[n - 10]\n    else:\n        return ones[n]",
                "def maximum_path_sum_i(triangle: list[list[int]]) -> int:\n    curr = triangle[len(triangle) - 1][:]\n    for i in range(len(triangle) - 2, -1, -1):\n        next = triangle[i][:]\n        for j in range(len(next)):\n            next[j] += max(curr[j], curr[j + 1])\n        curr = next\n    return curr[0]",
                "def counting_sundays(y1: int, y2: int) -> int:\n    day = 0\n    count = 0\n    for year in range(1900, y2 + 1):\n        for month in range(1, 13):\n            if year >= y1 and day % 7 == 6:\n                count += 1\n            if month == 4 or month == 6 or month == 9 or month == 11:\n                day += 30\n            elif month == 2:\n                if year % 4 == 0 and (year % 100!= 0 or year % 400 == 0):\n                    day += 29\n                else:\n                    day += 28\n            else:\n                day += 31\n    return count",
                "def factorial_digit_sum(n: int) -> int:\n    digits = [1]\n    for i in range(1, n + 1):\n        carry = 0\n        for j, digit in enumerate(digits):\n            digits[j] = digit * i + carry\n            carry = digits[j] // 10\n            digits[j] %= 10\n        while carry!= 0:\n            digits.append(carry % 10)\n            carry //= 10\n    result = 0\n    for digit in digits:\n        result += digit\n    return result",
                "def d(n: int) -> int:\n    result = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result += i\n            if i!= n // i:\n                result += n // i\n    return result\n\ndef amicable_numbers(n: int) -> int:\n    result = 0\n    for a in range(2, n):\n        b = d(a)\n        if a!= b and a == d(b):\n            result += a\n    return result",
                "def names_scores(names: list[str], queries: list[str]) -> int:\n    s_names = slices.clone(names)\n    slices.sort(s_names)\n    result = 0\n    for i, name in enumerate(s_names):\n        x = 0\n        for c in name:\n            x += int(c) - 64\n        for query in queries:\n            if query == name:\n                result += x * (i + 1)\n                break\n    return result",
                "def is_abundant(n: int) -> bool:\n    if n < 12:\n        return False\n    sum_divisors = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i!= n // i:\n                sum_divisors += n // i\n    return sum_divisors > n\n\ndef non_abundant_sums(n: int) -> int:\n    abundants = []\n    for i in range(12, n):\n        if is_abundant(i):\n            abundants.append(i)\n    abundant_sums = set()\n    for i in abundants:\n        for j in abundants:\n            abundant_sums.add(i + j)\n    result = 0\n    for i in range(n):\n        if i not in abundant_sums:\n            result += i\n    return result",
                "def lexicographic_permutations(n: int) -> str:\n    result = \"\"\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    for i in range(10, 0, -1):\n        fact = 1\n        for j in range(1, i):\n            fact *= j\n        idx = x // fact\n        result += str(digits[idx])\n        digits = digits[:idx] + digits[idx+1:]\n        x -= idx * fact\n    return result",
                "def n_digit_fibonacci_number(n: int) -> int:\n    a = [1]\n    b = [1]\n    i = 2\n    while len(b) < n:\n        carry = 0\n        c = b[:]\n        for j in range(len(b)):\n            if j < len(a):\n                b[j] = a[j] + b[j] + carry\n            else:\n                b[j] = b[j] + carry\n            carry = b[j] // 10\n            b[j] = b[j] % 10\n        if carry!= 0:\n            b.append(carry)\n        a = c[:]\n        i = i + 1\n    return i",
                "def reciprocal_cycles(n: int) -> int:\n    result = 0\n    max_length = 0\n    for i in range(1, n):\n        remainders = []\n        remainder = 1\n        for remainder!= 0 and not remainder in remainders:\n            remainders.append(remainder)\n            remainder = (remainder * 10) % i\n        length = 0\n        if remainder!= 0:\n            length = len(remainders) - remainders.index(remainder)\n        if length > max_length:\n            max_length = length\n            result = i\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef quadratic_primes(n: int) -> int:\n    max_primes = 0\n    result = 0\n    for a in range(-n + 1, n, 2):\n        for b in range(-n + 1, n, 2):\n            x = 0\n            while True:\n                if x * x + a * x + b < 2:\n                    break\n                if not is_prime(x * x + a * x + b):\n                    break\n                x += 1\n            if x > max_primes:\n                max_primes = x\n                result = a * b\n    return result",
                "def number_spiral_diagonals(n: int) -> int:\n    result = 1\n    for i in range(3, n + 1, 2):\n        result += 4 * i * i - 6 * i + 6\n    return result",
                "def distinct_powers(n: int) -> int:\n    result = 0\n    xs = {}\n    for i in range(2, n + 1):\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        for j in range(len(primes)):\n            for num % primes[j] == 0:\n                num //= primes[j]\n                powers[j] += 1\n        if num!= 1:\n            result += n - 1\n            continue\n        for j in range(2, n + 1):\n            pstr = f\"{powers[0] * j}-{powers[1] * j}-{powers[2] * j}-{powers[3] * j}\"\n            xs[pstr] = True\n    result += len(xs)\n    return result",
                "def digit_nth_powers(n: int) -> int:\n    result = 0\n    for i in range(2, 4 * int(math.pow(10, float(n)))):\n        digits_sum = 0\n        for digit in str(i):\n            digits_sum += int(math.pow(float(digit), float(n)))\n        if i == digits_sum:\n            result += i\n    return result",
                "def coin_sums(n: int) -> int:\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = [1] * (n + 1)\n    for coin in coins:\n        for i in range(coin, n + 1):\n            ways[i] += ways[i - coin]\n    return ways[n]",
                "def pandigital_products(n: int) -> int:\n    products = {}\n    s = \"\"\n    for i in range(1, n + 1):\n        s += str(i)\n    for a in range(1, 100):\n        for b in range(1, 10000):\n            c = a * b\n            chars = list(str(a) + str(b) + str(c))\n            chars.sort()\n            if \"\".join(chars) == s:\n                products[c] = True\n    result = 0\n    for product in products:\n        result += product\n    return result",
                "def digit_canceling_fractions(m: int) -> int:\n    numer = 1\n    denom = 1\n    for d in range(10, m):\n        for n in range(10, d):\n            n0 = n % 10\n            n1 = n // 10\n            d0 = d % 10\n            d1 = d // 10\n            if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0):\n                numer *= n\n                denom *= d\n    a = numer\n    b = denom\n    while b!= 0:\n        temp = b\n        b = a % b\n        a = temp\n    return denom // a",
                "def digit_factorials(n: int) -> int:\n    result = 0\n    for i in range(3, n):\n        fact_sum = 0\n        for digit in str(i):\n            fact = 1\n            for j in range(1, int(digit)):\n                fact *= j\n            fact_sum += fact\n        if i == fact_sum:\n            result += i\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef circular_primes(n: int) -> int:\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            rotations = {}\n            str = str(i)\n            for j in range(len(str)):\n                x = int(str[j:] + str[:j])\n                rotations[x] = None\n            flag = True\n            for x in rotations:\n                if not is_prime(x):\n                    flag = False\n                    break\n            if flag:\n                count += 1\n    return count",
                "def is_palindrome(s: str) -> bool:\n    for i in range(len(s) // 2):\n        if s[i]!= s[len(s) - i - 1]:\n            return False\n    return True\n\ndef double_base_palindromes(n: int) -> int:\n    result = 0\n    for i in range(1, n):\n        str_i = str(i)\n        bin_i = bin(i)\n        if is_palindrome(str_i) and is_palindrome(bin_i):\n            result += i\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef truncatable_primes(n: int) -> int:\n    result = 0\n    for i in range(10, n):\n        if is_prime(i):\n            si = str(i)\n            flag = True\n            for j in range(1, len(si)):\n                p1 = int(si[j:])\n                p2 = int(si[:len(si) - j])\n                if not is_prime(p1) or not is_prime(p2):\n                    flag = False\n                    break\n            if flag:\n                result += i\n    return result",
                "def pandigital_multiples(n: int) -> int:\n    result = -1\n    for i in range(2, n + 1):\n        cprod = \"\"\n        for j in range(1, 10):\n            cprod += str(i * j)\n            if len(cprod) == 9:\n                chars = cprod.split(\"\")\n                chars.sort()\n                if \"\".join(chars) == \"123456789\":\n                    cprod_int = int(cprod)\n                    result = max(result, cprod_int)\n                    break\n            elif len(cprod) > 9:\n                break\n    return result",
                "def integer_right_triangles(n: int) -> int:\n    max_sol = 0\n    result = 0\n    for p in range(3, n + 1):\n        sol = 0\n        for a in range(1, p // 2 + 1):\n            for b in range(a, p // 2 + 1):\n                c = p - a - b\n                if a * a + b * b == c * c:\n                    sol += 1\n        if sol > max_sol:\n            max_sol = sol\n            result = p\n    return result",
                "def champernowne_constant(b: int) -> int:\n    s = \"\"\n    for i in range(1, int(math.pow(b, 6))):\n        s += str(i)\n    result = 1\n    for i in range(0, 7):\n        n = int(s[int(math.pow(b, i)) - 1])\n        result *= n\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef pandigital_prime(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if is_prime(i):\n            si = str(i)\n            length = len(si)\n            flag = True\n            for j in range(1, length + 1):\n                if si.find(str(j)) == -1:\n                    flag = False\n                    break\n            if flag:\n                return i\n    return -1",
                "def coded_triangle_numbers(words: list[str]) -> int:\n    result = 0\n    for word in words:\n        value = 0\n        for c in word:\n            value += ord(c) - 64\n        n = int(math.sqrt(value * 2))\n        if n * (n + 1) == value * 2:\n            result += 1\n    return result",
                "def gen_permutations(s: str) -> list[str]:\n    if len(s) <= 1:\n        return [s]\n    result = []\n    for perm in gen_permutations(s[1:]):\n        for i in range(len(s)):\n            result.append(perm[:i] + s[0] + perm[i:])\n    return result\n\ndef sub_string_divisibility(n: int) -> int:\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = \"\"\n    for i in range(n + 1):\n        s += str(i)\n    for i in gen_permutations(s):\n        flag = True\n        for j in range(1, n - 1):\n            if int(i[j:j + 3]) % primes[j - 1]!= 0:\n                flag = False\n                break\n        if flag:\n            result += int(i)\n    return result",
                "def pentagon_numbers(n: int) -> int:\n    pentagon = {}\n    for i in range(1, n):\n        pentagon[i * (3 * i - 1) // 2] = True\n    result = -1\n    for j in pentagon:\n        for k in pentagon:\n            if pentagon[j + k] and pentagon[k - j]:\n                if result == -1 or k - j < result:\n                    result = k - j\n    return result",
                "def triangular_pentagonal_and_hexagonal(n: int) -> int:\n    ps = {}\n    i = 1\n    c = int(0.5 * i * (3 * i - 1))\n    while c < n:\n        i += 1\n        ps[c] = True\n        c = int(0.5 * i * (3 * i - 1))\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n:\n        i += 1\n        if c in ps:\n            result = c\n        c = i * (2 * i - 1)\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef goldbachs_other_conjecture(n: int) -> int:\n    result = -1\n    for i in range(9999, n, -2):\n        upper = int(math.sqrt(i / 2))\n        flag = False\n        for j in range(0, upper + 1):\n            if is_prime(i - 2 * j * j):\n                flag = True\n                break\n        if not flag:\n            result = i\n    return result",
                "def prime_factors(n: int) -> int:\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num:\n        if num % i!= 0:\n            i += 1\n        else:\n            num //= i\n            factors.append(i)\n    if num > 1:\n        factors.append(num)\n    s = set()\n    for v in factors:\n        s.add(v)\n    return len(s)\n\ndef distinct_primes_factors(n: int) -> int:\n    for i in range(n, 1000000):\n        if prime_factors(i) == 4 and prime_factors(i + 1) == 4 and prime_factors(i + 2) == 4 and prime_factors(i + 3) == 4:\n            return i\n    return -1",
                "def self_powers(n: int) -> str:\n    digits = [0] * 10\n    for i in range(1, n + 1):\n        temp_digits = [0] * 10\n        temp_digits[0] = 1\n        for j in range(i):\n            carry = 0\n            for k in range(10):\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] // 10\n                temp_digits[k] %= 10\n        for j in range(10):\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10:\n                digits[j] -= 10\n                if j < 9:\n                    digits[j + 1] += 1\n    result = \"\"\n    for i in range(9, -1, -1):\n        result += str(digits[i])\n    return result",
                "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef gen_permutations(s: str) -> list[str]:\n    if len(s) <= 1:\n        return [s]\n    result = []\n    for perm in gen_permutations(s[1:]):\n        for i in range(len(s)):\n            result.append(perm[:i] + s[0] + perm[i:])\n    return result\n\ndef prime_permutations(n: int) -> str:\n    for i in range(n, 999, -1):\n        if is_prime(i):\n            permutations = gen_permutations(str(i))\n            candidates = {}\n            for j in permutations:\n                candidate = int(j)\n                if candidate > i and is_prime(candidate):\n                    candidates[candidate] = True\n            for m in candidates:\n                if candidates[m + (m - i)]:\n                    return str(i) + str(m) + str(m + (m - i))\n    return \"\"",
                "def consecutive_prime_sum(limit: int) -> int:\n    sieve = [True] * limit\n    primes = []\n    for i in range(2, limit):\n        if sieve[i]:\n            primes.append(i)\n            for j in range(i * 2, limit, i):\n                sieve[j] = False\n    maxLength = 0\n    maxPrime = 0\n    for i in range(len(primes)):\n        for j in range(i + maxLength, len(primes)):\n            s = 0\n            for k in range(i, j):\n                s += primes[k]\n            if s >= limit:\n                break\n            if sieve[s] and j - i > maxLength:\n                maxLength = j - i\n                maxPrime = s\n    return maxPrime"
            ],
            "ruby": [
                "def multiples_of_3_and_5(n)\n    result = 0\n    (0...n).each do |i|\n        if i % 3 == 0 || i % 5 == 0\n            result += i\n        end\n    end\n    result\nend",
                "def even_fibonacci_numbers(n)\n    result = 0\n    a = 1\n    b = 2\n    while a < n\n        if a % 2 == 0\n            result += a\n        end\n        tmp = a\n        a = b\n        b = tmp + b\n    end\n    result\nend",
                "def largest_prime_factor(n)\n    result = n\n    i = 2\n    while i * i <= result\n        if result % i!= 0\n            i += 1\n        else\n            result /= i\n        end\n    end\n    result\nend",
                "def is_palindrome(s)\n    for i in 0...(s.length / 2)\n        return false if s[i]!= s[s.length - i - 1]\n    end\n    true\nend\n\ndef largest_palindrome_product(n)\n    result = 0\n    (100...1000).each do |i|\n        (i...1000).each do |j|\n            prod = i * j\n            if is_palindrome(prod.to_s) && prod > result && prod < n\n                result = prod\n            end\n        end\n    end\n    result\nend",
                "def smallest_multiple(n)\n    result = 1\n    (1..n).each do |i|\n        if result % i!= 0\n            (1..n).each do |j|\n                if (result * j) % i == 0\n                    result *= j\n                    break\n                end\n            end\n        end\n    end\n    result\nend",
                "def sum_square_difference(n)\n    sqr_sum = 0\n    num_sum = 0\n    (1..n).each do |i|\n        sqr_sum += i * i\n        num_sum += i\n    end\n    num_sum * num_sum - sqr_sum\nend",
                "def nth_prime(n)\n    primes = [2]\n    i = 3\n    while primes.length < n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    primes[primes.length - 1]\nend",
                "def largest_product_in_a_series(s, k)\n    result = 0\n    (0...s.length - k).each do |i|\n        product = 1\n        (0...k).each do |j|\n            product *= s[i + j].to_i\n        end\n        result = [result, product].max\n    end\n    result\nend",
                "def special_pythagorean_triplet(n)\n    (1...n).each do |a|\n        (a...n).each do |b|\n            c = n - a - b\n            if a * a + b * b == c * c\n                return a * b * c\n            end\n        end\n    end\n    -1\nend",
                "def summation_of_primes(n)\n    primes = [2]\n    i = 3\n    while i <= n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    result = 0\n    primes.each do |prime|\n        result += prime\n    end\n    result\nend",
                "def largest_product_in_a_grid(grid)\n    result = 0\n    (0...grid.length - 3).each do |i|\n        (0...grid[i].length - 3).each do |j|\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            (0...4).each do |k|\n                p1 *= grid[i + k][j]\n            end\n            (0...4).each do |k|\n                p2 *= grid[i][j + k]\n            end\n            (0...4).each do |k|\n                p3 *= grid[i + k][j + k]\n            end\n            (0...4).each do |k|\n                p4 *= grid[i + k][j + 3 - k]\n            end\n            result = [result, p1, p2, p3, p4].max\n        end\n    end\n    result\nend",
                "def highly_divisible_triangular_number(n)\n    for i in 1..100000000\n        result = i * (i + 1) / 2\n        count = 0\n        (1..Math.sqrt(result).to_i).each do |j|\n            if result % j == 0\n                count += 2\n            end\n            if j * j == result\n                count -= 1\n            end\n        end\n        if count > n\n            return result\n        end\n    end\n    -1\nend",
                "def large_sum(numbers)\n    digits = Array.new(60, 0)\n    (0...50).each do |i|\n        tmp = 0\n        numbers.each do |num|\n            tmp += num[49 - i].to_i\n        end\n        (i...60).each do |j|\n            digits[j] += tmp % 10\n            if digits[j] >= 10\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            end\n            tmp /= 10\n            break if tmp == 0\n        end\n    end\n    result = \"\"\n    (59...0).each do |i|\n        if digits[i]!= 0\n            (i...i - 10).each do |j|\n                result += digits[j].to_s\n            end\n            break\n        end\n    end\n    result\nend",
                "def longest_collatz_sequence(n)\n    longest = 0\n    result = 0\n    (1...n).each do |i|\n        chain = 1\n        num = i\n        while num!= 1\n            if num % 2 == 0\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end\n            chain += 1\n        end\n        if chain > longest\n            longest = chain\n            result = i\n        end\n    end\n    result\nend",
                "def lattice_paths(m, n)\n    grid = Array.new(m + 1) { Array.new(n + 1, 0) }\n    (0..m).each do |i|\n        grid[i][0] = 1\n    end\n    (0..n).each do |j|\n        grid[0][j] = 1\n    end\n    (1..m).each do |i|\n        (1..n).each do |j|\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        end\n    end\n    grid[m][n]\nend",
                "def power_digit_sum(n)\n    digits = [2]\n    (1...n).each do |i|\n        carry = 0\n        digits.each_with_index do |digit, j|\n            temp = digit*2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        end\n        digits.push(carry) if carry!= 0\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def number_to_words(n)\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000\n        \"one thousand\"\n    elsif n >= 100\n        if n % 100 == 0\n            ones[n / 100] + \" hundred\"\n        else\n            ones[n / 100] + \" hundred and \" + number_to_words(n % 100)\n        end\n    elsif n >= 20\n        suf = \"\"\n        if n % 10!= 0\n            suf = \" \" + ones[n % 10]\n        end\n        tens[n / 10] + suf\n    elsif n >= 10\n        teens[n - 10]\n    else\n        ones[n]\n    end\nend",
                "def maximum_path_sum_i(triangle)\n    curr = triangle[triangle.length - 1].clone\n    (triangle.length - 2).downto(0) do |i|\n        next = triangle[i].clone\n        (0...next.length).each do |j|\n            next[j] += [curr[j], curr[j + 1]].max\n        end\n        curr = next\n    end\n    curr[0]\nend",
                "def counting_sundays(y1, y2)\n    day = 0\n    count = 0\n    (1900..y2).each do |year|\n        (1..12).each do |month|\n            if year >= y1 && day % 7 == 6\n                count += 1\n            end\n            if month == 4 || month == 6 || month == 9 || month == 11\n                day += 30\n            elsif month == 2\n                if year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)\n                    day += 29\n                else\n                    day += 28\n                end\n            else\n                day += 31\n            end\n        end\n    end\n    count\nend",
                "def factorial_digit_sum(n)\n    digits = [1]\n    (1..n).each do |i|\n        carry = 0\n        digits.each_with_index do |digit, j|\n            digits[j] = digit * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        end\n        while carry!= 0\n            digits.push(carry % 10)\n            carry /= 10\n        end\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def d(n)\n    result = 1\n    (2..Math.sqrt(n).to_i).each do |i|\n        if n % i == 0\n            result += i\n            if i!= n / i\n                result += n / i\n            end\n        end\n    end\n    result\nend\n\ndef amicable_numbers(n)\n    result = 0\n    (2...n).each do |a|\n        b = d(a)\n        if a!= b && a == d(b)\n            result += a\n        end\n    end\n    result\nend",
                "def names_scores(names, queries)\n    sNames = names.clone\n    sNames.sort\n    result = 0\n    sNames.each_with_index do |name, i|\n        x = 0\n        name.each_byte do |c|\n            x += c - 64\n        end\n        queries.each do |query|\n            if query == name\n                result += x * (i + 1)\n                break\n            end\n        end\n    end\n    result\nend",
                "def is_abundant(n)\n    if n < 12\n        return false\n    end\n    sum_divisors = 1\n    (2...Math.sqrt(n)).each do |i|\n        if n % i == 0\n            sum_divisors += i\n            if i!= n / i\n                sum_divisors += n / i\n            end\n        end\n    end\n    sum_divisors > n\nend\n\ndef non_abundant_sums(n)\n    abundants = []\n    (12...n).each do |i|\n        if is_abundant(i)\n            abundants.push(i)\n        end\n    end\n    abundant_sums = {}\n    abundants.each do |i|\n        abundants.each do |j|\n            abundant_sums[i + j] = true\n        end\n    end\n    result = 0\n    (0...n).each do |i|\n        if!abundant_sums[i]\n            result += i\n        end\n    end\n    result\nend",
                "def lexicographic_permutations(n)\n    result = \"\"\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    for i in 10..1\n        fact = 1\n        for j in 1..(i-1)\n            fact *= j\n        end\n        idx = x / fact\n        result += digits[idx].to_s\n        digits = digits[0...idx] + digits[(idx+1)..-1]\n        x -= idx * fact\n    end\n    result\nend",
                "def n_digit_fibonacci_number(n)\n    a = [1]\n    b = [1]\n    i = 2\n    while b.length < n\n        carry = 0\n        c = b.clone\n        b.each_with_index do |num, index|\n            if index < a.length\n                b[index] = a[index] + b[index] + carry\n            else\n                b[index] = b[index] + carry\n            end\n            carry = b[index] / 10\n            b[index] = b[index] % 10\n        end\n        if carry!= 0\n            b.push(carry)\n        end\n        a = c.clone\n        i = i + 1\n    end\n    i\nend",
                "def reciprocal_cycles(n)\n    result = 0\n    maxLength = 0\n    (1...n).each do |i|\n        remainders = []\n        remainder = 1\n        while remainder!= 0 &&!remainders.include?(remainder)\n            remainders.push(remainder)\n            remainder = (remainder * 10) % i\n        end\n        length = 0\n        if remainder!= 0\n            length = remainders.length - remainders.index(remainder)\n        end\n        if length > maxLength\n            maxLength = length\n            result = i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    for i in 3..Math.sqrt(n).to_i\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef quadratic_primes(n)\n    max_primes = 0\n    result = 0\n    (-n + 1..n).step(2) do |a|\n        (-n + 1..n).step(2) do |b|\n            x = 0\n            loop do\n                if x*x + a*x + b < 2\n                    break\n                end\n                if!is_prime(x*x + a*x + b)\n                    break\n                end\n                x += 1\n            end\n            if x > max_primes\n                max_primes = x\n                result = a * b\n            end\n        end\n    end\n    result\nend",
                "def number_spiral_diagonals(n)\n    result = 1\n    (3...n).step(2) do |i|\n        result += 4 * i * i - 6 * i + 6\n    end\n    result\nend",
                "def distinct_powers(n)\n    result = 0\n    xs = {}\n    (2..n).each do |i|\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        primes.each do |prime|\n            while num % prime == 0\n                num /= prime\n                powers[primes.index(prime)] += 1\n            end\n        end\n        if num!= 1\n            result += n - 1\n            next\n        end\n        (2..n).each do |j|\n            pstr = \"#{powers[0] * j}-#{powers[1] * j}-#{powers[2] * j}-#{powers[3] * j}\"\n            xs[pstr] = true\n        end\n    end\n    result += xs.length\n    result\nend",
                "def digit_nth_powers(n)\n    result = 0\n    (2..(4 * 10**n)).each do |i|\n        digits_sum = 0\n        i.to_s.each_byte do |digit|\n            digits_sum += digit.to_i**n\n        end\n        if i == digits_sum\n            result += i\n        end\n    end\n    result\nend",
                "def coin_sums(n)\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = Array.new(n + 1, 0)\n    ways[0] = 1\n    coins.each do |coin|\n        (coin..n).each do |i|\n            ways[i] += ways[i - coin]\n        end\n    end\n    ways[n]\nend",
                "def pandigital_products(n)\n    products = {}\n    s = (1..n).to_a.join\n    (1..99).each do |a|\n        (1..9999).each do |b|\n            c = a * b\n            chars = (a.to_s + b.to_s + c.to_s).chars.sort\n            if chars.join == s\n                products[c] = true\n            end\n        end\n    end\n    result = 0\n    products.each do |product|\n        result += product\n    end\n    result\nend",
                "def digit_canceling_fractions(m)\n    numer = 1\n    denom = 1\n    (10...m).each do |d|\n        (10...d).each do |n|\n            n0 = n % 10\n            n1 = n / 10\n            d0 = d % 10\n            d1 = d / 10\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)\n                numer *= n\n                denom *= d\n            end\n        end\n    end\n    a = numer\n    b = denom\n    while b!= 0\n        temp = b\n        b = a % b\n        a = temp\n    end\n    denom / a\nend",
                "def digit_factorials(n)\n    result = 0\n    (3...n).each do |i|\n        fact_sum = 0\n        i.to_s.each_byte do |digit|\n            fact = 1\n            (1...digit).each do |j|\n                fact *= j\n            end\n            fact_sum += fact\n        end\n        if i == fact_sum\n            result += i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    for i in 3..Math.sqrt(n).to_i\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef circular_primes(n)\n    count = 0\n    (2...n).each do |i|\n        if is_prime(i)\n            rotations = {}\n            str = i.to_s\n            (0...str.length).each do |j|\n                x, _ = str[j..-1] + str[0...j].to_s\n                rotations[x.to_i] = nil\n            end\n            flag = true\n            rotations.each do |x|\n                if!is_prime(x)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                count += 1\n            end\n        end\n    end\n    count\nend",
                "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        if s[i]!= s[s.length - i - 1]\n            return false\n        end\n    end\n    true\nend\n\ndef double_base_palindromes(n)\n    result = 0\n    (1...n).each do |i|\n        str_i = i.to_s\n        bin_i = i.to_s(2)\n        if is_palindrome(str_i) && is_palindrome(bin_i)\n            result += i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    for i in 3..Math.sqrt(n).to_i\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef truncatable_primes(n)\n    result = 0\n    (10...n).each do |i|\n        if is_prime(i)\n            si = i.to_s\n            flag = true\n            (1...si.length).each do |j|\n                p1 = si[j..-1].to_i\n                p2 = si[0...si.length - j].to_i\n                if!is_prime(p1) ||!is_prime(p2)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                result += i\n            end\n        end\n    end\n    result\nend",
                "def pandigital_multiples(n)\n    result = -1\n    (2..n).each do |i|\n        cprod = \"\"\n        (1..9).each do |j|\n            cprod += i * j.to_s\n            if cprod.length == 9\n                chars = cprod.split(\"\")\n                chars.sort!\n                if chars.join(\"\") == \"123456789\"\n                    cprod_int = cprod.to_i\n                    result = [result, cprod_int].max\n                    break\n                end\n            elsif cprod.length > 9\n                break\n            end\n        end\n    end\n    result\nend",
                "def integer_right_triangles(n)\n    max_sol = 0\n    result = 0\n    (3...n).each do |p|\n        sol = 0\n        (1...(p / 2)).each do |a|\n            (a...(p / 2)).each do |b|\n                c = p - a - b\n                if a * a + b * b == c * c\n                    sol += 1\n                end\n            end\n        end\n        if sol > max_sol\n            max_sol = sol\n            result = p\n        end\n    end\n    result\nend",
                "def champernowne_constant(b)\n    s = \"\"\n    (1...(b**6).to_i).each do |i|\n        s += i.to_s\n    end\n    result = 1\n    (0...7).each do |i|\n        n = s[((b**i).to_i - 1).to_s.to_i]\n        result *= n.to_i\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    for i in 3..Math.sqrt(n).to_i\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef pandigital_prime(n)\n    for i in n - 1..1\n        if is_prime(i)\n            si = i.to_s\n            length = si.length\n            flag = true\n            for j in 1..length\n                if!si.include?(j.to_s)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                return i\n            end\n        end\n    end\n    return -1\nend",
                "def coded_triangle_numbers(words)\n    result = 0\n    words.each do |word|\n        value = 0\n        word.each_byte do |c|\n            value += c - 64\n        end\n        n = Math.sqrt(value * 2).to_i\n        if n * (n + 1) == value * 2\n            result += 1\n        end\n    end\n    result\nend",
                "def gen_permutations(s)\n    if s.length <= 1\n        return [s]\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0].to_s + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef sub_string_divisibility(n)\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = \"\"\n    (0...n).each do |i|\n        s += i.to_s\n    end\n    gen_permutations(s).each do |i|\n        flag = true\n        (1...n - 1).each do |j|\n            if n, _ = i[j..j + 2].to_i; n % primes[j - 1]!= 0\n                flag = false\n                break\n            end\n        end\n        if flag\n            s0, _ = i.to_i\n            result += s0\n        end\n    end\n    result\nend",
                "def pentagon_numbers(n)\n    pentagon = {}\n    (1...n).each do |i|\n        pentagon[i * (3 * i - 1) / 2] = true\n    end\n    result = -1\n    pentagon.each do |j, _|\n        pentagon.each do |k, _|\n            if pentagon[j + k] && pentagon[k - j]\n                if result == -1 || k - j < result\n                    result = k - j\n                end\n            end\n        end\n    end\n    result\nend",
                "def triangular_pentagonal_and_hexagonal(n)\n    ps = {}\n    i = 1\n    c = (i * (3 * i - 1)) / 2\n    while c < n\n        i += 1\n        ps[c] = true\n        c = (i * (3 * i - 1)) / 2\n    end\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n\n        i += 1\n        if ps[c]\n            result = c\n        end\n        c = i * (2 * i - 1)\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    for i in 3..(Math.sqrt(n)).to_i\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef goldbachs_other_conjecture(n)\n    result = -1\n    for i in 9999..n\n        upper = (Math.sqrt(i / 2)).to_i\n        flag = false\n        for j in 0..upper\n            if is_prime(i - 2 * j * j)\n                flag = true\n                break\n            end\n        end\n        if!flag\n            result = i\n        end\n    end\n    result\nend",
                "def prime_factors(n)\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num\n        if num % i!= 0\n            i += 1\n        else\n            num /= i\n            factors.push(i)\n        end\n    end\n    if num > 1\n        factors.push(num)\n    end\n    s = {}\n    factors.each do |v|\n        s[v] = true\n    end\n    s.length\nend\n\ndef distinct_primes_factors(n)\n    for i in n..999999\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4\n            return i\n        end\n    end\n    -1\nend",
                "def self_powers(n)\n    digits = [0] * 10\n    digits[0] = 1\n    for i in 1..n\n        temp_digits = [0] * 10\n        carry = 0\n        for j in 0..9\n            temp_digits[j] = digits[j] * i + carry\n            carry = temp_digits[j] / 10\n            temp_digits[j] %= 10\n        end\n        for j in 0..9\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10\n                digits[j] -= 10\n                if j < 9\n                    digits[j + 1] += 1\n                end\n            end\n        end\n    end\n    result = \"\"\n    for i in 9..0\n        result += digits[i].to_s\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    for i in 3..Math.sqrt(n).to_i\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef gen_permutations(s)\n    if s.length <= 1\n        return [s]\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0].to_s + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef prime_permutations(n)\n    for i in n..999\n        if is_prime(i)\n            permutations = gen_permutations(i.to_s)\n            candidates = {}\n            permutations.each do |j|\n                candidate, _ = j.to_i\n                if candidate > i && is_prime(candidate)\n                    candidates[candidate] = true\n                end\n            end\n            candidates.each do |m, _|\n                if candidates[m + (m - i)]\n                    return i.to_s + m.to_s + (m + (m - i)).to_s\n                end\n            end\n        end\n    end\n    return \"\"\nend",
                "def consecutive_prime_sum(limit)\n    sieve = Array.new(limit, true)\n    primes = []\n    for i in 2...limit\n        if sieve[i]\n            primes.push(i)\n            for j in (i * 2)...limit\n                sieve[j] = false\n            end\n        end\n    end\n    maxLength = 0\n    maxPrime = 0\n    for i in 0...primes.length\n        for j in (i + maxLength)...primes.length\n            s = 0\n            for k in i...j\n                s += primes[k]\n            end\n            if s >= limit\n                break\n            end\n            if sieve[s] && j - i > maxLength\n                maxLength = j - i\n                maxPrime = s\n            end\n        end\n    end\n    maxPrime\nend"
            ],
            "rust": [
                "fn multiples_of_3_and_5(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..n {\n        if i % 3 == 0 || i % 5 == 0 {\n            result += i;\n        }\n    }\n    result\n}",
                "fn even_fibonacci_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut a = 1;\n    let mut b = 2;\n    loop {\n        if a >= n {\n            break;\n        }\n        if a % 2 == 0 {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    result\n}",
                "fn largest_prime_factor(n: i32) -> i32 {\n    let mut result = n;\n    let mut i = 2;\n    while i * i <= result {\n        if result % i!= 0 {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    result\n}",
                "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s[i]!= s[s.len() - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn largest_palindrome_product(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 100..1000 {\n        for j in i..1000 {\n            let prod = i * j;\n            if is_palindrome(&prod.to_string()) && prod > result && prod < n {\n                result = prod;\n            }\n        }\n    }\n    result\n}",
                "fn smallest_multiple(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 1..=n {\n        if result % i!= 0 {\n            for j in 1..=n {\n                if (result * j) % i == 0 {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn sum_square_difference(n: i32) -> i32 {\n    let mut sqr_sum = 0;\n    let mut num_sum = 0;\n    for i in 1..=n {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    num_sum * num_sum - sqr_sum\n}",
                "fn nth_prime(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while primes.len() < n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    primes[primes.len() - 1]\n}",
                "fn largest_product_in_a_series(s: &String, k: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..s.len() - k as usize {\n        let mut product = 1;\n        for j in 0..k as usize {\n            product *= s.chars().nth(i + j).unwrap() as i32 - '0' as i32;\n        }\n        result = result.max(product);\n    }\n    result\n}",
                "fn special_pythagorean_triplet(n: i32) -> i32 {\n    for a in 1..n {\n        for b in a..n {\n            let c = n - a - b;\n            if a * a + b * b == c * c {\n                return a * b * c;\n            }\n        }\n    }\n    -1\n}",
                "fn summation_of_primes(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while i <= n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let mut result = 0;\n    for prime in &primes {\n        result += prime;\n    }\n    result\n}",
                "fn largest_product_in_a_grid(grid: &Vec<Vec<i32>>) -> i32 {\n    let mut result = 0;\n    for i in 0..grid.len() - 3 {\n        for j in 0..grid[i].len() - 3 {\n            let mut p1 = 1;\n            let mut p2 = 1;\n            let mut p3 = 1;\n            let mut p4 = 1;\n            for k in 0..4 {\n                p1 *= grid[i + k][j];\n            }\n            for k in 0..4 {\n                p2 *= grid[i][j + k];\n            }\n            for k in 0..4 {\n                p3 *= grid[i + k][j + k];\n            }\n            for k in 0..4 {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max(result, p1, p2, p3, p4);\n        }\n    }\n    result\n}",
                "fn highly_divisible_triangular_number(n: i32) -> i32 {\n    for i in 1..100000000 {\n        let result = i * (i + 1) / 2;\n        let mut count = 0;\n        for j in 1..(result as f64).sqrt() as i32 + 1 {\n            if result % j == 0 {\n                count += 2;\n            }\n            if j * j == result {\n                count -= 1;\n            }\n        }\n        if count > n {\n            return result;\n        }\n    }\n    -1\n}",
                "fn large_sum(numbers: &Vec<String>) -> String {\n    let mut digits = vec![0; 60];\n    for i in 0..50 {\n        let mut tmp = 0;\n        for num in numbers {\n            tmp += num.chars().nth(49 - i).unwrap() as i32 - '0' as i32;\n        }\n        for j in i..60 {\n            digits[j] += tmp % 10;\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if tmp == 0 {\n                break;\n            }\n        }\n    }\n    for i in (0..60).rev() {\n        if digits[i]!= 0 {\n            let mut result = String::new();\n            for j in i..i + 10 {\n                result.push_str(&digits[j].to_string());\n            }\n            return result;\n        }\n    }\n    String::new()\n}",
                "fn longest_collatz_sequence(n: i32) -> i32 {\n    let mut longest = 0;\n    let mut result = 0;\n    for i in 1..n {\n        let mut chain = 1;\n        let mut num = i;\n        while num!= 1 {\n            if num % 2 == 0 {\n                num /= 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if chain > longest {\n            longest = chain;\n            result = i;\n        }\n    }\n    result\n}",
                "fn lattice_paths(m: i32, n: i32) -> i32 {\n    let mut grid = vec![vec![0; n as usize + 1]; m as usize + 1];\n    for i in 0..m + 1 {\n        grid[i][0] = 1;\n    }\n    for j in 0..n + 1 {\n        grid[0][j] = 1;\n    }\n    for i in 1..m + 1 {\n        for j in 1..n + 1 {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    grid[m as usize][n as usize]\n}",
                "fn power_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![2];\n    for i in 1..n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            let temp = digits[j]*2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if carry!= 0 {\n            digits.push(carry);\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
                "fn number_to_words(n: i32) -> String {\n    let ones = vec![\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = vec![\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = vec![\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if n == 1000 {\n        return \"one thousand\".to_string();\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n / 100].to_string() + \" hundred\".to_string();\n        } else {\n            return ones[n / 100].to_string() + \" hundred and \".to_string() + number_to_words(n % 100);\n        }\n    } else if n >= 20 {\n        let mut suf = \"\".to_string();\n        if n % 10!= 0 {\n            suf = \" \".to_string() + ones[n % 10].to_string();\n        }\n        return tens[n / 10].to_string() + suf;\n    } else if n >= 10 {\n        return teens[n - 10].to_string();\n    } else {\n        return ones[n].to_string();\n    }\n}",
                "fn maximum_path_sum_i(triangle: &Vec<Vec<i32>>) -> i32 {\n    let mut curr = triangle[triangle.len() - 1].clone();\n    for i in (0..triangle.len() - 1).rev() {\n        let mut next = Vec::new();\n        for j in 0..triangle[i].len() {\n            next.push(triangle[i][j] + int::max(curr[j], curr[j + 1]));\n        }\n        curr = next;\n    }\n    curr[0]\n}",
                "fn counting_sundays(y1: i32, y2: i32) -> i32 {\n    let mut day = 0;\n    let mut count = 0;\n    for year in 1900..=y2 {\n        for month in 1..=12 {\n            if year >= y1 && day % 7 == 6 {\n                count += 1;\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30;\n            } else if month == 2 {\n                if year % 4 == 0 && (year % 100!= 0 || year % 400 == 0) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    count\n}",
                "fn factorial_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![1];\n    for i in 1..=n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while carry!= 0 {\n            digits.push(carry % 10);\n            carry /= 10;\n        }\n    }\n    digits.iter().fold(0, |acc, &x| acc + x)\n}",
                "fn d(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 2..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            result += i;\n            if i!= n / i {\n                result += n / i;\n            }\n        }\n    }\n    result\n}\n\nfn amicable_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    for a in 2..n {\n        let b = d(a);\n        if a!= b && a == d(b) {\n            result += a;\n        }\n    }\n    result\n}",
                "fn names_scores(names: &Vec<String>, queries: &Vec<String>) -> i32 {\n    let mut s_names = names.clone();\n    s_names.sort();\n    let mut result = 0;\n    for (i, name) in s_names.iter().enumerate() {\n        let mut x = 0;\n        for c in name.chars() {\n            x += (c as i32) - 64;\n        }\n        for query in queries {\n            if query == name {\n                result += x * (i + 1);\n                break;\n            }\n        }\n    }\n    result\n}",
                "fn is_abundant(n: i32) -> bool {\n    if n < 12 {\n        return false;\n    }\n    let mut sum_divisors = 1;\n    for i in 2..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            sum_divisors += i;\n            if i!= n / i {\n                sum_divisors += n / i;\n            }\n        }\n    }\n    sum_divisors > n\n}\n\nfn non_abundant_sums(n: i32) -> i32 {\n    let mut abundants = Vec::new();\n    for i in 12..n {\n        if is_abundant(i) {\n            abundants.push(i);\n        }\n    }\n    let mut abundant_sums = HashMap::new();\n    for i in &abundants {\n        for j in &abundants {\n            abundant_sums.insert(i + j, true);\n        }\n    }\n    let mut result = 0;\n    for i in 0..n {\n        if!abundant_sums.contains_key(&i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn lexicographic_permutations(n: i32) -> String {\n    let mut result = String::new();\n    let mut digits = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut x = n - 1;\n    for i in 10..1 {\n        let mut fact = 1;\n        for j in 1..i {\n            fact *= j;\n        }\n        let idx = x / fact;\n        result.push_str(&digits[idx].to_string());\n        digits.remove(idx);\n        x -= idx * fact;\n    }\n    result\n}",
                "fn n_digit_fibonacci_number(n: i32) -> i32 {\n    let mut a = vec![1];\n    let mut b = vec![1];\n    let mut i = 2;\n    while b.len() < n {\n        let mut carry = 0;\n        let mut c = b.clone();\n        for j in 0..b.len() {\n            if j < a.len() {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if carry!= 0 {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    i\n}",
                "fn reciprocal_cycles(n: i32) -> i32 {\n    let mut result = 0;\n    let mut max_length = 0;\n    for i in 1..n {\n        let mut remainders = Vec::new();\n        let mut remainder = 1;\n        loop {\n            if remainder == 0 || remainders.contains(&remainder) {\n                break;\n            }\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = if remainder == 0 {\n            remainders.len() - remainders.iter().position(|&x| x == remainder).unwrap()\n        } else {\n            0\n        };\n        if length > max_length {\n            max_length = length;\n            result = i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn quadratic_primes(n: i32) -> i32 {\n    let mut max_primes = 0;\n    let mut result = 0;\n    for a in -n + 1..n {\n        for b in -n + 1..n {\n            let mut x = 0;\n            loop {\n                if x*x + a*x + b < 2 {\n                    break;\n                }\n                if!is_prime(x*x + a*x + b) {\n                    break;\n                }\n                x += 1;\n            }\n            if x > max_primes {\n                max_primes = x;\n                result = a * b;\n            }\n        }\n    }\n    result\n}",
                "fn number_spiral_diagonals(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 3..=n {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    result\n}",
                "fn distinct_powers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut xs = HashMap::new();\n    for i in 2..n+1 {\n        let mut primes = vec![2, 3, 5, 7];\n        let mut powers = vec![0, 0, 0, 0];\n        let mut num = i;\n        for j in 0..primes.len() {\n            while num % primes[j] == 0 {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if num!= 1 {\n            result += n - 1;\n            continue;\n        }\n        for j in 2..n+1 {\n            let pstr = format!(\"{}-{}-{}-{}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n            xs.insert(pstr, true);\n        }\n    }\n    result += xs.len() as i32;\n    result\n}",
                "fn digit_nth_powers(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 2..4 * (10 as f64).powi(n) as i32 {\n        let mut digits_sum = 0;\n        for digit in i.to_string().chars() {\n            digits_sum += (digit as i32).pow(n);\n        }\n        if i == digits_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn coin_sums(n: i32) -> i32 {\n    let coins = vec![1, 2, 5, 10, 20, 50, 100, 200];\n    let mut ways = vec![1; n as usize + 1];\n    for coin in coins {\n        for i in coin..=n {\n            ways[i as usize] += ways[(i - coin) as usize];\n        }\n    }\n    ways[n as usize]\n}",
                "fn pandigital_products(n: i32) -> i32 {\n    let mut products = HashMap::new();\n    let mut s = String::new();\n    for i in 1..=n {\n        s.push_str(&i.to_string());\n    }\n    for a in 1..100 {\n        for b in 1..10000 {\n            let c = a * b;\n            let chars: Vec<char> = s.chars().collect();\n            chars.sort();\n            if chars.iter().collect::<String>() == s {\n                products.insert(c, true);\n            }\n        }\n    }\n    let mut result = 0;\n    for product in products.keys() {\n        result += product;\n    }\n    result\n}",
                "fn digit_canceling_fractions(m: i32) -> i32 {\n    let mut numer = 1;\n    let mut denom = 1;\n    for d in 10..m {\n        for n in 10..d {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let mut a = numer;\n    let mut b = denom;\n    while b!= 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    denom / a\n}",
                "fn digit_factorials(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 3..n {\n        let mut fact_sum = 0;\n        for digit in i.to_string().chars() {\n            let mut fact = 1;\n            for j in 1..=digit.to_digit(10).unwrap() {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if i == fact_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn circular_primes(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 2..n {\n        if is_prime(i) {\n            let mut rotations = HashMap::new();\n            let str = i.to_string();\n            for j in 0..str.len() {\n                let x = str[j..].to_string() + &str[..j];\n                rotations.insert(x.parse::<i32>().unwrap(), ());\n            }\n            let mut flag = true;\n            for x in rotations.keys() {\n                if!is_prime(*x) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
                "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s[i]!= s[s.len() - i - 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn double_base_palindromes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 1..n {\n        let str_i = i.to_string();\n        let bin_i = format!(\"{:b}\", i);\n        if is_palindrome(&str_i) && is_palindrome(&bin_i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn truncatable_primes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 10..n {\n        if is_prime(i) {\n            let si = i.to_string();\n            let mut flag = true;\n            for j in 1..si.len() {\n                let p1 = si[j..].parse::<i32>().unwrap();\n                let p2 = si[..si.len() - j].parse::<i32>().unwrap();\n                if!is_prime(p1) ||!is_prime(p2) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                result += i;\n            }\n        }\n    }\n    result\n}",
                "fn pandigital_multiples(n: i32) -> i32 {\n    let mut result = -1;\n    for i in 2..n+1 {\n        let mut cprod = String::new();\n        for j in 1..10 {\n            cprod.push_str(&i.to_string() * &j.to_string());\n            if cprod.len() == 9 {\n                let chars: Vec<char> = cprod.chars().collect();\n                chars.sort();\n                if chars.iter().collect::<String>() == \"123456789\" {\n                    result = max(result, cprod.parse::<i32>().unwrap());\n                    break;\n                }\n            } else if cprod.len() > 9 {\n                break;\n            }\n        }\n    }\n    result\n}",
                "fn integer_right_triangles(n: i32) -> i32 {\n    let mut max_sol = 0;\n    let mut result = 0;\n    for p in 3..n + 1 {\n        let mut sol = 0;\n        for a in 1..(p / 2) + 1 {\n            for b in a..(p / 2) + 1 {\n                let c = p - a - b;\n                if a * a + b * b == c * c {\n                    sol += 1;\n                }\n            }\n        }\n        if sol > max_sol {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    result\n}",
                "fn champernowne_constant(b: i32) -> i32 {\n    let mut s = String::new();\n    for i in 1..(b as f64).powi(6) as i32 {\n        s.push_str(&i.to_string());\n    }\n    let mut result = 1;\n    for i in 0..7 {\n        result *= s[((b as f64).powi(i) - 1) as usize].parse::<i32>().unwrap();\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn pandigital_prime(n: i32) -> i32 {\n    for i in (n - 1)..1 {\n        if is_prime(i) {\n            let si = i.to_string();\n            let length = si.len();\n            let mut flag = true;\n            for j in 1..length + 1 {\n                if!si.contains(&j.to_string()) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                return i;\n            }\n        }\n    }\n    -1\n}",
                "fn coded_triangle_numbers(words: &Vec<String>) -> i32 {\n    let mut result = 0;\n    for word in words {\n        let mut value = 0;\n        for c in word.chars() {\n            value += c as i32 - 64;\n        }\n        let n = (value as f64).sqrt() as i32;\n        if n * (n + 1) == value * 2 {\n            result += 1;\n        }\n    }\n    result\n}",
                "fn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.to_string()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1].to_string() + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn sub_string_divisibility(n: i32) -> i32 {\n    let mut result = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut s = String::new();\n    for i in 0..=n {\n        s.push_str(&i.to_string());\n    }\n    for i in gen_permutations(&s) {\n        let mut flag = true;\n        for j in 1..n - 1 {\n            if let Ok(n) = i[j..j + 3].parse::<i32>() {\n                if n % primes[j - 1]!= 0 {\n                    flag = false;\n                    break;\n                }\n            } else {\n                flag = false;\n                break;\n            }\n        }\n        if flag {\n            if let Ok(s0) = i.parse::<i32>() {\n                result += s0;\n            }\n        }\n    }\n    result\n}",
                "fn pentagon_numbers(n: i32) -> i32 {\n    let mut pentagon = HashMap::new();\n    for i in 1..n {\n        pentagon.insert(i * (3 * i - 1) / 2, true);\n    }\n    let mut result = -1;\n    for j in pentagon.keys() {\n        for k in pentagon.keys() {\n            if pentagon.get(j + k).unwrap() && pentagon.get(k - j).unwrap() {\n                if result == -1 || k - j < result {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn triangular_pentagonal_and_hexagonal(n: i32) -> i32 {\n    let mut ps = HashMap::new();\n    let mut i = 1;\n    let mut c = (i as f64 * (3.0 * i as f64 - 1.0)) as i32;\n    while c < n {\n        i += 1;\n        ps.insert(c, true);\n        c = (i as f64 * (3.0 * i as f64 - 1.0)) as i32;\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let mut result = -1;\n    while c < n {\n        i += 1;\n        if ps.contains_key(&c) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn goldbachs_other_conjecture(n: i32) -> i32 {\n    let mut result = -1;\n    for i in 9999..n {\n        let upper = (i as f64).sqrt() as i32;\n        let mut flag = false;\n        for j in 0..upper {\n            if is_prime(i - 2 * j * j) {\n                flag = true;\n                break;\n            }\n        }\n        if!flag {\n            result = i;\n        }\n    }\n    result\n}",
                "fn prime_factors(n: i32) -> i32 {\n    let mut num = n;\n    let mut factors = Vec::new();\n    let mut i = 2;\n    while i * i <= num {\n        if num % i!= 0 {\n            i += 1;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if num > 1 {\n        factors.push(num);\n    }\n    let mut s = std::collections::HashMap::new();\n    for v in factors {\n        s.insert(v, true);\n    }\n    s.len() as i32\n}\n\nfn distinct_primes_factors(n: i32) -> i32 {\n    for i in n..1000000 {\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4 {\n            return i;\n        }\n    }\n    -1\n}",
                "fn self_powers(n: i32) -> String {\n    let mut digits = [0; 10];\n    for i in 1..=n {\n        let mut temp_digits = [0; 10];\n        temp_digits[0] = 1;\n        for j in 0..i {\n            let mut carry = 0;\n            for k in 0..10 {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for j in 0..10 {\n            digits[j] += temp_digits[j];\n            if digits[j] >= 10 {\n                digits[j] -= 10;\n                if j < 9 {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let mut result = String::new();\n    for i in (0..10).rev() {\n        result.push_str(&digits[i].to_string());\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.clone()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn prime_permutations(n: i32) -> String {\n    for i in n..1000 {\n        if is_prime(i) {\n            for perm in gen_permutations(&i.to_string()) {\n                let candidate = perm.parse::<i32>().unwrap();\n                if candidate > i && is_prime(candidate) {\n                    if let Some(m) = candidates.get(&(candidate - i)) {\n                        if candidates.contains_key(&(m + (m - i))) {\n                            return i.to_string() + &candidate.to_string() + &(m + (m - i)).to_string();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let mut candidates = HashMap::new();\n    for i in 1000..10000 {\n        if is_prime(i) {\n            for perm in gen_permutations(&i.to_string()) {\n                let candidate = perm.parse::<i32>().unwrap();\n                if candidate > i && is_prime(candidate) {\n                    candidates.insert(candidate - i, candidate);\n                }\n            }\n        }\n    }\n    println!(\"{}\", prime_permutations(9999));\n}",
                "fn consecutive_prime_sum(limit: i32) -> i32 {\n    let mut sieve = vec![true; limit as usize];\n    let mut primes = Vec::new();\n    for i in 2..limit {\n        if sieve[i as usize] {\n            primes.push(i);\n            for j in (i * 2)..limit {\n                sieve[j as usize] = false;\n            }\n        }\n    }\n    let mut maxLength = 0;\n    let mut maxPrime = 0;\n    for i in 0..primes.len() {\n        for j in i + maxLength..primes.len() {\n            let mut s = 0;\n            for k in i..j {\n                s += primes[k];\n            }\n            if s >= limit {\n                break;\n            }\n            if sieve[s as usize] && j - i > maxLength {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    maxPrime\n}"
            ],
            "scala": [
                "def multiplesOf3And5(n: Int): Int = {\n  var result = 0\n  for (i <- 0 until n) {\n    if (i % 3 == 0 || i % 5 == 0) {\n      result += i\n    }\n  }\n  result\n}",
                "def evenFibonacciNumbers(n: Int): Int = {\n  var result = 0\n  var a = 1\n  var b = 2\n  while (a < n) {\n    if (a % 2 == 0) {\n      result += a\n    }\n    val tmp = a\n    a = b\n    b = tmp + b\n  }\n  result\n}",
                "def largestPrimeFactor(n: Int): Int = {\n  var result = n\n  var i = 2\n  while (i * i <= result) {\n    if (result % i!= 0) {\n      i += 1\n    } else {\n      result /= i\n    }\n  }\n  result\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i)!= s(s.length - i - 1)) {\n      return false\n    }\n  }\n  true\n}\n\ndef largestPalindromeProduct(n: Int): Int = {\n  var result = 0\n  for (i <- 100 until 1000; j <- i until 1000) {\n    val prod = i * j\n    if (isPalindrome(prod.toString) && prod > result && prod < n) {\n      result = prod\n    }\n  }\n  result\n}",
                "def smallestMultiple(n: Int): Int = {\n  var result = 1\n  for (i <- 1 to n) {\n    if (result % i!= 0) {\n      for (j <- 1 to n) {\n        if (result * j) % i == 0 {\n          result *= j\n          break\n        }\n      }\n    }\n  }\n  result\n}",
                "def sumSquareDifference(n: Int): Int = {\n  var sqrSum = 0\n  var numSum = 0\n  for (i <- 1 to n) {\n    sqrSum += i * i\n    numSum += i\n  }\n  numSum * numSum - sqrSum\n}",
                "def nthPrime(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (primes.length < n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  primes(primes.length - 1)\n}",
                "def largestProductInASeries(s: String, k: Int): Int = {\n  var result = 0\n  for (i <- 0 until s.length - k) {\n    var product = 1\n    for (j <- 0 until k) {\n      product *= s(i + j) - '0'\n    }\n    result = math.max(result, product)\n  }\n  result\n}",
                "def specialPythagoreanTriplet(n: Int): Int = {\n  for (a <- 1 until n) {\n    for (b <- a until n) {\n      val c = n - a - b\n      if (a * a + b * b == c * c) {\n        return a * b * c\n      }\n    }\n  }\n  -1\n}",
                "def summationOfPrimes(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (i <= n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  var result = 0\n  for (prime <- primes) {\n    result += prime\n  }\n  result\n}",
                "def largestProductInAGrid(grid: collection.Seq[collection.Seq[Int]]): Int = {\n  var result = 0\n  for (i <- 0 until grid.length - 3) {\n    for (j <- 0 until grid(i).length - 3) {\n      val p1 = grid(i)(j) * grid(i + 1)(j) * grid(i + 2)(j) * grid(i + 3)(j)\n      val p2 = grid(i)(j) * grid(i)(j + 1) * grid(i)(j + 2) * grid(i)(j + 3)\n      val p3 = grid(i)(j) * grid(i + 1)(j + 1) * grid(i + 2)(j + 2) * grid(i + 3)(j + 3)\n      val p4 = grid(i)(j) * grid(i + 1)(j + 2) * grid(i + 2)(j + 1) * grid(i + 3)(j)\n      result = math.max(result, p1, p2, p3, p4)\n    }\n  }\n  result\n}",
                "def highlyDivisibleTriangularNumber(n: Int): Int = {\n  for (i <- 1 to 100000000) {\n    val result = i * (i + 1) / 2\n    var count = 0\n    for (j <- 1 to math.sqrt(result).toInt) {\n      if (result % j == 0) {\n        count += 2\n      }\n      if (j * j == result) {\n        count -= 1\n      }\n    }\n    if (count > n) {\n      return result\n    }\n  }\n  -1\n}",
                "def largeSum(numbers: collection.Seq[String]): String = {\n  val digits = new Array[Int](60)\n  for (i <- 0 until 50) {\n    var tmp = 0\n    for (num <- numbers) {\n      tmp += num(49 - i) - '0'\n    }\n    for (j <- i until 60) {\n      digits(j) += tmp % 10\n      if digits(j) >= 10 {\n        digits(j + 1) += digits(j) / 10\n        digits(j) %= 10\n      }\n      tmp /= 10\n      if tmp == 0 {\n        break\n      }\n    }\n  }\n  for (i <- 59 to 0 by -1) {\n    if digits(i)!= 0 {\n      var result = \"\"\n      for (j <- i to i - 10 by -1) {\n        result += digits(j).toString\n      }\n      return result\n    }\n  }\n  \"\"\n}",
                "def longestCollatzSequence(n: Int): Int = {\n  var longest = 0\n  var result = 0\n  for (i <- 1 until n) {\n    var chain = 1\n    var num = i\n    while (num!= 1) {\n      if (num % 2 == 0) {\n        num = num / 2\n      } else {\n        num = 3 * num + 1\n      }\n      chain += 1\n    }\n    if (chain > longest) {\n      longest = chain\n      result = i\n    }\n  }\n  result\n}",
                "def latticePaths(m: Int, n: Int): Int = {\n  val grid = Array.ofDim[Int](m + 1, n + 1)\n  for (i <- 0 to m) {\n    grid(i)(0) = 1\n  }\n  for (j <- 0 to n) {\n    grid(0)(j) = 1\n  }\n  for (i <- 1 to m) {\n    for (j <- 1 to n) {\n      grid(i)(j) = grid(i - 1)(j) + grid(i)(j - 1)\n    }\n  }\n  grid(m)(n)\n}",
                "def powerDigitSum(n: Int): Int = {\n  val digits = collection.mutable.ArrayBuffer[Int](2)\n  for (i <- 1 until n) {\n    var carry = 0\n    for (j <- 0 until digits.length) {\n      val temp = digits(j) * 2 + carry\n      digits(j) = temp % 10\n      carry = temp / 10\n    }\n    if (carry!= 0) {\n      digits += carry\n    }\n  }\n  var result = 0\n  for (digit <- digits) {\n    result += digit\n  }\n  result\n}",
                "def numberToWords(n: Int): String = {\n  val ones = Array(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n  val teens = Array(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n  val tens = Array(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n  if (n == 1000) {\n    \"one thousand\"\n  } else if (n >= 100) {\n    if (n % 100 == 0) {\n      ones(n / 100) + \" hundred\"\n    } else {\n      ones(n / 100) + \" hundred and \" + numberToWords(n % 100)\n    }\n  } else if (n >= 20) {\n    var suf = \"\"\n    if (n % 10!= 0) {\n      suf = \" \" + ones(n % 10)\n    }\n    tens(n / 10) + suf\n  } else if (n >= 10) {\n    teens(n - 10)\n  } else {\n    ones(n)\n  }\n}",
                "def maximumPathSumI(triangle: collection.Seq[collection.Seq[Int]]): Int = {\n  val curr = collection.mutable.ArrayBuffer[Int]()\n  for (i <- triangle.last.indices) {\n    curr += triangle.last(i)\n  }\n  for (i <- (triangle.length - 2) to 0 by -1) {\n    val next = collection.mutable.ArrayBuffer[Int]()\n    for (j <- triangle(i).indices) {\n      next += triangle(i)(j) + math.max(curr(j), curr(j + 1)).toInt\n    }\n    curr = next\n  }\n  curr(0)\n}",
                "def countingSundays(y1: Int, y2: Int): Int = {\n  var day = 0\n  var count = 0\n  for (year <- 1900 to y2) {\n    for (month <- 1 to 12) {\n      if (year >= y1 && day % 7 == 6) {\n        count += 1\n      }\n      if (month == 4 || month == 6 || month == 9 || month == 11) {\n        day += 30\n      } else if (month == 2) {\n        if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n          day += 29\n        } else {\n          day += 28\n        }\n      } else {\n        day += 31\n      }\n    }\n  }\n  count\n}",
                "def factorialDigitSum(n: Int): Int = {\n  val digits = collection.mutable.ArrayBuffer[Int](1)\n  for (i <- 1 to n) {\n    var carry = 0\n    for (j <- 0 until digits.length) {\n      digits(j) = digits(j) * i + carry\n      carry = digits(j) / 10\n      digits(j) %= 10\n    }\n    while (carry!= 0) {\n      digits += carry % 10\n      carry /= 10\n    }\n  }\n  digits.sum\n}",
                "def d(n: Int): Int = {\n  var result = 1\n  for (i <- 2 to math.sqrt(n).toInt) {\n    if (n % i == 0) {\n      result += i\n      if (i!= n / i) {\n        result += n / i\n      }\n    }\n  }\n  result\n}\n\ndef amicableNumbers(n: Int): Int = {\n  var result = 0\n  for (a <- 2 until n) {\n    val b = d(a)\n    if (a!= b && a == d(b)) {\n      result += a\n    }\n  }\n  result\n}",
                "def namesScores(names: collection.Seq[String], queries: collection.Seq[String]): Int = {\n  val sNames = names.clone()\n  sNames.sortWith(_ < _)\n  var result = 0\n  for (i <- 0 until sNames.length) {\n    var x = 0\n    for (c <- sNames(i)) {\n      x += c - 64\n    }\n    for (query <- queries) {\n      if (query == sNames(i)) {\n        result += x * (i + 1)\n        break\n      }\n    }\n  }\n  result\n}",
                "def isAbundant(n: Int): Boolean = {\n  if (n < 12) {\n    false\n  } else {\n    var sumDivisors = 1\n    for (i <- 2 to math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        sumDivisors += i\n        if (i!= n / i) {\n          sumDivisors += n / i\n        }\n      }\n    }\n    sumDivisors > n\n  }\n}\n\ndef nonAbundantSums(n: Int): Int = {\n  val abundants = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 12 until n) {\n    if (isAbundant(i)) {\n      abundants += i\n    }\n  }\n  val abundantSums = collection.mutable.Map[Int, Boolean]()\n  for (i <- abundants) {\n    for (j <- abundants) {\n      abundantSums(i + j) = true\n    }\n  }\n  var result = 0\n  for (i <- 0 until n) {\n    if (!abundantSums(i)) {\n      result += i\n    }\n  }\n  result\n}",
                "def lexicographicPermutations(n: Int): String = {\n  val result = new StringBuilder()\n  val digits = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n  var x = n - 1\n  for (i <- 10 to 1 by -1) {\n    var fact = 1\n    for (j <- 1 to i - 1) {\n      fact *= j\n    }\n    val idx = x / fact\n    result.append(digits(idx))\n    digits.remove(idx)\n    x -= idx * fact\n  }\n  result.toString\n}",
                "def nDigitFibonacciNumber(n: Int): Int = {\n  var a = collection.mutable.ArrayBuffer[Int](1)\n  var b = collection.mutable.ArrayBuffer[Int](1)\n  var i = 2\n  while (b.length < n) {\n    var carry = 0\n    val c = b.clone()\n    for (j <- 0 until b.length) {\n      if (j < a.length) {\n        b(j) = a(j) + b(j) + carry\n      } else {\n        b(j) = b(j) + carry\n      }\n      carry = b(j) / 10\n      b(j) = b(j) % 10\n    }\n    if (carry!= 0) {\n      b += carry\n    }\n    a = c.clone()\n    i = i + 1\n  }\n  i\n}",
                "def reciprocalCycles(n: Int): Int = {\n  var result = 0\n  var maxLength = 0\n  for (i <- 1 until n) {\n    var remainders = collection.mutable.ArrayBuffer[Int]()\n    var remainder = 1\n    while (remainder!= 0 &&!remainders.contains(remainder)) {\n      remainders += remainder\n      remainder = (remainder * 10) % i\n    }\n    var length = 0\n    if (remainder!= 0) {\n      length = remainders.length - remainders.indexOf(remainder)\n    }\n    if (length > maxLength) {\n      maxLength = length\n      result = i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef quadraticPrimes(n: Int): Int = {\n  var maxPrimes = 0\n  var result = 0\n  for (a <- -n + 1 until n by 2) {\n    for (b <- -n + 1 until n by 2) {\n      var x = 0\n      while (true) {\n        if (x * x + a * x + b < 2) {\n          break\n        }\n        if (!isPrime(x * x + a * x + b)) {\n          break\n        }\n        x += 1\n      }\n      if (x > maxPrimes) {\n        maxPrimes = x\n        result = a * b\n      }\n    }\n  }\n  result\n}",
                "def numberSpiralDiagonals(n: Int): Int = {\n  var result = 1\n  for (i <- 3 to n by 2) {\n    result += 4 * i * i - 6 * i + 6\n  }\n  result\n}",
                "def distinctPowers(n: Int): Int = {\n  var result = 0\n  val xs = collection.mutable.Map[String, Boolean]()\n  for (i <- 2 to n) {\n    val primes = Array(2, 3, 5, 7)\n    val powers = Array(0, 0, 0, 0)\n    var num = i\n    for (j <- 0 until primes.length) {\n      while (num % primes(j) == 0) {\n        num /= primes(j)\n        powers(j) += 1\n      }\n    }\n    if (num!= 1) {\n      result += n - 1\n      continue\n    }\n    for (j <- 2 to n) {\n      val pstr = s\"${powers(0) * j}-${powers(1) * j}-${powers(2) * j}-${powers(3) * j}\"\n      xs(pstr) = true\n    }\n  }\n  result += xs.size\n  result\n}",
                "def digitNthPowers(n: Int): Int = {\n  var result = 0\n  for (i <- 2 until 4 * math.pow(10, n).toInt) {\n    var digitsSum = 0\n    for (digit <- i.toString) {\n      digitsSum += math.pow(digit.asDigit, n).toInt\n    }\n    if (i == digitsSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def coinSums(n: Int): Int = {\n  val coins = Array(1, 2, 5, 10, 20, 50, 100, 200)\n  val ways = Array.fill(n + 1)(0)\n  ways(0) = 1\n  for (coin <- coins) {\n    for (i <- coin to n) {\n      ways(i) += ways(i - coin)\n    }\n  }\n  ways(n)\n}",
                "def pandigitalProducts(n: Int): Int = {\n  val products = collection.mutable.Map[Int, Boolean]()\n  var s = \"\"\n  for (i <- 1 to n) {\n    s += i.toString\n  }\n  for (a <- 1 to 99) {\n    for (b <- 1 to 9999) {\n      val c = a * b\n      val chars = collection.mutable.ArrayBuffer[Char]()\n      chars ++= a.toString.toCharArray\n      chars ++= b.toString.toCharArray\n      chars ++= c.toString.toCharArray\n      chars.sortWith(_ < _)\n      if (chars.mkString == s) {\n        products(c) = true\n      }\n    }\n  }\n  var result = 0\n  for (product <- products) {\n    result += product\n  }\n  result\n}",
                "def digitCancelingFractions(m: Int): Int = {\n  var numer = 1\n  var denom = 1\n  for (d <- 10 until m) {\n    for (n <- 10 until d) {\n      val n0 = n % 10\n      val n1 = n / 10\n      val d0 = d % 10\n      val d1 = d / 10\n      if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n        numer *= n\n        denom *= d\n      }\n    }\n  }\n  var a = numer\n  var b = denom\n  while (b!= 0) {\n    val temp = b\n    b = a % b\n    a = temp\n  }\n  denom / a\n}",
                "def digitFactorials(n: Int): Int = {\n  var result = 0\n  for (i <- 3 until n) {\n    var factSum = 0\n    for (digit <- i.toString) {\n      var fact = 1\n      for (j <- 1 to digit.asDigit) {\n        fact *= j\n      }\n      factSum += fact\n    }\n    if (i == factSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef circularPrimes(n: Int): Int = {\n  var count = 0\n  for (i <- 2 until n) {\n    if (isPrime(i)) {\n      val rotations = scala.collection.mutable.Map[Int, Unit]()\n      val str = i.toString\n      for (j <- 0 until str.length) {\n        val x = str.substring(j) + str.substring(0, j)\n        rotations(x.toInt) = ()\n      }\n      var flag = true\n      for (x <- rotations.keys) {\n        if (!isPrime(x)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        count += 1\n      }\n    }\n  }\n  count\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i)!= s(s.length - i - 1)) {\n      return false\n    }\n  }\n  true\n}\n\ndef doubleBasePalindromes(n: Int): Int = {\n  var result = 0\n  for (i <- 1 until n) {\n    val strI = i.toString\n    val binI = java.lang.Long.toBinaryString(i)\n    if (isPalindrome(strI) && isPalindrome(binI)) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef truncatablePrimes(n: Int): Int = {\n  var result = 0\n  for (i <- 10 until n) {\n    if (isPrime(i)) {\n      val si = i.toString\n      var flag = true\n      for (j <- 1 until si.length) {\n        val p1 = si.substring(j).toInt\n        val p2 = si.substring(0, si.length - j).toInt\n        if (!isPrime(p1) ||!isPrime(p2)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        result += i\n      }\n    }\n  }\n  result\n}",
                "def pandigitalMultiples(n: Int): Int = {\n  var result = -1\n  for (i <- 2 to n) {\n    var cprod = \"\"\n    for (j <- 1 to 9) {\n      cprod += (i * j).toString\n      if (cprod.length == 9) {\n        val chars = cprod.split(\"\")\n        chars.sortWith(_ < _)\n        if (chars.mkString(\"\") == \"123456789\") {\n          result = math.max(result, cprod.toInt)\n          break\n        }\n      } else if (cprod.length > 9) {\n        break\n      }\n    }\n  }\n  result\n}",
                "def integerRightTriangles(n: Int): Int = {\n  var maxSol = 0\n  var result = 0\n  for (p <- 3 to n) {\n    var sol = 0\n    for (a <- 1 until p / 2) {\n      for (b <- a until p / 2) {\n        val c = p - a - b\n        if a * a + b * b == c * c {\n          sol += 1\n        }\n      }\n    }\n    if sol > maxSol {\n      maxSol = sol\n      result = p\n    }\n  }\n  result\n}",
                "def champernowneConstant(b: Int): Int = {\n  var s = \"\"\n  for (i <- 1 until math.pow(b, 6).toInt) {\n    s += i.toString\n  }\n  var result = 1\n  for (i <- 0 until 7) {\n    result *= s(math.pow(b, i).toInt - 1).toString.toInt\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef pandigitalPrime(n: Int): Int = {\n  var i = n - 1\n  while (i > 0) {\n    if (isPrime(i)) {\n      val si = i.toString\n      val length = si.length\n      var flag = true\n      for (j <- 1 to length) {\n        if (!si.contains(j.toString)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        return i\n      }\n    }\n    i -= 1\n  }\n  -1\n}",
                "def codedTriangleNumbers(words: collection.Seq[String]): Int = {\n  var result = 0\n  for (word <- words) {\n    var value = 0\n    for (c <- word) {\n      value += c - 'A' + 1\n    }\n    val n = math.sqrt(value * 2).toInt\n    if (n * (n + 1) == value * 2) {\n      result += 1\n    }\n  }\n  result\n}",
                "def genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    return Seq(s)\n  }\n  val result = collection.mutable.ArrayBuffer[String]()\n  for (perm <- genPermutations(s.substring(1))) {\n    for (i <- 0 until s.length) {\n      result += perm.substring(0, i) + s(0) + perm.substring(i)\n    }\n  }\n  result\n}\n\ndef subStringDivisibility(n: Int): Int = {\n  var result = 0\n  val primes = Seq(2, 3, 5, 7, 11, 13, 17)\n  var s = \"\"\n  for (i <- 0 to n) {\n    s += i.toString\n  }\n  for (i <- genPermutations(s)) {\n    var flag = true\n    for (j <- 1 until n - 1) {\n      if (n, _) = i.substring(j, j + 3).toInt; n % primes(j - 1)!= 0 {\n        flag = false\n        break\n      }\n    }\n    if (flag) {\n      s0, _ = i.toInt\n      result += s0\n    }\n  }\n  result\n}",
                "def pentagonNumbers(n: Int): Int = {\n  val pentagon = collection.mutable.Map[Int, Boolean]()\n  for (i <- 1 until n) {\n    pentagon(i * (3 * i - 1) / 2) = true\n  }\n  var result = -1\n  for (j <- pentagon.keys) {\n    for (k <- pentagon.keys) {\n      if pentagon(j + k) && pentagon(k - j) {\n        if (result == -1 || k - j < result) {\n          result = k - j\n        }\n      }\n    }\n  }\n  result\n}",
                "def triangularPentagonalAndHexagonal(n: Int): Int = {\n  val ps = collection.mutable.Map[Int, Boolean]()\n  var i = 1\n  var c = (i * (3 * i - 1)) / 2\n  while (c < n) {\n    i += 1\n    ps(c) = true\n    c = (i * (3 * i - 1)) / 2\n  }\n  i = 1\n  c = i * (2 * i - 1)\n  var result = -1\n  while (c < n) {\n    i += 1\n    if (ps(c)) {\n      result = c\n    }\n    c = i * (2 * i - 1)\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef goldbachsOtherConjecture(n: Int): Int = {\n  var result = -1\n  for (i <- 9999 to n by -2) {\n    val upper = math.sqrt(i / 2).toInt\n    var flag = false\n    for (j <- 0 to upper) {\n      if (isPrime(i - 2 * j * j)) {\n        flag = true\n        break\n      }\n    }\n    if (!flag) {\n      result = i\n    }\n  }\n  result\n}",
                "def primeFactors(n: Int): Int = {\n  var num = n\n  var factors = collection.mutable.ArrayBuffer[Int]()\n  var i = 2\n  while (i * i <= num) {\n    if (num % i!= 0) {\n      i += 1\n    } else {\n      num /= i\n      factors += i\n    }\n  }\n  if (num > 1) {\n    factors += num\n  }\n  val s = collection.mutable.Map[Int, Boolean]()\n  for (v <- factors) {\n    s(v) = true\n  }\n  s.size\n}\n\ndef distinctPrimesFactors(n: Int): Int = {\n  for (i <- n until 1000000) {\n    if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n      return i\n    }\n  }\n  -1\n}",
                "def selfPowers(n: Int): String = {\n  val digits = Array.fill(10)(0)\n  for (i <- 1 to n) {\n    val tempDigits = Array.fill(10)(0)\n    tempDigits(0) = 1\n    for (j <- 0 until i) {\n      var carry = 0\n      for (k <- 0 until 10) {\n        tempDigits(k) = tempDigits(k) * i + carry\n        carry = tempDigits(k) / 10\n        tempDigits(k) %= 10\n      }\n    }\n    for (j <- 0 until 10) {\n      digits(j) += tempDigits(j)\n      if digits(j) >= 10 {\n        digits(j) -= 10\n        if j < 9 {\n          digits(j + 1) += 1\n        }\n      }\n    }\n  }\n  var result = \"\"\n  for (i <- 9 to 0 by -1) {\n    result += digits(i).toString\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n      if (n % i == 0) {\n        return false\n      }\n    }\n    true\n  }\n}\n\ndef genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    Seq(s)\n  } else {\n    val result = collection.mutable.ArrayBuffer[String]()\n    for (perm <- genPermutations(s.substring(1))) {\n      for (i <- 0 until s.length) {\n        result += perm.substring(0, i) + s.charAt(0) + perm.substring(i)\n      }\n    }\n    result\n  }\n}\n\ndef primePermutations(n: Int): String = {\n  for (i <- n to 999 by -1) {\n    if (isPrime(i)) {\n      val permutations = genPermutations(i.toString)\n      val candidates = collection.mutable.Map[Int, Boolean]()\n      for (j <- permutations) {\n        val candidate = j.toInt\n        if (candidate > i && isPrime(candidate)) {\n          candidates(candidate) = true\n        }\n      }\n      for (m <- candidates.keys) {\n        if (candidates(m + (m - i))) {\n          return i.toString + m.toString + (m + (m - i)).toString\n        }\n      }\n    }\n  }\n  \"\"\n}",
                "def consecutivePrimeSum(limit: Int): Int = {\n  val sieve = Array.fill(limit)(true)\n  for (i <- sieve.indices) {\n    sieve(i) = true\n  }\n  val primes = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 2 until limit) {\n    if (sieve(i)) {\n      primes += i\n      for (j <- i * 2 until limit by i) {\n        sieve(j) = false\n      }\n    }\n  }\n  var maxLength = 0\n  var maxPrime = 0\n  for (i <- 0 until primes.length) {\n    for (j <- i + maxLength until primes.length) {\n      var s = 0\n      for (k <- i until j) {\n        s += primes(k)\n      }\n      if (s >= limit) {\n        break\n      }\n      if (sieve(s) && j - i > maxLength) {\n        maxLength = j - i\n        maxPrime = s\n      }\n    }\n  }\n  maxPrime\n}"
            ]
        },
        "python": {
            "cpp": [
                "int multiplesOf3And5(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int evenFibonacciNumbers(int n) {\n    int result = 0;\n    int a = 1;\n    int b = 2;\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a;\n        }\n        int tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "int largestPrimeFactor(int n) {\n    int result = n;\n    int i = 2;\n    while (i * i <= result) {\n        if (result % i == 0) {\n            result /= i;\n        } else {\n            i += 1;\n        }\n    }\n    return result;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i]!= s[s.size() - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint largestPalindromeProduct(int n) {\n    int result = 0;\n    for (int i = 100; i < 1000; i++) {\n        for (int j = i; j < 1000; j++) {\n            int prod = i * j;\n            if (isPalindrome(to_string(prod)) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "int smallestMultiple(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        if (result % i!= 0) {\n            for (int j = 1; j <= n; j++) {\n                if ((result * j) % i == 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int sumSquareDifference(int n) {\n    int sqrSum = 0;\n    int numSum = 0;\n    for (int i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "int nthPrime(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (primes.size() < n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes.back();\n}",
                "int largestProductInASeries(const string& s, int k) {\n    int result = 0;\n    for (int i = 0; i < s.size() - k; i++) {\n        int product = 1;\n        for (int j = 0; j < k; j++) {\n            product *= s[i + j] - '0';\n        }\n        result = max(result, product);\n    }\n    return result;\n}",
                "int specialPythagoreanTriplet(int n) {\n    for (int a = 1; a < n; a++) {\n        for (int b = a; b < n; b++) {\n            int c = n - a - b;\n            if (a * a + b * b == c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "int summationOfPrimes(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (i <= n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    int result = 0;\n    for (int prime : primes) {\n        result += prime;\n    }\n    return result;\n}",
                "int largestProductInAGrid(const vector<vector<int>>& grid) {\n    int result = 0;\n    for (int i = 0; i < grid.size() - 3; i++) {\n        for (int j = 0; j < grid[i].size() - 3; j++) {\n            int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (int k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (int k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "int highlyDivisibleTriangularNumber(int n) {\n    for (int i = 1; i < 100000000; i++) {\n        int result = i * (i + 1) / 2;\n        int count = 0;\n        for (int j = 1; j <= sqrt(result); j++) {\n            if (result % j == 0) {\n                count += 2;\n            }\n            if (j * j == result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "string largeSum(const vector<string>& numbers) {\n    vector<int> digits(60, 0);\n    for (int i = 0; i < 50; i++) {\n        int tmp = 0;\n        for (const string& num : numbers) {\n            tmp += num[49 - i] - '0';\n        }\n        for (int j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if (tmp == 0) {\n                break;\n            }\n        }\n    }\n    for (int i = 59; i >= 0; i--) {\n        if (digits[i]!= 0) {\n            string result;\n            for (int j = i; j >= i - 10; j--) {\n                result += to_string(digits[j]);\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
                "int longestCollatzSequence(int n) {\n    int longest = 0;\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        int chain = 1;\n        int num = i;\n        while (num!= 1) {\n            if (num % 2 == 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "int latticePaths(int m, int n) {\n    vector<vector<int>> grid(m + 1, vector<int>(n + 1));\n    for (int i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (int j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "int powerDigitSum(int n) {\n    vector<int> digits = {2};\n    for (int i = 1; i < n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            int temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry) {\n            digits.push_back(carry);\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "string numberToWords(int n) {\n    vector<string> ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    vector<string> teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n    vector<string> tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        string suf = \"\";\n        if (n % 10!= 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "int maximumPathSumI(const vector<vector<int>>& triangle) {\n    vector<int> curr = triangle.back();\n    for (int i = triangle.size() - 2; i >= 0; i--) {\n        vector<int> next = triangle[i];\n        for (int j = 0; j < next.size(); j++) {\n            next[j] += max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "int countingSundays(int y1, int y2) {\n    int day = 0;\n    int count = 0;\n    for (int year = 1900; year <= y2; year++) {\n        for (int month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 == 6) {\n                count++;\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30;\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "int factorialDigitSum(int n) {\n    vector<int> digits = {1};\n    for (int i = 1; i <= n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while (carry) {\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
                "int d(int n) {\n    int result = 1;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            result += i;\n            if (i!= n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nint amicableNumbers(int n) {\n    int result = 0;\n    for (int a = 2; a < n; a++) {\n        int b = d(a);\n        if (a!= b && a == d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "int namesScores(const vector<string>& names, const vector<string>& queries) {\n    vector<string> s_names = names;\n    sort(s_names.begin(), s_names.end());\n    int result = 0;\n    for (int i = 0; i < s_names.size(); i++) {\n        int x = 0;\n        for (char c : s_names[i]) {\n            x += c - 'A' + 1;\n        }\n        if (find(queries.begin(), queries.end(), s_names[i])!= queries.end()) {\n            result += x * (i + 1);\n        }\n    }\n    return result;\n}",
                "bool isAbundant(int n) {\n    if (n < 12) {\n        return false;\n    }\n    int sumDivisors = 1;\n    for (int i = 2; i <= int(sqrt(n)); i++) {\n        if (n % i == 0) {\n            sumDivisors += i;\n            if (i!= n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nint nonAbundantSums(int n) {\n    vector<int> abundants;\n    for (int i = 12; i <= n; i++) {\n        if (isAbundant(i)) {\n            abundants.push_back(i);\n        }\n    }\n    set<int> abundantSums;\n    for (int i : abundants) {\n        for (int j : abundants) {\n            abundantSums.insert(i + j);\n        }\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (abundantSums.find(i) == abundantSums.end()) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "string lexicographicPermutations(int n) {\n    string result;\n    vector<int> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = n - 1;\n    for (int i = 10; i > 0; i--) {\n        int fact = 1;\n        for (int j = 1; j < i; j++) {\n            fact *= j;\n        }\n        int idx = x / fact;\n        result += to_string(digits[idx]);\n        digits.erase(digits.begin() + idx);\n        x -= idx * fact;\n    }\n    return result;\n}",
                "int nDigitFibonacciNumber(int n) {\n    vector<int> a = {1};\n    vector<int> b = {1};\n    int i = 2;\n    while (b.size() < n) {\n        int carry = 0;\n        vector<int> c = b;\n        for (int j = 0; j < b.size(); j++) {\n            if (j < a.size()) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry) {\n            b.push_back(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
                "int reciprocalCycles(int n) {\n    int result = 0;\n    int max_length = 0;\n    for (int i = 1; i < n; i++) {\n        vector<int> remainders;\n        int remainder = 1;\n        while (remainder!= 0 && remainders.end() == find(remainders.begin(), remainders.end(), remainder)) {\n            remainders.push_back(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        int length = 0;\n        if (remainder!= 0) {\n            length = remainders.size() - distance(remainders.begin(), find(remainders.begin(), remainders.end(), remainder));\n        }\n        if (length > max_length) {\n            max_length = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint quadraticPrimes(int n) {\n    int maxPrimes = 0;\n    int result = 0;\n    for (int a = -n + 1; a < n; a += 2) {\n        for (int b = -n + 1; b < n; b += 2) {\n            int x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x += 1;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "int numberSpiralDiagonals(int n) {\n    int result = 1;\n    for (int i = 3; i < n + 1; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "int distinctPowers(int n) {\n    int result = 0;\n    set<string> xs;\n    for (int i = 2; i <= n; i++) {\n        vector<int> primes = {2, 3, 5, 7};\n        vector<int> powers = {0, 0, 0, 0};\n        int num = i;\n        for (int j = 0; j < primes.size(); j++) {\n            while (num % primes[j] == 0) {\n                num /= primes[j];\n                powers[j]++;\n            }\n        }\n        if (num!= 1) {\n            result += n - 1;\n            continue;\n        }\n        for (int j = 2; j <= n; j++) {\n            string pstr = to_string(powers[0] * j) + \"-\" + to_string(powers[1] * j) + \"-\" + to_string(powers[2] * j) + \"-\" + to_string(powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.size();\n    return result;\n}",
                "int digitNthPowers(int n) {\n    int result = 0;\n    for (int i = 2; i < 4 * pow(10, n); i++) {\n        int digitsSum = 0;\n        for (char digit : to_string(i)) {\n            digitsSum += pow(digit - '0', n);\n        }\n        if (i == digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "int coinSums(int n) {\n    vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 200};\n    vector<int> ways(n + 1, 0);\n    ways[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "int pandigitalProducts(int n) {\n    set<int> products;\n    string s;\n    for (int i = 1; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (int a = 1; a < 100; a++) {\n        for (int b = 1; b < 10000; b++) {\n            int c = a * b;\n            string chars = to_string(a) + to_string(b) + to_string(c);\n            sort(chars.begin(), chars.end());\n            if (chars == s) {\n                products.insert(c);\n            }\n        }\n    }\n    int result = 0;\n    for (int product : products) {\n        result += product;\n    }\n    return result;\n}",
                "int digitCancelingFractions(int m) {\n    int numer = 1, denom = 1;\n    for (int d = 10; d < m; d++) {\n        for (int n = 10; n < d; n++) {\n            int n0 = n % 10, n1 = n / 10;\n            int d0 = d % 10, d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    int a = numer, b = denom;\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return denom / a;\n}",
                "int digitFactorials(int n) {\n    int result = 0;\n    for (int i = 3; i < n; i++) {\n        int factSum = 0;\n        for (char digit : to_string(i)) {\n            int fact = 1;\n            for (int j = 1; j < digit - '0' + 1; j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i == factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint circularPrimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            set<int> rotations;\n            for (int j = 0; j < int(log10(i)) + 1; j++) {\n                rotations.insert(stoi(to_string(i).substr(j) + to_string(i).substr(0, j)));\n            }\n            bool flag = true;\n            for (int x : rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
                "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i]!= s[s.size() - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint doubleBasePalindromes(int n) {\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        string str_i = to_string(i);\n        string bin_i = to_string(bitset<32>(i).to_string<char, string::traits_type, string::allocator_type>());\n        if (isPalindrome(str_i) && isPalindrome(bin_i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint truncatablePrimes(int n) {\n    int result = 0;\n    for (int i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            bool flag = true;\n            for (int j = 1; j < si.size(); j++) {\n                int p1 = stoi(si.substr(j));\n                int p2 = stoi(si.substr(0, j));\n                if (!isPrime(p1) ||!isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "int pandigitalMultiples(int n) {\n    int result = -1;\n    for (int i = 2; i <= n; i++) {\n        string cprod;\n        for (int j = 1; j <= 9; j++) {\n            cprod += to_string(i * j);\n            if (cprod.size() == 9) {\n                if (is_sorted(cprod)) {\n                    result = max(result, stoi(cprod));\n                    break;\n                }\n            } else if (cprod.size() > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "int integerRightTriangles(int n) {\n    int maxSol = 0;\n    int result = 0;\n    for (int p = 3; p <= n; p++) {\n        int sol = 0;\n        for (int a = 1; a < p / 2; a++) {\n            for (int b = a; b < p / 2; b++) {\n                int c = p - a - b;\n                if (a * a + b * b == c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "int champernowneConstant(int b) {\n    string s;\n    for (int i = 1; i < pow(b, 6); i++) {\n        s += to_string(i);\n    }\n    int result = 1;\n    for (int i = 7; i >= 0; i--) {\n        result *= stoi(s[pow(b, i) - 1]);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint pandigitalPrime(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            int length = si.size();\n            bool flag = true;\n            for (int j = 1; j <= length; j++) {\n                if (to_string(j)!= si.substr(j - 1, 1)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "int codedTriangleNumbers(const vector<string>& words) {\n    int result = 0;\n    for (const string& word : words) {\n        int value = 0;\n        for (char c : word) {\n            value += c - 'A' + 1;\n        }\n        int n = static_cast<int>(sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result += 1;\n        }\n    }\n    return result;\n}",
                "vector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s.substr(0, 1) + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nint subStringDivisibility(int n) {\n    int result = 0;\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17};\n    string s(n + 1, '0');\n    for (int i = 0; i <= n; i++) {\n        s[i] = i + '0';\n    }\n    for (const string& i : genPermutations(s)) {\n        bool flag = true;\n        for (int j = 1; j < n - 1; j++) {\n            if (stoi(i.substr(j, 3)) % primes[j - 1]!= 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += stoi(i);\n        }\n    }\n    return result;\n}",
                "int pentagonNumbers(int n) {\n    set<int> pentagon;\n    for (int i = 1; i < n; i++) {\n        pentagon.insert(i * (3 * i - 1) / 2);\n    }\n    int result = -1;\n    for (int j : pentagon) {\n        for (int k : pentagon) {\n            if (pentagon.count(j + k) && pentagon.count(k - j)) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "int triangularPentagonalAndHexagonal(int n) {\n    set<int> ps;\n    int i = 1;\n    int c = 0.5 * i * (3 * i - 1);\n    while (c < n) {\n        i += 1;\n        ps.insert(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    int result = -1;\n    while (c < n) {\n        i += 1;\n        if (ps.count(c)) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint goldbachsOtherConjecture(int n) {\n    int result = -1;\n    for (int i = 9999; i >= n; i -= 2) {\n        int upper = int(sqrt(i / 2));\n        bool flag = false;\n        for (int j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "int primeFactors(int n) {\n    int num = n;\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= num) {\n        if (num % i) {\n            i += 1;\n        } else {\n            num /= i;\n            factors.push_back(i);\n        }\n    }\n    if (num > 1) {\n        factors.push_back(num);\n    }\n    return factors.size();\n}\n\nint distinctPrimesFactors(int n) {\n    for (int i = n; i < 1000000; i++) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "string selfPowers(int n) {\n    vector<int> digits(10, 0);\n    digits[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        vector<int> temp_digits(10, 0);\n        temp_digits[0] = 1;\n        for (int j = 0; j < i; j++) {\n            int carry = 0;\n            for (int k = 0; k < 10; k++) {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for (int j = 0; j < 10; j++) {\n            digits[j] += temp_digits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    string result;\n    for (int i = 9; i >= 0; i--) {\n        result += to_string(digits[i]);\n    }\n    return result;\n}",
                "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s.substr(0, 1) + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nstring primePermutations(int n) {\n    for (int i = n; i >= 1000; i--) {\n        if (isPrime(i)) {\n            const vector<string>& permutations = genPermutations(to_string(i));\n            set<int> candidates;\n            for (const string& j : permutations) {\n                int candidate = stoi(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.insert(candidate);\n                }\n            }\n            for (int m : candidates) {\n                if (m + (m - i)!= 0 && m + (m - i) in candidates) {\n                    return to_string(i) + to_string(m) + to_string(m + (m - i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
                "int consecutivePrimeSum(int limit) {\n    vector<bool> sieve(limit, true);\n    vector<int> primes;\n    for (int i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n            for (int j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    int max_length = 0;\n    int max_prime = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i + max_length; j < primes.size(); j++) {\n            int s = 0;\n            for (int k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > max_length) {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    return max_prime;\n}"
            ],
            "csharp": [
                "class Global {\n    public static int MultiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int EvenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i == 0) {\n                result /= i;\n            } else {\n                i += 1;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i]!= s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int LargestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (IsPalindrome(prod.ToString()) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SmallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i!= 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int NthPrime(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (primes.Count < n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes[primes.Count - 1];\n    }\n}",
                "class Global {\n    public static int LargestProductInASeries(string s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.Length - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= int.Parse(s[i + j].ToString());\n            }\n            result = Math.Max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int SpecialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int SummationOfPrimes(int n) {\n        IList<int> primes = new List<int> { 2 };\n        int i = 3;\n        while (i <= n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        foreach (int prime in primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LargestProductInAGrid(IList<IList<int>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.Count - 3; i++) {\n            for (int j = 0; j < grid[i].Count - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid[i + k][j];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid[i][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid[i + k][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid[i + k][j + 3 - k];\n                }\n                result = Math.Max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int HighlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; int.Parse(Math.Sqrt(result).ToString()) + 1; j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string LargeSum(IList<string> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            foreach (string num in numbers) {\n                tmp += int.Parse(num[49 - i]);\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i]!= 0) {\n                string result = \"\";\n                for (int j = i; j >= i - 10; j--) {\n                    result += digits[j].ToString();\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int LongestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num!= 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain += 1;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int LatticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][n + 1];\n        for (int i = 0; i < m + 1; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j < n + 1; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i < m + 1; i++) {\n            for (int j = 1; j < n + 1; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int PowerDigitSum(int n) {\n        IList<int> digits = new List<int> { 2 };\n        for (int _ = 1; _ < n; _++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                int temp = digits[j] * 2 + carry;\n                digits[j] = temp % 10;\n                carry = temp / 10;\n            }\n            if (carry!= 0) {\n                digits.Add(carry);\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string NumberToWords(int n) {\n        string[] ones = new string[] { \"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\" };\n        string[] teens = new string[] { \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" };\n        string[] tens = new string[] { \"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            string suf = \"\";\n            if (n % 10!= 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int MaximumPathSumI(IList<IList<int>> triangle) {\n        IList<int> curr = triangle[triangle.Count - 1].ToList();\n        for (int i = triangle.Count - 2; i >= 0; i--) {\n            IList<int> next = triangle[i].ToList();\n            for (int j = 0; j < next.Count; j++) {\n                next[j] += Math.Max(curr[j], curr[j + 1]);\n            }\n            curr = next;\n        }\n        return curr[0];\n    }\n}",
                "class Global {\n    public static int CountingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count += 1;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int FactorialDigitSum(int n) {\n        IList<int> digits = new List<int>() { 1 };\n        for (int i = 1; i < n + 1; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                digits[j] = digits[j] * i + carry;\n                carry = digits[j] / 10;\n                digits[j] %= 10;\n            }\n            while (carry > 0) {\n                digits.Add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int D(int n) {\n        int result = 1;\n        for (int i = 2; i <= (int)Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i!= n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int AmicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = D(a);\n            if (a!= b && a == D(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NamesScores(IList<string> names, IList<string> queries) {\n        IList<string> s_names = names.OrderBy(x => x).ToList();\n        int result = 0;\n        for (int i = 0; i < s_names.Count; i++) {\n            int x = 0;\n            foreach (char c in s_names[i]) {\n                x += (int)c - 64;\n            }\n            if (s_names[i] == queries) {\n                result += x * (i + 1);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i < (int)Math.Sqrt(n) + 1; i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i!= n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int NonAbundantSums(int n) {\n        IList<int> abundants = new List<int>();\n        for (int i = 12; i < n; i++) {\n            if (IsAbundant(i)) {\n                abundants.Add(i);\n            }\n        }\n        ISet<int> abundantSums = new HashSet<int>();\n        foreach (int i in abundants) {\n            foreach (int j in abundants) {\n                abundantSums.Add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.Contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static string LexicographicPermutations(int n) {\n        string result = \"\";\n        IList<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += digits[idx].ToString();\n            digits.RemoveAt(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NDigitFibonacciNumber(int n) {\n        IList<int> a = new List<int> { 1 };\n        IList<int> b = new List<int> { 1 };\n        int i = 2;\n        while (b.Count < n) {\n            int carry = 0;\n            IList<int> c = b.ToList();\n            for (int j = 0; j < b.Count; j++) {\n                if (j < a.Count) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry > 0) {\n                b.Add(carry);\n            }\n            a = c;\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int ReciprocalCycles(int n) {\n        int result = 0;\n        int max_length = 0;\n        for (int i = 1; i < n; i++) {\n            IList<int> remainders = new List<int>();\n            int remainder = 1;\n            while (remainder!= 0 &&!remainders.Contains(remainder)) {\n                remainders.Add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder!= 0) {\n                length = remainders.Count - remainders.IndexOf(remainder);\n            }\n            if (length > max_length) {\n                max_length = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int QuadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!IsPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x += 1;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int NumberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i < n + 1; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DistinctPowers(int n) {\n        int result = 0;\n        HashSet<string> xs = new HashSet<string>();\n        for (int i = 2; i <= n; i++) {\n            int[] primes = { 2, 3, 5, 7 };\n            int[] powers = { 0, 0, 0, 0 };\n            int num = i;\n            for (int j = 0; j < primes.Length; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j]++;\n                }\n            }\n            if (num!= 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                string pstr = $\"{powers[0] * j}-{powers[1] * j}-{powers[2] * j}-{powers[3] * j}\";\n                xs.Add(pstr);\n            }\n        }\n        result += xs.Count;\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * 10 ** n; i++) {\n            int digitsSum = 0;\n            foreach (char digit in i.ToString()) {\n                digitsSum += int.Parse(digit.ToString()) ** n;\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int CoinSums(int n) {\n        int[] coins = new int[] { 1, 2, 5, 10, 20, 50, 100, 200 };\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        foreach (int coin in coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int PandigitalProducts(int n) {\n        ISet<int> products = new HashSet<int>();\n        string s = string.Join(\"\", Enumerable.Range(1, n + 1));\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                IList<char> chars = new List<char>(a.ToString() + b.ToString() + c.ToString());\n                chars.Sort();\n                if (string.Join(\"\", chars) == s) {\n                    products.Add(c);\n                }\n            }\n        }\n        int result = 0;\n        foreach (int product in products) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int DigitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b!= 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int DigitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            foreach (char digit in i.ToString()) {\n                int fact = 1;\n                for (int j = 1; j < int.Parse(digit.ToString()); j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int CircularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (IsPrime(i)) {\n                HashSet<int> rotations = new HashSet<int>();\n                for (int j = 0; j < str(i).Length; j++) {\n                    rotations.Add(int.Parse(str(i).Substring(j) + str(i).Substring(0, j)));\n                }\n                bool flag = true;\n                foreach (int x in rotations) {\n                    if (!IsPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count += 1;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i]!= s[s.Length - 1 - i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int DoubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            string str_i = i.ToString();\n            string bin_i = Convert.ToString(i, 2);\n            if (IsPalindrome(str_i) && IsPalindrome(bin_i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i < Math.Sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int TruncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                bool flag = true;\n                for (int j = 1; j < si.Length; j++) {\n                    int p1 = int.Parse(si.Substring(j));\n                    int p2 = int.Parse(si.Substring(0, si.Length - j));\n                    if (!IsPrime(p1) ||!IsPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            string cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += i * j;\n                if (cprod.Length == 9) {\n                    if (string.Join(\"\", cprod.OrderBy(c => c)) == \"123456789\") {\n                        result = Math.Max(result, int.Parse(cprod));\n                        break;\n                    }\n                } else if (cprod.Length > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int IntegerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol += 1;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int ChampernowneConstant(int b) {\n        string s = \"\";\n        for (int i = 1; i < b * b * b * b * b * b; i++) {\n            s += i.ToString();\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            result *= int.Parse(s[b * b * b * b * b * i]);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int PandigitalPrime(int n) {\n        for (int i = n - 1; i >= 0; i--) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                int length = si.Length;\n                bool flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (si.IndexOf(j.ToString()) == -1) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int CodedTriangleNumbers(IList<string> words) {\n        int result = 0;\n        foreach (string word in words) {\n            int value = 0;\n            foreach (char c in word) {\n                value += (int)c - 64;\n            }\n            int n = (int)Math.Sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return s;\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s.Substring(0, 1) + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int SubStringDivisibility(int n) {\n        int result = 0;\n        IList<int> primes = new List<int> { 2, 3, 5, 7, 11, 13, 17 };\n        string s = string.Join(\"\", Enumerable.Range(0, n + 1));\n        foreach (string i in GenPermutations(s)) {\n            bool flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (int.Parse(i.Substring(j, 3)) % primes[j - 1]!= 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += int.Parse(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PentagonNumbers(int n) {\n        ISet<int> pentagon = new HashSet<int>();\n        for (int i = 1; i < n; i++) {\n            pentagon.Add(i * (3 * i - 1) / 2);\n        }\n        int result = -1;\n        foreach (int j in pentagon) {\n            foreach (int k in pentagon) {\n                if (pentagon.Contains(j + k) && pentagon.Contains(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int TriangularPentagonalAndHexagonal(int n) {\n        HashSet<int> ps = new HashSet<int>();\n        int i = 1;\n        double c = 0.5 * i * (3 * i - 1);\n        while (c < n) {\n            i += 1;\n            ps.Add((int)c);\n            c = 0.5 * i * (3 * i - 1);\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i += 1;\n            if (ps.Contains(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i < int.Parse(Math.Sqrt(n).ToString()) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int GoldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i >= n; i -= 2) {\n            int upper = int.Parse(Math.Sqrt(i / 2).ToString());\n            bool flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (IsPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int PrimeFactors(int n) {\n        int num = n;\n        IList<int> factors = new List<int>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i == 0) {\n                num /= i;\n                factors.Add(i);\n            } else {\n                i += 1;\n            }\n        }\n        if (num > 1) {\n            factors.Add(num);\n        }\n        return factors.Distinct().Count();\n    }\n\n    public static int DistinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static string SelfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] temp_digits = new int[10];\n            temp_digits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    temp_digits[k] = temp_digits[k] * i + carry;\n                    carry = temp_digits[k] / 10;\n                    temp_digits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += temp_digits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        string result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += digits[i].ToString();\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i < Math.Sqrt(n) + 1; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return s;\n        }\n        IList<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s.Substring(0, 1) + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static string PrimePermutations(int n) {\n        for (int i = n; i >= 999; i -= 1) {\n            if (IsPrime(i)) {\n                IList<string> permutations = GenPermutations(i.ToString());\n                ISet<int> candidates = new HashSet<int>();\n                foreach (string j in permutations) {\n                    int candidate = int.Parse(j);\n                    if (candidate > i && IsPrime(candidate)) {\n                        candidates.Add(candidate);\n                    }\n                }\n                foreach (int m in candidates) {\n                    if (m + (m - i) in candidates) {\n                        return i.ToString() + m.ToString() + (m + (m - i)).ToString();\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int ConsecutivePrimeSum(int limit) {\n        bool[] sieve = new bool[limit];\n        IList<int> primes = new List<int>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.Add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int max_length = 0;\n        int max_prime = 0;\n        for (int i = 0; i < primes.Count; i++) {\n            for (int j = i + max_length; j < primes.Count; j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes[k];\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > max_length) {\n                    max_length = j - i;\n                    max_prime = s;\n                }\n            }\n        }\n        return max_prime;\n    }\n}"
            ],
            "go": [
                "func MultiplesOf3And5(n int) int {\n    result := 0\n    for i := 0; i < n; i++ {\n        if i%3 == 0 || i%5 == 0 {\n            result += i\n        }\n    }\n    return result\n}",
                "func EvenFibonacciNumbers(n int) int {\n    result := 0\n    a := 1\n    b := 2\n    for a < n {\n        if a%2 == 0 {\n            result += a\n        }\n        tmp := a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
                "func LargestPrimeFactor(n int) int {\n    result := n\n    i := 2\n    for i * i <= result {\n        if result % i == 0 {\n            result /= i\n        } else {\n            i++\n        }\n    }\n    return result\n}",
                "func IsPalindrome(s string) bool {\n    for i := 0; i < len(s) / 2; i++ {\n        if s[i]!= s[len(s) - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc LargestPalindromeProduct(n int) int {\n    result := 0\n    for i := 100; i < 1000; i++ {\n        for j := i; j < 1000; j++ {\n            prod := i * j\n            if IsPalindrome(strconv.Itoa(prod)) && prod > result && prod < n {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
                "func SmallestMultiple(n int) int {\n    result := 1\n    for i := 1; i <= n; i++ {\n        if result % i!= 0 {\n            for j := 1; j <= n; j++ {\n                if (result * j) % i == 0 {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
                "func SumSquareDifference(n int) int {\n    sqrSum := 0\n    numSum := 0\n    for i := 1; i <= n; i++ {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
                "func NthPrime(n int) int {\n    primes := []int{2}\n    i := 3\n    for len(primes) < n {\n        for _, p := range primes {\n            if i%p == 0 {\n                break\n            }\n            if p*p > i {\n                primes = append(primes, i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes[len(primes)-1]\n}",
                "func LargestProductInASeries(s string, k int) int {\n    result := 0\n    for i := 0; i < len(s) - k; i++ {\n        product := 1\n        for j := 0; j < k; j++ {\n            num, _ := strconv.Atoi(string(s[i + j]))\n            product *= num\n        }\n        result = max(result, product)\n    }\n    return result\n}",
                "func SpecialPythagoreanTriplet(n int) int {\n    for a := 1; a < n; a++ {\n        for b := a; b < n; b++ {\n            c := n - a - b\n            if a*a + b*b == c*c {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
                "func SummationOfPrimes(n int) int {\n    primes := []int{2}\n    i := 3\n    for i <= n {\n        for _, p := range primes {\n            if i%p == 0 {\n                break\n            }\n            if p*p > i {\n                primes = append(primes, i)\n                break\n            }\n        }\n        i += 2\n    }\n    result := 0\n    for _, prime := range primes {\n        result += prime\n    }\n    return result\n}",
                "func LargestProductInAGrid(grid [][]int) int {\n    result := 0\n    for i := 0; i < len(grid) - 3; i++ {\n        for j := 0; j < len(grid[i]) - 3; j++ {\n            p1, p2, p3, p4 := 1, 1, 1, 1\n            for k := 0; k < 4; k++ {\n                p1 *= grid[i + k][j]\n            }\n            for k := 0; k < 4; k++ {\n                p2 *= grid[i][j + k]\n            }\n            for k := 0; k < 4; k++ {\n                p3 *= grid[i + k][j + k]\n            }\n            for k := 0; k < 4; k++ {\n                p4 *= grid[i + k][j + 3 - k]\n            }\n            result = max(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
                "func HighlyDivisibleTriangularNumber(n int) int {\n    for i := 1; i < 100000000; i++ {\n        result := i * (i + 1) / 2\n        count := 0\n        for j := 1; int(math.Sqrt(float64(result))) >= j; j++ {\n            if result%j == 0 {\n                count += 2\n            }\n            if j*j == result {\n                count -= 1\n        }\n        if count > n {\n            return result\n        }\n    }\n    return -1\n}",
                "func LargeSum(numbers []string) string {\n    digits := make([]int, 60)\n    for i := 0; i < 50; i++ {\n        tmp := 0\n        for _, num := range numbers {\n            tmp += int(num[49 - i])\n        }\n        for j := i; j < 60; j++ {\n            digits[j] += tmp % 10\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if tmp == 0 {\n                break\n        }\n    }\n    for i := 59; i >= 0; i-- {\n        if digits[i]!= 0 {\n            result := \"\"\n            for j := i; j >= i - 10; j-- {\n                result += strconv.Itoa(digits[j])\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
                "func LongestCollatzSequence(n int) int {\n    longest := 0\n    result := 0\n    for i := 1; i < n; i++ {\n        chain := 1\n        num := i\n        for num!= 1 {\n            if num%2 == 0 {\n                num = num / 2\n            } else {\n                num = 3*num + 1\n            }\n            chain += 1\n        }\n        if chain > longest {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
                "func LatticePaths(m int, n int) int {\n    grid := make([][]int, m + 1)\n    for i := range grid {\n        grid[i] = make([]int, n + 1)\n    }\n    for i := 0; i <= m; i++ {\n        grid[i][0] = 1\n    }\n    for j := 0; j <= n; j++ {\n        grid[0][j] = 1\n    }\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
                "func PowerDigitSum(n int) int {\n    digits := []int{2}\n    for _ := 0; _ < n; _++ {\n        carry := 0\n        for j := range digits {\n            temp := digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if carry!= 0 {\n            digits = append(digits, carry)\n        }\n    }\n    result := 0\n    for _, digit := range digits {\n        result += digit\n    }\n    return result\n}",
                "func NumberToWords(n int) string {\n    ones := []string{\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    teens := []string{\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"}\n    tens := []string{\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"}\n    if n == 1000 {\n        return \"one thousand\"\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n/100] + \" hundred\"\n        } else {\n            return ones[n/100] + \" hundred and \" + NumberToWords(n%100)\n        }\n    } else if n >= 20 {\n        suf := \"\"\n        if n % 10!= 0 {\n            suf = \" \" + ones[n%10]\n        }\n        return tens[n/10] + suf\n    } else if n >= 10 {\n        return teens[n-10]\n    } else {\n        return ones[n]\n    }\n}",
                "func MaximumPathSumI(triangle [][]int) int {\n    curr := make([]int, len(triangle[len(triangle)-1]))\n    copy(curr, triangle[len(triangle)-1])\n    for i := len(triangle) - 2; i >= 0; i-- {\n        next := make([]int, len(triangle[i]))\n        for j := 0; j < len(next); j++ {\n            next[j] = triangle[i][j] + max(curr[j], curr[j+1])\n        }\n        curr = next\n    }\n    return curr[0]\n}",
                "func CountingSundays(y1 int, y2 int) int {\n    day := 0\n    count := 0\n    for year := 1900; year <= y2; year++ {\n        for month := 1; month <= 12; month++ {\n            if year >= y1 && day%7 == 6 {\n                count++\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30\n            } else if month == 2 {\n                if year%4 == 0 && (year%100!= 0 || year%400 == 0) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
                "func FactorialDigitSum(n int) int {\n    digits := []int{1}\n    for i := 1; i < n+1; i++ {\n        carry := 0\n        for j := range digits {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        for carry > 0 {\n            digits = append(digits, carry % 10)\n            carry /= 10\n    }\n    result := 0\n    for _, digit := range digits {\n        result += digit\n    }\n    return result\n}",
                "func D(n int) int {\n    result := 1\n    for i := 2; i < int(math.Sqrt(float64(n))) + 1; i++ {\n        if n%i == 0 {\n            result += i\n            if i!= n/i {\n                result += n/i\n            }\n        }\n    }\n    return result\n}\n\nfunc AmicableNumbers(n int) int {\n    result := 0\n    for a := 2; a < n; a++ {\n        b := D(a)\n        if a!= b && a == D(b) {\n            result += a\n        }\n    }\n    return result\n}",
                "func NamesScores(names []string, queries []string) int {\n    sNames := []string{}\n    for _, name := range names {\n        sNames = append(sNames, name)\n    }\n    sort.Strings(sNames)\n    result := 0\n    for i, name := range sNames {\n        x := 0\n        for _, c := range name {\n            x += int(c) - 64\n        }\n        if name == \"Amy\" {\n            fmt.Println(\"Amy is at index\", i)\n        }\n        if name == \"Brian\" {\n            fmt.Println(\"Brian is at index\", i)\n        }\n        if name == \"Cory\" {\n            fmt.Println(\"Cory is at index\", i)\n        }\n        if name == \"Dave\" {\n            fmt.Println(\"Dave is at index\", i)\n        }\n        if name == \"Eric\" {\n            fmt.Println(\"Eric is at index\", i)\n        }\n        if name == \"Fred\" {\n            fmt.Println(\"Fred is at index\", i)\n        }\n        if name == \"Gary\" {\n            fmt.Println(\"Gary is at index\", i)\n        }\n        if name == \"Harry\" {\n            fmt.Println(\"Harry is at index\", i)\n        }\n        if name == \"Irene\" {\n            fmt.Println(\"Irene is at index\", i)\n        }\n        if name == \"Jane\" {\n            fmt.Println(\"Jane is at index\", i)\n        }\n        if name == \"Kevin\" {\n            fmt.Println(\"Kevin is at index\", i)\n        }\n        if name == \"Lisa\" {\n            fmt.Println(\"Lisa is at index\", i)\n        }\n        if name == \"Mary\" {\n            fmt.Println(\"Mary is at index\", i)\n        }\n        if name == \"Nancy\" {\n            fmt.Println(\"Nancy is at index\", i)\n        }\n        if name == \"Olivia\" {\n            fmt.Println(\"Olivia is at index\", i)\n        }\n        if name == \"Peter\" {\n            fmt.Println(\"Peter is at index\", i)\n        }\n        if name == \"Quincy\" {\n            fmt.Println(\"Quincy is at index\", i)\n        }\n        if name == \"Rachel\" {\n            fmt.Println(\"Rachel is at index\", i)\n        }\n        if name == \"Steve\" {\n            fmt.Println(\"Steve is at index\", i)\n        }\n        if name == \"Terry\" {\n            fmt.Println(\"Terry is at index\", i)\n        }\n        if name == \"Uma\" {\n            fmt.Println(\"Uma is at index\", i)\n        }\n        if name == \"Victor\" {\n            fmt.Println(\"Victor is at index\", i)\n        }\n        if name == \"Wendy\" {\n            fmt.Println(\"Wendy is at index\", i)\n        }\n        if name == \"Xavier\" {\n            fmt.Println(\"Xavier is at index\", i)\n        }\n        if name == \"Yvonne\" {\n            fmt.Println(\"Yvonne is at index\", i)\n        }\n        if name == \"Zachary\" {\n            fmt.Println(\"Zachary is at index\", i)\n        }\n        if name == \"Abigail\" {\n            fmt.Println(\"Abigail is at index\", i)\n        }\n        if name == \"Billy\" {\n            fmt.Println(\"Billy is at index\", i)\n        }\n        if name == \"Cecil\" {\n            fmt.Println(\"Cecil is at index\", i)\n        }\n        if name == \"Doris\" {\n            fmt.Println(\"Doris is at index\", i)\n        }\n        if name == \"Eugene\" {\n            fmt.Println(\"Eugene is at index\", i)\n        }\n        if name == \"Floyd\" {\n            fmt.Println(\"Floyd is at index\", i)\n        }\n        if name == \"Gabriel\" {\n            fmt.Println(\"Gabriel is at index\", i)\n        }\n        if name == \"Henry\" {\n            fmt.Println(\"Henry is at index\", i)\n        }\n        if name == \"Isabel\" {\n            fmt.Println(\"Isabel is at index\", i)\n        }\n        if name == \"Jeff\" {\n            fmt.Println(\"Jeff is at index\", i)\n        }\n        if name == \"Kimberly\" {\n            fmt.Println(\"Kimberly is at index\", i)\n        }\n        if name == \"Larry\" {\n            fmt.Println(\"Larry is at index\", i)\n        }\n        if name == \"Margaret\" {\n            fmt.Println(\"Margaret is at index\", i)\n        }\n        if name == \"Natalie\" {\n            fmt.Println(\"Natalie is at index\", i)\n        }\n        if name == \"Owen\" {\n            fmt.Println(\"Owen is at index\", i)\n        }\n        if name == \"Patrick\" {\n            fmt.Println(\"Patrick is at index\", i)\n        }\n        if name == \"Quinn\" {\n            fmt.Println(\"Quinn is at index\", i)\n        }\n        if name == \"Roger\" {\n            fmt.Println(\"Roger is at index\", i)\n        }\n        if name == \"Samantha\" {\n            fmt.Println(\"Samantha is at index\", i)\n        }\n        if name == \"Todd\" {\n            fmt.Println(\"Todd is at index\", i)\n        }\n        if name == \"Una\" {\n            fmt.Println(\"Una is at index\", i)\n        }\n        if name == \"Vincent\" {\n            fmt.Println(\"Vincent is at index\", i)\n        }\n        if name == \"Walter\" {\n            fmt.Println(\"Walter is at index\", i)\n        }\n        if name == \"Xander\" {\n            fmt.Println(\"Xander is at index\", i)\n        }\n        if name == \"Yolanda\" {\n            fmt.Println(\"Yolanda is at index\", i)\n        }\n        if name == \"Zoe\" {\n            fmt.Println(\"Zoe is at index\", i)\n        }\n        if name == \"Aaron\" {\n            fmt.Println(\"Aaron is at index\", i)\n        }\n        if name == \"Benjamin\" {\n            fmt.Println(\"Benjamin is at index\", i)\n        }\n        if name == \"Charles\" {\n            fmt.Println(\"Charles is at index\", i)\n        }\n        if name == \"Daniel\" {\n            fmt.Println(\"Daniel is at index\", i)\n        }\n        if name == \"Edward\" {\n            fmt.Println(\"Edward is at index\", i)\n        }\n        if name == \"Frank\" {\n            fmt.Println(\"Frank is at index\", i)\n        }\n        if name == \"George\" {\n            fmt.Println(\"George is at index\", i)\n        }\n        if name == \"Hannah\" {\n            fmt.Println(\"Hannah is at index\", i)\n        }\n        if name == \"Ian\" {\n            fmt.Println(\"Ian is at index\", i)\n        }\n        if name == \"James\" {\n            fmt.Println(\"James is at index\", i)\n        }\n        if name == \"John\" {\n            fmt.Println(\"John is at index\", i)\n        }\n        if name == \"Kenneth\" {\n            fmt.Println(\"Kenneth is at index\", i)\n        }\n        if name == \"Lee\" {\n            fmt.Println(\"Lee is at index\", i)\n        }\n        if name == \"Maria\" {\n            fmt.Println(\"Maria is at index\", i)\n        }\n        if name == \"Nicholas\" {\n            fmt.Println(\"Nicholas is at index\", i)\n        }\n        if name == \"Oliver\" {\n            fmt.Println(\"Oliver is at index\", i)\n        }\n        if name == \"Paul\" {\n            fmt.Println(\"Paul is at index\", i)\n        }\n        if name == \"Quentin\" {\n            fmt.Println(\"Quentin is at index\", i)\n        }\n        if name == \"Robert\" {\n            fmt.Println(\"Robert is at index\", i)\n        }\n        if name == \"Sarah\" {\n            fmt.Println(\"Sarah is at index\", i)\n        }\n        if name == \"Timothy\" {\n            fmt.Println(\"Timothy is at index\", i)\n        }\n        if name == \"Ursula\" {\n            fmt.Println(\"Ursula is at index\", i)\n        }\n        if name == \"Victoria\" {\n            fmt.Println(\"Victoria is at index\", i)\n        }\n        if name == \"William\" {\n            fmt.Println(\"William is at index\", i)\n        }\n        if name == \"Xavier\" {\n            fmt.Println(\"Xavier is at index\", i)\n        }\n        if name == \"Yvonne\" {\n            fmt.Println(\"Yvonne is at index\", i)\n        }\n        if name == \"Zachary\" {\n            fmt.Println(\"Zachary is at index\", i)",
                "func IsAbundant(n int) bool {\n    if n < 12 {\n        return false\n    }\n    sumDivisors := 1\n    for i := 2; i < int(math.Sqrt(float64(n))) + 1; i++ {\n        if n%i == 0 {\n            sumDivisors += i\n            if i!= n/i {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfunc NonAbundantSums(n int) int {\n    abundants := []int{}\n    for i := 12; i < n; i++ {\n        if IsAbundant(i) {\n            abundants = append(abundants, i)\n        }\n    }\n    abundantSums := map[int]bool{}\n    for _, i := range abundants {\n        for _, j := range abundants {\n            abundantSums[i+j] = true\n        }\n    }\n    result := 0\n    for i := 0; i < n; i++ {\n        if!abundantSums[i] {\n            result += i\n        }\n    }\n    return result\n}",
                "func LexicographicPermutations(n int) string {\n    result := \"\"\n    digits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    x := n - 1\n    for i := 10; i > 0; i-- {\n        fact := 1\n        for j := 1; j < i; j++ {\n            fact *= j\n        }\n        idx := x / fact\n        result += strconv.Itoa(digits[idx])\n        digits = append(digits[:idx], digits[idx+1:]...)\n        x -= idx * fact\n    }\n    return result\n}",
                "func NDigitFibonacciNumber(n int) int {\n    a := []int{1}\n    b := []int{1}\n    i := 2\n    for len(b) < n {\n        carry := 0\n        c := make([]int, len(b))\n        copy(c, b)\n        for j := range b {\n            if j < len(a) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if carry > 0 {\n            b = append(b, carry)\n        }\n        a = c\n        i++\n    }\n    return i\n}",
                "func ReciprocalCycles(n int) int {\n    result := 0\n    max_length := 0\n    for i := 1; i < n; i++ {\n        remainders := []int{}\n        remainder := 1\n        for remainder!= 0 && remainder!= 1 {\n            remainders = append(remainders, remainder)\n            remainder = (remainder * 10) % i\n        }\n        length := 0\n        if remainder!= 0 {\n            length = len(remainders) - remainders[len(remainders)-1]\n        }\n        if length > max_length {\n            max_length = length\n            result = i\n        }\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc QuadraticPrimes(n int) int {\n    maxPrimes := 0\n    result := 0\n    for a := -n + 1; a <= n; a += 2 {\n        for b := -n + 1; b <= n; b += 2 {\n            x := 0\n            for {\n                if x*x + a*x + b < 2 {\n                    break\n                }\n                if!IsPrime(x*x + a*x + b) {\n                    break\n                }\n                x++\n            }\n            if x > maxPrimes {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
                "func NumberSpiralDiagonals(n int) int {\n    result := 1\n    for i := 3; i < n+1; i += 2 {\n        result += 4*i*i - 6*i + 6\n    }\n    return result\n}",
                "func DistinctPowers(n int) int {\n    result := 0\n    xs := map[string]bool{}\n    for i := 2; i <= n; i++ {\n        primes := []int{2, 3, 5, 7}\n        powers := []int{0, 0, 0, 0}\n        num := i\n        for j := 0; j < len(primes); j++ {\n            for num % primes[j] == 0 {\n                num //= primes[j]\n                powers[j] += 1\n            }\n        }\n        if num!= 1 {\n            result += n - 1\n            continue\n        }\n        for j := 2; j <= n; j++ {\n            pstr := fmt.Sprintf(\"%d-%d-%d-%d\", powers[0]*j, powers[1]*j, powers[2]*j, powers[3]*j)\n            xs[pstr] = true\n        }\n    }\n    result += len(xs)\n    return result\n}",
                "func DigitNthPowers(n int) int {\n    result := 0\n    for i := 2; i < 4 * 10 ** n; i++ {\n        digitsSum := 0\n        for _, digit := range strconv.Itoa(i) {\n            digitsSum += int(digit) ** n\n        }\n        if i == digitsSum {\n            result += i\n        }\n    }\n    return result\n}",
                "func CoinSums(n int) int {\n    coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\n    ways := make([]int, n + 1)\n    ways[0] = 1\n    for _, coin := range coins {\n        for i := coin; i <= n; i++ {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
                "func PandigitalProducts(n int) int {\n    products := map[int]bool{}\n    s := strings.Join(strings.Split(strings.Repeat(\"123456789\", n), \"\"), \"\")\n    for a := 1; a < 100; a++ {\n        for b := 1; b < 10000; b++ {\n            c := a * b\n            chars := []string{strconv.Itoa(a), strconv.Itoa(b), strconv.Itoa(c)}\n            sort.Strings(chars)\n            if strings.Join(chars, \"\") == s {\n                products[c] = true\n            }\n        }\n    }\n    result := 0\n    for product := range products {\n        result += product\n    }\n    return result\n}",
                "func DigitCancelingFractions(m int) int {\n    numer := 1\n    denom := 1\n    for d := 10; d < m; d++ {\n        for n := 10; n < d; n++ {\n            n0, n1 := n % 10, n / 10\n            d0, d1 := d % 10, d / 10\n            if (n1 == d0 && n0*d == n*d1) || (n0 == d1 && n1*d == n*d0) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    a, b := numer, denom\n    for b!= 0 {\n        a, b = b, a%b\n    }\n    return denom / a\n}",
                "func DigitFactorials(n int) int {\n    result := 0\n    for i := 3; i < n; i++ {\n        factSum := 0\n        for _, digit := range strconv.Itoa(i) {\n            fact := 1\n            for j := 1; j < int(digit) + 1; j++ {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if i == factSum {\n            result += i\n        }\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc CircularPrimes(n int) int {\n    count := 0\n    for i := 2; i < n; i++ {\n        if IsPrime(i) {\n            rotations := map[int]bool{}\n            for j := 0; j < len(strconv.Itoa(i)); j++ {\n                rotations[int(strconv.Itoa(i)[j:] + strconv.Itoa(i)[:j])] = true\n            }\n            flag := true\n            for x := range rotations {\n                if!IsPrime(x) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                count++\n            }\n        }\n    }\n    return count\n}",
                "func IsPalindrome(s string) bool {\n    for i := 0; i < len(s) / 2; i++ {\n        if s[i]!= s[len(s)-1-i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc DoubleBasePalindromes(n int) int {\n    result := 0\n    for i := 1; i < n; i++ {\n        strI := strconv.Itoa(i)\n        binI := strconv.FormatInt(int64(i), 2)\n        if IsPalindrome(strI) && IsPalindrome(binI) {\n            result += i\n        }\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i < int(math.Sqrt(float64(n)))+1; i += 2 {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TruncatablePrimes(n int) int {\n    result := 0\n    for i := 10; i < n; i++ {\n        if IsPrime(i) {\n            si := strconv.Itoa(i)\n            flag := true\n            for j := 1; j < len(si); j++ {\n                p1, _ := strconv.Atoi(si[j:])\n                p2, _ := strconv.Atoi(si[:j])\n                if!IsPrime(p1) ||!IsPrime(p2) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                result += i\n            }\n        }\n    }\n    return result\n}",
                "func PandigitalMultiples(n int) int {\n    result := -1\n    for i := 2; i <= n; i++ {\n        cprod := \"\"\n        for j := 1; j <= 9; j++ {\n            cprod += strconv.Itoa(i * j)\n            if len(cprod) == 9 {\n                if strings.Join(sort.StringSlice(cprod), \"\") == \"123456789\" {\n                    result = max(result, strconv.Atoi(cprod))\n                    break\n                }\n            } else if len(cprod) > 9 {\n                break\n            }\n        }\n    }\n    return result\n}",
                "func IntegerRightTriangles(n int) int {\n    maxSol := 0\n    result := 0\n    for p := 3; p <= n; p++ {\n        sol := 0\n        for a := 1; a < p/2; a++ {\n            for b := a; b < p/2; b++ {\n                c := p - a - b\n                if a*a + b*b == c*c {\n                    sol++\n                }\n            }\n        }\n        if sol > maxSol {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
                "func ChampernowneConstant(b int) int {\n    s := \"\"\n    for i := 1; i < b**6; i++ {\n        s += strconv.Itoa(i)\n    }\n    result := 1\n    for i := 0; i < 7; i++ {\n        num, _ := strconv.Atoi(s[b**i - 1 : b**(i+1) - 1])\n        result *= num\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc PandigitalPrime(n int) int {\n    for i := n - 1; i > 0; i-- {\n        if IsPrime(i) {\n            si := strconv.Itoa(i)\n            length := len(si)\n            flag := true\n            for j := 1; j <= length; j++ {\n                if strconv.Itoa(j)!= si[j-1:j] {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                return i\n            }\n        }\n    }\n    return -1\n}",
                "func CodedTriangleNumbers(words []string) int {\n    result := 0\n    for _, word := range words {\n        value := 0\n        for _, c := range word {\n            value += int(c) - 64\n        }\n        n := int(math.Sqrt(float64(value * 2)))\n        if n * (n + 1) == value * 2 {\n            result += 1\n        }\n    }\n    return result\n}",
                "func GenPermutations(s string) []string {\n    if len(s) <= 1 {\n        return []string{s}\n    }\n    result := []string{}\n    for _, perm := range GenPermutations(s[1:]) {\n        for i := 0; i < len(s); i++ {\n            result = append(result, perm[:i] + s[0:1] + perm[i:])\n        }\n    }\n    return result\n}\n\nfunc SubStringDivisibility(n int) int {\n    result := 0\n    primes := []int{2, 3, 5, 7, 11, 13, 17}\n    s := strings.Join(strings.Split(strconv.Itoa(n + 1), \"\"), \"\")\n    for _, i := range GenPermutations(s) {\n        flag := true\n        for j := 1; j < n - 1; j++ {\n            if int(i[j:j + 3]) % primes[j - 1]!= 0 {\n                flag = false\n                break\n            }\n        }\n        if flag {\n            num, _ := strconv.Atoi(i)\n            result += num\n        }\n    }\n    return result\n}",
                "func PentagonNumbers(n int) int {\n    pentagon := map[int]bool{}\n    for i := 1; i < n; i++ {\n        pentagon[i * (3 * i - 1) // 2] = true\n    }\n    result := -1\n    for j := range pentagon {\n        for k := range pentagon {\n            if pentagon[j+k] && pentagon[k-j] {\n                if result == -1 || k-j < result {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
                "func TriangularPentagonalAndHexagonal(n int) int {\n    ps := map[int]bool{}\n    i := 1\n    c := 0.5 * i * (3 * i - 1)\n    for c < n {\n        i += 1\n        ps[c] = true\n        c = 0.5 * i * (3 * i - 1)\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    result := -1\n    for c < n {\n        i += 1\n        if ps[c] {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc GoldbachsOtherConjecture(n int) int {\n    result := -1\n    for i := 9999; i >= n; i -= 2 {\n        upper := int(math.Sqrt(float64(i / 2)))\n        flag := false\n        for j := 0; j <= upper; j++ {\n            if IsPrime(i - 2 * j * j) {\n                flag = true\n                break\n            }\n        }\n        if!flag {\n            result = i\n        }\n    }\n    return result\n}",
                "func PrimeFactors(n int) int {\n    num := n\n    factors := []int{}\n    i := 2\n    for i * i <= num {\n        if num % i == 0 {\n            factors = append(factors, i)\n            num /= i\n        } else {\n            i++\n        }\n    }\n    if num > 1 {\n        factors = append(factors, num)\n    }\n    return len(factors)\n}\n\nfunc DistinctPrimesFactors(n int) int {\n    for i := n; i < 1000000; i += 4 {\n        if PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4 {\n            return i\n        }\n    }\n    return -1\n}",
                "func SelfPowers(n int) string {\n    digits := make([]int, 10)\n    for i := 1; i <= n; i++ {\n        tempDigits := make([]int, 10)\n        tempDigits[0] = 1\n        for j := 0; j < i; j++ {\n            carry := 0\n            for k := 0; k < 10; k++ {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n        }\n        for j := 0; j < 10; j++ {\n            digits[j] += tempDigits[j]\n            if digits[j] >= 10 {\n                digits[j] -= 10\n                if j < 9 {\n                    digits[j + 1] += 1\n        }\n    }\n    result := \"\"\n    for i := 9; i >= 0; i-- {\n        result += strconv.Itoa(digits[i])\n    }\n    return result\n}",
                "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i < int(math.Sqrt(float64(n))) + 1; i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc GenPermutations(s string) []string {\n    if len(s) <= 1 {\n        return []string{s}\n    }\n    result := []string{}\n    for _, perm := range GenPermutations(s[1:]) {\n        for i := 0; i < len(s); i++ {\n            result = append(result, perm[:i] + s[0:1] + perm[i:])\n        }\n    }\n    return result\n}\n\nfunc PrimePermutations(n int) string {\n    for i := n; i >= 999; i-- {\n        if IsPrime(i) {\n            permutations := GenPermutations(strconv.Itoa(i))\n            candidates := map[int]bool{}\n            for _, j := range permutations {\n                candidate, _ := strconv.Atoi(j)\n                if candidate > i && IsPrime(candidate) {\n                    candidates[candidate] = true\n                }\n            }\n            for m := range candidates {\n                if m + (m - i) > i && candidates[m + (m - i)] {\n                    return strconv.Itoa(i) + strconv.Itoa(m) + strconv.Itoa(m + (m - i))\n                }\n            }\n        }\n    }\n    return \"\"\n}",
                "func ConsecutivePrimeSum(limit int) int {\n    sieve := make([]bool, limit)\n    primes := []int{}\n    for i := 2; i < limit; i++ {\n        if sieve[i] {\n            primes = append(primes, i)\n            for j := i * 2; j < limit; j += i {\n                sieve[j] = false\n            }\n        }\n    }\n    maxLength := 0\n    maxPrime := 0\n    for i := 0; i < len(primes); i++ {\n        for j := i + maxLength; j < len(primes); j++ {\n            s := 0\n            for _, p := range primes[i:j] {\n                s += p\n            }\n            if s >= limit {\n                break\n            }\n            if sieve[s] && j - i > maxLength {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
            ],
            "java": [
                "class Global {\n    public static int multiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int evenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i == 0) {\n                result /= i;\n            } else {\n                i += 1;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i)!= s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int largestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (isPalindrome(String.valueOf(prod)) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int smallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i!= 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int sumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
                "class Global {\n    public static int nthPrime(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (primes.size() < n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes.get(primes.size() - 1);\n    }\n}",
                "class Global {\n    public static int largestProductInASeries(String s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.length() - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= Integer.parseInt(s.substring(i + j, i + j + 1));\n            }\n            result = Math.max(result, product);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int specialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int summationOfPrimes(int n) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        int i = 3;\n        while (i <= n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        for (int prime : primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int largestProductInAGrid(List<List<Integer>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.size() - 3; i++) {\n            for (int j = 0; j < grid.get(i).size() - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid.get(i + k).get(j);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid.get(i).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid.get(i + k).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid.get(i + k).get(j + 3 - k);\n                }\n                result = Math.max(result, p1, p2, p3, p4);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int highlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j < (int) Math.sqrt(result) + 1; j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String largeSum(List<String> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            for (String num : numbers) {\n                tmp += Integer.parseInt(num.substring(49 - i));\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i]!= 0) {\n                String result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += digits[j];\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int longestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num!= 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain += 1;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int latticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
                "class Global {\n    public static int powerDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(2);\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                int temp = digits.get(j) * 2 + carry;\n                digits.set(j, temp % 10);\n                carry = temp / 10;\n            }\n            if (carry!= 0) {\n                digits.add(carry);\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String numberToWords(int n) {\n        String[] ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        String[] teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        String[] tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            String suf = \"\";\n            if (n % 10!= 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
                "class Global {\n    public static int maximumPathSumI(List<List<Integer>> triangle) {\n        List<Integer> curr = new ArrayList<>(triangle.get(triangle.size() - 1));\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            List<Integer> next = new ArrayList<>(triangle.get(i));\n            for (int j = 0; j < next.size(); j++) {\n                next.set(j, next.get(j) + Math.max(curr.get(j), curr.get(j + 1)));\n            }\n            curr = next;\n        }\n        return curr.get(0);\n    }\n}",
                "class Global {\n    public static int countingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count += 1;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static int factorialDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>();\n        digits.add(1);\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                digits.set(j, digits.get(j) * i + carry);\n                carry = digits.get(j) / 10;\n                digits.set(j, digits.get(j) % 10);\n            }\n            while (carry > 0) {\n                digits.add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int d(int n) {\n        int result = 1;\n        for (int i = 2; i <= (int) Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i!= n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int amicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = d(a);\n            if (a!= b && a == d(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int namesScores(List<String> names, List<String> queries) {\n        List<String> sNames = new ArrayList<>(names);\n        Collections.sort(sNames);\n        int result = 0;\n        for (int i = 0; i < sNames.size(); i++) {\n            int x = 0;\n            for (char c : sNames.get(i).toCharArray()) {\n                x += c - 'A' + 1;\n            }\n            if (sNames.get(i).equals(queries)) {\n                result += x * (i + 1);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i!= n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int nonAbundantSums(int n) {\n        List<Integer> abundants = new ArrayList<>();\n        for (int i = 12; i <= n; i++) {\n            if (isAbundant(i)) {\n                abundants.add(i);\n            }\n        }\n        Set<Integer> abundantSums = new HashSet<>();\n        for (int i : abundants) {\n            for (int j : abundants) {\n                abundantSums.add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static String lexicographicPermutations(int n) {\n        String result = \"\";\n        List<Integer> digits = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += digits.get(idx);\n            digits.remove(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int nDigitFibonacciNumber(int n) {\n        List<Integer> a = new ArrayList<>();\n        a.add(1);\n        List<Integer> b = new ArrayList<>();\n        b.add(1);\n        int i = 2;\n        while (b.size() < n) {\n            int carry = 0;\n            List<Integer> c = new ArrayList<>(b);\n            for (int j = 0; j < b.size(); j++) {\n                if (j < a.size()) {\n                    b.set(j, a.get(j) + b.get(j) + carry);\n                } else {\n                    b.set(j, b.get(j) + carry);\n                }\n                carry = b.get(j) / 10;\n                b.set(j, b.get(j) % 10);\n            }\n            if (carry > 0) {\n                b.add(carry);\n            }\n            a = c;\n            i = i + 1;\n        }\n        return i;\n    }\n}",
                "class Global {\n    public static int reciprocalCycles(int n) {\n        int result = 0;\n        int max_length = 0;\n        for (int i = 1; i < n; i++) {\n            List<Integer> remainders = new ArrayList<>();\n            int remainder = 1;\n            while (remainder!= 0 &&!remainders.contains(remainder)) {\n                remainders.add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder!= 0) {\n                length = remainders.size() - remainders.indexOf(remainder);\n            }\n            if (length > max_length) {\n                max_length = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int quadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!isPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x += 1;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int numberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i < n + 1; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int distinctPowers(int n) {\n        int result = 0;\n        Set<String> xs = new HashSet<>();\n        for (int i = 2; i <= n; i++) {\n            List<Integer> primes = Arrays.asList(2, 3, 5, 7);\n            List<Integer> powers = Arrays.asList(0, 0, 0, 0);\n            int num = i;\n            for (int j = 0; j < primes.size(); j++) {\n                while (num % primes.get(j) == 0) {\n                    num /= primes.get(j);\n                    powers.set(j, powers.get(j) + 1);\n                }\n            }\n            if (num!= 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                String pstr = String.format(\"%d-%d-%d-%d\", powers.get(0) * j, powers.get(1) * j, powers.get(2) * j, powers.get(3) * j);\n                xs.add(pstr);\n            }\n        }\n        result += xs.size();\n        return result;\n    }\n}",
                "class Global {\n    public static int digitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * 10 ** n; i++) {\n            int digitsSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                digitsSum += (int) Math.pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int coinSums(int n) {\n        int[] coins = {1, 2, 5, 10, 20, 50, 100, 200};\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
                "class Global {\n    public static int pandigitalProducts(int n) {\n        Set<Integer> products = new HashSet<>();\n        String s = String.join(\"\", IntStream.range(1, n+1).mapToObj(String::valueOf).toArray(String[]::new));\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                String chars = String.join(\"\", String.valueOf(a), String.valueOf(b), String.valueOf(c));\n                chars = chars.chars().sorted().mapToObj(i -> (char) i).collect(Collectors.joining());\n                if (chars.equals(s)) {\n                    products.add(c);\n                }\n            }\n        }\n        int result = 0;\n        for (int product : products) {\n            result += product;\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int digitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b!= 0) {\n            a %= b;\n            int t = a;\n            a = b;\n            b = t;\n        }\n        return denom / a;\n    }\n}",
                "class Global {\n    public static int digitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                int fact = 1;\n                for (int j = 1; j < digit; j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int circularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                Set<Integer> rotations = new HashSet<>();\n                for (int j = 0; j < String.valueOf(i).length(); j++) {\n                    rotations.add(Integer.parseInt(String.valueOf(i).substring(j) + String.valueOf(i).substring(0, j)));\n                }\n                boolean flag = true;\n                for (int x : rotations) {\n                    if (!isPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
                "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i)!= s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int doubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            String strI = String.valueOf(i);\n            String binI = String.valueOf(Integer.toBinaryString(i));\n            if (isPalindrome(strI) && isPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int truncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (isPrime(i)) {\n                String si = String.valueOf(i);\n                boolean flag = true;\n                for (int j = 1; j < si.length(); j++) {\n                    int p1 = Integer.parseInt(si.substring(j));\n                    int p2 = Integer.parseInt(si.substring(0, j));\n                    if (!isPrime(p1) ||!isPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            String cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += String.valueOf(i * j);\n                if (cprod.length() == 9) {\n                    if (new String(cprod.toCharArray()).compareTo(\"123456789\") == 0) {\n                        result = Math.max(result, Integer.parseInt(cprod));\n                        break;\n                    }\n                } else if (cprod.length() > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int integerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol += 1;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int champernowneConstant(int b) {\n        String s = \"\";\n        for (int i = 1; i < Math.pow(b, 6); i++) {\n            s += i;\n        }\n        int result = 1;\n        for (int i = 7; i >= 0; i--) {\n            result *= Integer.parseInt(s.substring(Math.pow(b, i) - 1, Math.pow(b, i)));\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int pandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (isPrime(i)) {\n                String si = String.valueOf(i);\n                int length = si.length();\n                boolean flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (String.valueOf(j).compareTo(si)!= 0) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static int codedTriangleNumbers(List<String> words) {\n        int result = 0;\n        for (String word : words) {\n            int value = 0;\n            for (char c : word.toCharArray()) {\n                value += c - 'A' + 1;\n            }\n            int n = (int) Math.sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int subStringDivisibility(int n) {\n        int result = 0;\n        List<Integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17);\n        String s = String.join(\"\", Collections.nCopies(n + 1, \"0\"));\n        for (String i : genPermutations(s)) {\n            boolean flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (Integer.parseInt(i.substring(j, j + 3)) % primes.get(j - 1)!= 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += Integer.parseInt(i);\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int pentagonNumbers(int n) {\n        Set<Integer> pentagon = new HashSet<>();\n        for (int i = 1; i < n; i++) {\n            pentagon.add(i * (3 * i - 1) / 2);\n        }\n        int result = -1;\n        for (int j : pentagon) {\n            for (int k : pentagon) {\n                if (pentagon.contains(j + k) && pentagon.contains(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int triangularPentagonalAndHexagonal(int n) {\n        Set<Integer> ps = new HashSet<>();\n        int i = 1;\n        int c = 0.5 * i * (3 * i - 1);\n        while (c < n) {\n            i += 1;\n            ps.add(c);\n            c = 0.5 * i * (3 * i - 1);\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i += 1;\n            if (c in ps) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int goldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i >= n; i -= 2) {\n            int upper = (int) Math.sqrt(i / 2);\n            boolean flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (isPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static int primeFactors(int n) {\n        int num = n;\n        List<Integer> factors = new ArrayList<>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i == 0) {\n                num /= i;\n                factors.add(i);\n            } else {\n                i++;\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        return factors.size();\n    }\n\n    public static int distinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
                "class Global {\n    public static String selfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        String result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += digits[i];\n        }\n        return result;\n    }\n}",
                "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static String primePermutations(int n) {\n        for (int i = n; i >= 999; i -= 1) {\n            if (isPrime(i)) {\n                List<String> permutations = genPermutations(Integer.toString(i));\n                Set<Integer> candidates = new HashSet<>();\n                for (String j : permutations) {\n                    int candidate = Integer.parseInt(j);\n                    if (candidate > i && isPrime(candidate)) {\n                        candidates.add(candidate);\n                    }\n                }\n                for (int m : candidates) {\n                    if (m + (m - i) in candidates) {\n                        return Integer.toString(i) + Integer.toString(m) + Integer.toString(m + (m - i));\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
                "class Global {\n    public static int consecutivePrimeSum(int limit) {\n        boolean[] sieve = new boolean[limit];\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + maxLength; j < primes.size(); j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes.get(k);\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
            ],
            "javascript": [
                "const multiplesOf3And5 = (n) => {\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const evenFibonacciNumbers = (n) => {\n    let result = 0;\n    let a = 1;\n    let b = 2;\n    while (a < n) {\n        if (a % 2 === 0) {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
                "const largestPrimeFactor = (n) => {\n    let result = n;\n    let i = 2;\n    while (i * i <= result) {\n        if (result % i) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i]!== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst largestPalindromeProduct = (n) => {\n    let result = 0;\n    for (let i = 100; i < 1000; i++) {\n        for (let j = i; j < 1000; j++) {\n            let prod = i * j;\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
                "const smallestMultiple = (n) => {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        if (result % i!== 0) {\n            for (let j = 1; j <= n; j++) {\n                if ((result * j) % i === 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const sumSquareDifference = (n) => {\n    let sqrSum = 0;\n    let numSum = 0;\n    for (let i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
                "const nthPrime = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (primes.length < n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.length - 1];\n}",
                "const largestProductInASeries = (s, k) => {\n    let result = 0;\n    for (let i = 0; i < s.length - k; i++) {\n        let product = 1;\n        for (let j = 0; j < k; j++) {\n            product *= parseInt(s[i + j]);\n        }\n        result = Math.max(result, product);\n    }\n    return result;\n}",
                "const specialPythagoreanTriplet = (n) => {\n    for (let a = 1; a < n; a++) {\n        for (let b = a; b < n; b++) {\n            const c = n - a - b;\n            if (a * a + b * b === c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
                "const summationOfPrimes = (n) => {\n    let primes = [2];\n    let i = 3;\n    while (i <= n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let result = 0;\n    for (let prime of primes) {\n        result += prime;\n    }\n    return result;\n}",
                "const largestProductInAGrid = (grid) => {\n    let result = 0;\n    for (let i = 0; i < grid.length - 3; i++) {\n        for (let j = 0; j < grid[i].length - 3; j++) {\n            let p1 = 1;\n            let p2 = 1;\n            let p3 = 1;\n            let p4 = 1;\n            for (let k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (let k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = Math.max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
                "const highlyDivisibleTriangularNumber = (n) => {\n    for (let i = 1; i < 100000000; i++) {\n        let result = i * (i + 1) / 2;\n        let count = 0;\n        for (let j = 1; Math.sqrt(result) >= j; j++) {\n            if (result % j === 0) {\n                count += 2;\n            }\n            if (j * j === result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
                "const largeSum = (numbers) => {\n    let digits = [0] * 60;\n    for (let i = 0; i < 50; i++) {\n        let tmp = 0;\n        for (let num of numbers) {\n            tmp += parseInt(num[49 - i]);\n        }\n        for (let j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp = Math.floor(tmp / 10);\n            if (tmp === 0) {\n                break;\n            }\n        }\n    }\n    for (let i = 59; i >= 0; i--) {\n        if (digits[i]!== 0) {\n            let result = '';\n            for (let j = i; j > i - 10; j--) {\n                result += digits[j].toString();\n            }\n            return result;\n        }\n    }\n}",
                "const longestCollatzSequence = (n) => {\n    let longest = 0;\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let chain = 1;\n        let num = i;\n        while (num!== 1) {\n            if (num % 2 === 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const latticePaths = (m, n) => {\n    let grid = [];\n    for (let i = 0; i < m + 1; i++) {\n        grid.push([0] * (n + 1));\n    }\n    for (let i = 0; i < m + 1; i++) {\n        grid[i][0] = 1;\n    }\n    for (let j = 0; j < n + 1; j++) {\n        grid[0][j] = 1;\n    }\n    for (let i = 1; i < m + 1; i++) {\n        for (let j = 1; j < n + 1; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
                "const powerDigitSum = (n) => {\n    let digits = [2];\n    for (let _ = 0; _ < n; _++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10 | 0;\n        }\n        if (carry) {\n            digits.push(carry);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const numberToWords = (n) => {\n    const ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    const teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    const tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if (n === 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 === 0) {\n            return ones[n // 100] + \" hundred\";\n        } else {\n            return ones[n // 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        let suf = \"\";\n        if (n % 10!== 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n // 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
                "const maximumPathSumI = (triangle) => {\n    let curr = triangle[triangle.length - 1].slice();\n    for (let i = triangle.length - 2; i >= 0; i--) {\n        let next = triangle[i].slice();\n        for (let j = 0; j < next.length; j++) {\n            next[j] += Math.max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
                "const countingSundays = (y1, y2) => {\n    let day = 0;\n    let count = 0;\n    for (let year = 1900; year <= y2; year++) {\n        for (let month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 === 6) {\n                count += 1;\n            }\n            if (month in [4, 6, 9, 11]) {\n                day += 30;\n            } else if (month === 2) {\n                if (year % 4 === 0 && (year % 100!== 0 || year % 400 === 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
                "const factorialDigitSum = (n) => {\n    let digits = [1];\n    for (let i = 1; i <= n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = Math.floor(digits[j] / 10);\n            digits[j] %= 10;\n        }\n        while (carry) {\n            digits.push(carry % 10);\n            carry = Math.floor(carry / 10);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
                "const d = (n) => {\n    let result = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            result += i;\n            if (i!== n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nconst amicableNumbers = (n) => {\n    let result = 0;\n    for (let a = 2; a < n; a++) {\n        let b = d(a);\n        if (a!== b && a === d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
                "const namesScores = (names, queries) => {\n    let sNames = names.sort();\n    let result = 0;\n    for (let i = 0; i < sNames.length; i++) {\n        let x = 0;\n        for (let c of sNames[i]) {\n            x += c.charCodeAt(0) - 64;\n        }\n        if (sNames[i] in queries) {\n            result += x * (i + 1);\n        }\n    }\n    return result;\n}",
                "const isAbundant = (n) => {\n    if (n < 12) {\n        return false;\n    }\n    let sumDivisors = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            sumDivisors += i;\n            if (i!== n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nconst nonAbundantSums = (n) => {\n    let abundants = [];\n    for (let i = 12; i <= n; i++) {\n        if (isAbundant(i)) {\n            abundants.push(i);\n        }\n    }\n    let abundantSums = new Set();\n    for (let i of abundants) {\n        for (let j of abundants) {\n            abundantSums.add(i + j);\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!abundantSums.has(i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const lexicographicPermutations = (n) => {\n    let result = '';\n    let digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let x = n - 1;\n    for (let i = 10; i > 0; i--) {\n        let fact = 1;\n        for (let j = 1; j < i; j++) {\n            fact *= j;\n        }\n        let idx = Math.floor(x / fact);\n        result += digits[idx];\n        digits.splice(idx, 1);\n        x -= idx * fact;\n    }\n    return result;\n}",
                "const nDigitFibonacciNumber = (n) => {\n    let a = [1];\n    let b = [1];\n    let i = 2;\n    while (b.length < n) {\n        let carry = 0;\n        let c = b.slice();\n        for (let j = 0; j < b.length; j++) {\n            if (j < a.length) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = Math.floor(b[j] / 10);\n            b[j] = b[j] % 10;\n        }\n        if (carry) {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
                "const reciprocalCycles = (n) => {\n    let result = 0;\n    let maxLength = 0;\n    for (let i = 1; i < n; i++) {\n        let remainders = [];\n        let remainder = 1;\n        while (remainder!== 0 && remainder!== remainders[remainders.length - 1]) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = 0;\n        if (remainder!== 0) {\n            length = remainders.length - remainders.indexOf(remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst quadraticPrimes = (n) => {\n    let maxPrimes = 0;\n    let result = 0;\n    for (let a = -n + 1; a < n; a += 2) {\n        for (let b = -n + 1; b < n; b += 2) {\n            let x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x += 1;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
                "const numberSpiralDiagonals = (n) => {\n    let result = 1;\n    for (let i = 3; i < n + 1; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
                "const distinctPowers = (n) => {\n    let result = 0;\n    let xs = new Set();\n    for (let i = 2; i <= n; i++) {\n        let primes = [2, 3, 5, 7];\n        let powers = [0, 0, 0, 0];\n        let num = i;\n        for (let j = 0; j < primes.length; j++) {\n            while (num % primes[j] === 0) {\n                num //= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num!== 1) {\n            result += n - 1;\n            continue;\n        }\n        for (let j = 2; j <= n; j++) {\n            let pstr = `${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}`;\n            xs.add(pstr);\n        }\n    }\n    result += xs.size;\n    return result;\n}",
                "const digitNthPowers = (n) => {\n    let result = 0;\n    for (let i = 2; i < 4 * 10 ** n; i++) {\n        let digitsSum = 0;\n        for (let digit of String(i)) {\n            digitsSum += parseInt(digit) ** n;\n        }\n        if (i === digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const coinSums = (n) => {\n    const coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    const ways = Array(n + 1).fill(0);\n    ways[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
                "const pandigitalProducts = (n) => {\n    let products = new Set();\n    let s = '';\n    for (let i = 1; i <= n; i++) {\n        s += i;\n    }\n    for (let a = 1; a < 100; a++) {\n        for (let b = 1; b < 10000; b++) {\n            let c = a * b;\n            let chars = [a, b, c].map(i => i.toString()).sort();\n            if (chars.join('') === s) {\n                products.add(c);\n            }\n        }\n    }\n    let result = 0;\n    for (let product of products) {\n        result += product;\n    }\n    return result;\n}",
                "const digitCancelingFractions = (m) => {\n    let numer = 1;\n    let denom = 1;\n    for (let d = 10; d < m; d++) {\n        for (let n = 10; n < d; n++) {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let a = numer;\n    let b = denom;\n    while (b) {\n        a = b;\n        b = a % b;\n    }\n    return denom / a;\n}",
                "const digitFactorials = (n) => {\n    let result = 0;\n    for (let i = 3; i < n; i++) {\n        let factSum = 0;\n        for (let digit of String(i)) {\n            let fact = 1;\n            for (let j = 1; j < parseInt(digit) + 1; j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i === factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst circularPrimes = (n) => {\n    let count = 0;\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            let rotations = new Set();\n            for (let j = 0; j < String(i).length; j++) {\n                rotations.add(parseInt(String(i).substring(j) + String(i).substring(0, j)));\n            }\n            let flag = true;\n            for (let x of rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}",
                "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i]!== s[s.length - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst doubleBasePalindromes = (n) => {\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let strI = i.toString();\n        let binI = (i).toString(2);\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i;\n        }\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst truncatablePrimes = (n) => {\n    let result = 0;\n    for (let i = 10; i <= n; i++) {\n        if (isPrime(i)) {\n            const si = i.toString();\n            let flag = true;\n            for (let j = 1; j < si.length; j++) {\n                const p1 = parseInt(si.substring(j));\n                const p2 = parseInt(si.substring(0, si.length - j));\n                if (!isPrime(p1) ||!isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
                "const pandigitalMultiples = (n) => {\n    let result = -1;\n    for (let i = 2; i <= n; i++) {\n        let cprod = '';\n        for (let j = 1; j <= 9; j++) {\n            cprod += i * j;\n            if (cprod.length === 9) {\n                if (cprod.split('').sort().join('') === '123456789') {\n                    result = Math.max(result, parseInt(cprod));\n                    break;\n                }\n            } else if (cprod.length > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
                "const integerRightTriangles = (n) => {\n    let maxSol = 0;\n    let result = 0;\n    for (let p = 3; p <= n; p++) {\n        let sol = 0;\n        for (let a = 1; a < p / 2; a++) {\n            for (let b = a; b < p / 2; b++) {\n                let c = p - a - b;\n                if (a * a + b * b === c * c) {\n                    sol += 1;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
                "const champernowneConstant = (b) => {\n    let s = '';\n    for (let i = 1; i < b**6; i++) {\n        s += i;\n    }\n    let result = 1;\n    for (let i = 7; i >= 0; i--) {\n        result *= parseInt(s[b**i - 1]);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst pandigitalPrime = (n) => {\n    for (let i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            const si = String(i);\n            const length = si.length;\n            let flag = true;\n            for (let j = 1; j <= length; j++) {\n                if (String(j)!== si.substring(j - 1, j)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
                "const codedTriangleNumbers = (words) => {\n    let result = 0;\n    for (let word of words) {\n        let value = 0;\n        for (let c of word) {\n            value += c.charCodeAt(0) - 64;\n        }\n        let n = Math.floor(Math.sqrt(value * 2));\n        if (n * (n + 1) === value * 2) {\n            result += 1;\n        }\n    }\n    return result;\n}",
                "const genPermutations = (s) => {\n    if (s.length <= 1) {\n        return s;\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst subStringDivisibility = (n) => {\n    let result = 0;\n    const primes = [2, 3, 5, 7, 11, 13, 17];\n    const s = [...Array(n + 1).keys()].map(i => i.toString()).join('');\n    for (let i of genPermutations(s)) {\n        let flag = true;\n        for (let j = 1; j < n - 1; j++) {\n            if (parseInt(i.substring(j, j + 3)) % primes[j - 1]!== 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += parseInt(i);\n        }\n    }\n    return result;\n}",
                "const pentagonNumbers = (n) => {\n    let pentagon = new Set();\n    for (let i = 1; i < n; i++) {\n        pentagon.add(i * (3 * i - 1) / 2);\n    }\n    let result = -1;\n    for (let j of pentagon) {\n        for (let k of pentagon) {\n            if (pentagon.has(j + k) && pentagon.has(k - j)) {\n                if (result === -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
                "const triangularPentagonalAndHexagonal = (n) => {\n    let ps = new Set();\n    let i = 1;\n    let c = 0.5 * i * (3 * i - 1);\n    while (c < n) {\n        i += 1;\n        ps.add(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let result = -1;\n    while (c < n) {\n        i += 1;\n        if (ps.has(c)) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst goldbachsOtherConjecture = (n) => {\n    let result = -1;\n    for (let i = 9999; i >= n; i -= 2) {\n        let upper = Math.floor(Math.sqrt(i / 2));\n        let flag = false;\n        for (let j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
                "const primeFactors = (n) => {\n    let num = n;\n    let factors = [];\n    let i = 2;\n    while (i * i <= num) {\n        if (num % i) {\n            i += 1;\n        } else {\n            num //= i;\n            factors.push(i);\n        }\n    }\n    if (num > 1) {\n        factors.push(num);\n    }\n    return factors.length;\n}\n\nconst distinctPrimesFactors = (n) => {\n    for (let i = n; i < 1000000; i++) {\n        if (primeFactors(i) === 4 && primeFactors(i + 1) === 4 && primeFactors(i + 2) === 4 && primeFactors(i + 3) === 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "const selfPowers = (n) => {\n    let digits = [0] * 10;\n    for (let i = 1; i <= n; i++) {\n        let tempDigits = [0] * 10;\n        tempDigits[0] = 1;\n        for (let j = 0; j < i; j++) {\n            let carry = 0;\n            for (let k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = Math.floor(tempDigits[k] / 10);\n                tempDigits[k] %= 10;\n            }\n        }\n        for (let j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let result = \"\";\n    for (let i = 9; i >= 0; i--) {\n        result += digits[i].toString();\n    }\n    return result;\n}",
                "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.sqrt(n); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst genPermutations = (s) => {\n    if (s.length <= 1) {\n        return s;\n    }\n    let result = [];\n    for (let perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; i++) {\n            result.push(perm.substring(0, i) + s.substring(0, 1) + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst primePermutations = (n) => {\n    for (let i = n; i >= 999; i -= 1) {\n        if (isPrime(i)) {\n            let permutations = genPermutations(i.toString());\n            let candidates = new Set();\n            for (let j of permutations) {\n                let candidate = parseInt(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.add(candidate);\n                }\n            }\n            for (let m of candidates) {\n                if (m + (m - i) in candidates) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString();\n                }\n            }\n        }\n    }\n    return '';\n}",
                "const consecutivePrimeSum = (limit) => {\n    let sieve = Array(limit).fill(true);\n    let primes = [];\n    for (let i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push(i);\n            for (let j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    let maxLength = 0;\n    let maxPrime = 0;\n    for (let i = 0; i < primes.length; i++) {\n        for (let j = i + maxLength; j < primes.length; j++) {\n            let s = primes.slice(i, j).reduce((a, b) => a + b);\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
            ],
            "kotlin": [
                "fun multiplesOf3And5(n: Int): Int {\n    var result = 0\n    for (i in 0 until n) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun evenFibonacciNumbers(n: Int): Int {\n    var result = 0\n    var a = 1\n    var b = 2\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a\n        }\n        val tmp = a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
                "fun largestPrimeFactor(n: Int): Int {\n    var result = n\n    var i = 2\n    while (i * i <= result) {\n        if (result % i == 0) {\n            result /= i\n        } else {\n            i += 1\n        }\n    }\n    return result\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i]!= s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun largestPalindromeProduct(n: Int): Int {\n    var result = 0\n    for (i in 100..999) {\n        for (j in i..999) {\n            val prod = i * j\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
                "fun smallestMultiple(n: Int): Int {\n    var result = 1\n    for (i in 1..n) {\n        if (result % i!= 0) {\n            for (j in 1..n) {\n                if ((result * j) % i == 0) {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun sumSquareDifference(n: Int): Int {\n    var sqrSum = 0\n    var numSum = 0\n    for (i in 1..n) {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
                "fun nthPrime(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (primes.size < n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes.last()\n}",
                "fun largestProductInASeries(s: String, k: Int): Int {\n    var result = 0\n    for (i in s.length - k until s.length) {\n        var product = 1\n        for (j in 0 until k) {\n            product *= s[i - j].toInt()\n        }\n        result = maxOf(result, product)\n    }\n    return result\n}",
                "fun specialPythagoreanTriplet(n: Int): Int {\n    for (a in 1..n) {\n        for (b in a..n) {\n            val c = n - a - b\n            if (a * a + b * b == c * c) {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
                "fun summationOfPrimes(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (i <= n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    var result = 0\n    for (prime in primes) {\n        result += prime\n    }\n    return result\n}",
                "fun largestProductInAGrid(grid: List<List<Int>>): Int {\n    var result = 0\n    for (i in grid.indices - 3) {\n        for (j in grid[i].indices - 3) {\n            val p1 = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]\n            val p2 = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]\n            val p3 = grid[i][j] * grid[i + 1][j + 1] * grid[i + 2][j + 2] * grid[i + 3][j + 3]\n            val p4 = grid[i][j] * grid[i + 1][j + 2] * grid[i + 2][j + 1] * grid[i + 3][j]\n            result = maxOf(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
                "fun highlyDivisibleTriangularNumber(n: Int): Int {\n    for (i in 1..100000000) {\n        val result = i * (i + 1) / 2\n        var count = 0\n        for (j in 1..sqrt(result).toInt()) {\n            if (result % j == 0) {\n                count += 2\n            }\n            if (j * j == result) {\n                count -= 1\n            }\n        }\n        if (count > n) {\n            return result\n        }\n    }\n    return -1\n}",
                "fun largeSum(numbers: List<String>): String {\n    val digits = IntArray(60) { 0 }\n    for (i in 0 until 50) {\n        var tmp = 0\n        for (num in numbers) {\n            tmp += num[49 - i].toInt()\n        }\n        for (j in i until 60) {\n            digits[j] += tmp % 10\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if tmp == 0 {\n                break\n            }\n        }\n    }\n    for (i in 59 downTo 0) {\n        if digits[i]!= 0 {\n            var result = \"\"\n            for (j in i downTo i - 10) {\n                result += digits[j].toString()\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
                "fun longestCollatzSequence(n: Int): Int {\n    var longest = 0\n    var result = 0\n    for (i in 1 until n) {\n        var chain = 1\n        var num = i\n        while (num!= 1) {\n            if (num % 2 == 0) {\n                num /= 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain++\n        }\n        if (chain > longest) {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
                "fun latticePaths(m: Int, n: Int): Int {\n    val grid = Array(m + 1) { IntArray(n + 1) }\n    for (i in 0 until m + 1) {\n        grid[i][0] = 1\n    }\n    for (j in 0 until n + 1) {\n        grid[0][j] = 1\n    }\n    for (i in 1 until m + 1) {\n        for (j in 1 until n + 1) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
                "fun powerDigitSum(n: Int): Int {\n    val digits = mutableListOf(2)\n    for (_ in 1 until n) {\n        var carry = 0\n        for (j in digits.indices) {\n            val temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if (carry!= 0) {\n            digits.add(carry)\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun numberToWords(n: Int): String {\n    val ones = listOf(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val teens = listOf(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n    val tens = listOf(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n    if (n == 1000) {\n        return \"one thousand\"\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\"\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100)\n        }\n    } else if (n >= 20) {\n        var suf = \"\"\n        if (n % 10!= 0) {\n            suf = \" \" + ones[n % 10]\n        }\n        return tens[n / 10] + suf\n    } else if (n >= 10) {\n        return teens[n - 10]\n    } else {\n        return ones[n]\n    }\n}",
                "fun maximumPathSumI(triangle: List<List<Int>>): Int {\n    val curr = triangle.last().toMutableList()\n    for (i in triangle.size - 2 downTo 0) {\n        val next = triangle[i].toMutableList()\n        for (j in next.indices) {\n            next[j] += maxOf(curr[j], curr[j + 1])\n        }\n        curr.clear()\n        curr.addAll(next)\n    }\n    return curr[0]\n}",
                "fun countingSundays(y1: Int, y2: Int): Int {\n    var day = 0\n    var count = 0\n    for (year in 1900 until y2 + 1) {\n        for (month in 1..12) {\n            if (year >= y1 && day % 7 == 6) {\n                count++\n            }\n            if (month in listOf(4, 6, 9, 11)) {\n                day += 30\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
                "fun factorialDigitSum(n: Int): Int {\n    val digits = mutableListOf(1)\n    for (i in 1 until n + 1) {\n        var carry = 0\n        for (j in digits.indices) {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        while (carry > 0) {\n            digits.add(carry % 10)\n            carry /= 10\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
                "fun d(n: Int): Int {\n    var result = 1\n    for (i in 2..sqrt(n).toInt()) {\n        if (n % i == 0) {\n            result += i\n            if (i!= n / i) {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfun amicableNumbers(n: Int): Int {\n    var result = 0\n    for (a in 2..n) {\n        val b = d(a)\n        if (a!= b && a == d(b)) {\n            result += a\n        }\n    }\n    return result\n}",
                "fun namesScores(names: List<String>, queries: List<String>): Int {\n    val sNames = names.sorted()\n    var result = 0\n    for (i in sNames.indices) {\n        var x = 0\n        for (c in sNames[i]) {\n            x += c.toInt() - 64\n        }\n        if (sNames[i] in queries) {\n            result += x * (i + 1)\n        }\n    }\n    return result\n}",
                "fun isAbundant(n: Int): Boolean {\n    if (n < 12) {\n        return false\n    }\n    var sumDivisors = 1\n    for (i in 2 until sqrt(n).toInt() + 1) {\n        if (n % i == 0) {\n            sumDivisors += i\n            if (i!= n / i) {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfun nonAbundantSums(n: Int): Int {\n    val abundants = mutableListOf<Int>()\n    for (i in 12 until n) {\n        if (isAbundant(i)) {\n            abundants.add(i)\n        }\n    }\n    val abundantSums = mutableSetOf<Int>()\n    for (i in abundants) {\n        for (j in abundants) {\n            abundantSums.add(i + j)\n        }\n    }\n    var result = 0\n    for (i in 0 until n) {\n        if (i!in abundantSums) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun lexicographicPermutations(n: Int): String {\n    val result = StringBuilder()\n    val digits = listOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n    var x = n - 1\n    for (i in 10 downTo 1) {\n        val fact = (1..i).fold(1) { acc, i -> acc * i }\n        val idx = x / fact\n        result.append(digits[idx])\n        digits.removeAt(idx)\n        x -= idx * fact\n    }\n    return result.toString()\n}",
                "fun nDigitFibonacciNumber(n: Int): Int {\n    val a = mutableListOf(1)\n    val b = mutableListOf(1)\n    var i = 2\n    while (b.size < n) {\n        var carry = 0\n        val c = b.toMutableList()\n        for (j in b.indices) {\n            if (j < a.size) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if (carry > 0) {\n            b.add(carry)\n        }\n        a = c\n        i++\n    }\n    return i\n}",
                "fun reciprocalCycles(n: Int): Int {\n    var result = 0\n    var maxLength = 0\n    for (i in 1 until n) {\n        val remainders = mutableListOf<Int>()\n        var remainder = 1\n        while (remainder!= 0 && remainder!in remainders) {\n            remainders.add(remainder)\n            remainder = (remainder * 10) % i\n        }\n        var length = 0\n        if (remainder!= 0) {\n            length = remainders.size - remainders.indexOf(remainder)\n        }\n        if (length > maxLength) {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3 until sqrt(n).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun quadraticPrimes(n: Int): Int {\n    var maxPrimes = 0\n    var result = 0\n    for (a in -n + 1 until n step 2) {\n        for (b in -n + 1 until n step 2) {\n            var x = 0\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break\n                }\n                x += 1\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
                "fun numberSpiralDiagonals(n: Int): Int {\n    var result = 1\n    for (i in 3 until n + 1 step 2) {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
                "fun distinctPowers(n: Int): Int {\n    var result = 0\n    val xs = mutableSetOf<String>()\n    for (i in 2 until n + 1) {\n        val primes = listOf(2, 3, 5, 7)\n        val powers = mutableListOf(0, 0, 0, 0)\n        var num = i\n        for (j in primes.indices) {\n            while (num % primes[j] == 0) {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if (num!= 1) {\n            result += n - 1\n            continue\n        }\n        for (j in 2 until n + 1) {\n            val pstr = \"${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}\"\n            xs.add(pstr)\n        }\n    }\n    result += xs.size\n    return result\n}",
                "fun digitNthPowers(n: Int): Int {\n    var result = 0\n    for (i in 2..4 * 10.0.pow(n).toInt()) {\n        var digitsSum = 0\n        for (digit in i.toString()) {\n            digitsSum += digit.toInt().pow(n).toInt()\n        }\n        if (i == digitsSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun coinSums(n: Int): Int {\n    val coins = listOf(1, 2, 5, 10, 20, 50, 100, 200)\n    val ways = IntArray(n + 1)\n    ways[0] = 1\n    for (coin in coins) {\n        for (i in coin until n + 1) {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
                "fun pandigitalProducts(n: Int): Int {\n    val products = mutableSetOf<Int>()\n    val s = (1..n).joinToString(\"\")\n    for (a in 1..99) {\n        for (b in 1..9999) {\n            val c = a * b\n            val chars = listOf(a, b, c).joinToString(\"\").toCharArray().sortedArray()\n            if (chars.joinToString(\"\") == s) {\n                products.add(c)\n            }\n        }\n    }\n    var result = 0\n    for (product in products) {\n        result += product\n    }\n    return result\n}",
                "fun digitCancelingFractions(m: Int): Int {\n    var numer = 1\n    var denom = 1\n    for (d in 10 until m) {\n        for (n in 10 until d) {\n            val n0 = n % 10\n            val n1 = n / 10\n            val d0 = d % 10\n            val d1 = d / 10\n            if (n1 == d0 && n0 * d == n * d1) {\n                numer *= n\n            } else if (n0 == d1 && n1 * d == n * d0) {\n                numer *= n\n            }\n            denom *= d\n        }\n    }\n    var a = numer\n    var b = denom\n    while (b!= 0) {\n        val temp = b\n        b = a % b\n        a = temp\n    }\n    return denom / a\n}",
                "fun digitFactorials(n: Int): Int {\n    var result = 0\n    for (i in 3 until n) {\n        var factSum = 0\n        for (digit in i.toString()) {\n            var fact = 1\n            for (j in 1..digit.toInt()) {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if (i == factSum) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3 until sqrt(n).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun circularPrimes(n: Int): Int {\n    var count = 0\n    for (i in 2 until n) {\n        if (isPrime(i)) {\n            val rotations = mutableSetOf<Int>()\n            for (j in 0 until str(i).length) {\n                rotations.add(str(i).substring(j) + str(i).substring(0, j).toInt())\n            }\n            var flag = true\n            for (x in rotations) {\n                if (!isPrime(x)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                count += 1\n            }\n        }\n    }\n    return count\n}",
                "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i]!= s[s.length - 1 - i]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun doubleBasePalindromes(n: Int): Int {\n    var result = 0\n    for (i in 1 until n) {\n        val strI = i.toString()\n        val binI = Integer.toBinaryString(i)\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i\n        }\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3 until sqrt(n).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun truncatablePrimes(n: Int): Int {\n    var result = 0\n    for (i in 10 until n) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            var flag = true\n            for (j in 1 until si.length) {\n                val p1 = si.substring(j).toInt()\n                val p2 = si.substring(0, si.length - j).toInt()\n                if (!isPrime(p1) ||!isPrime(p2)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                result += i\n            }\n        }\n    }\n    return result\n}",
                "fun pandigitalMultiples(n: Int): Int {\n    var result = -1\n    for (i in 2..n) {\n        var cprod = \"\"\n        for (j in 1..9) {\n            cprod += i * j\n            if (cprod.length == 9) {\n                if (cprod.sorted() == \"123456789\") {\n                    result = max(result, cprod.toInt())\n                    break\n                }\n            } else if (cprod.length > 9) {\n                break\n            }\n        }\n    }\n    return result\n}",
                "fun integerRightTriangles(n: Int): Int {\n    var maxSol = 0\n    var result = 0\n    for (p in 3..n) {\n        var sol = 0\n        for (a in 1..p / 2) {\n            for (b in a..p / 2) {\n                val c = p - a - b\n                if a * a + b * b == c * c {\n                    sol += 1\n                }\n            }\n        }\n        if sol > maxSol {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
                "fun champernowneConstant(b: Int): Int {\n    var s = \"\"\n    for (i in 1..b.toDouble().pow(6).toInt()) {\n        s += i.toString()\n    }\n    var result = 1\n    for (i in 7 downTo 1) {\n        result *= s[b.toDouble().pow(i - 1).toInt() - 1].toInt()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3 until sqrt(n).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun pandigitalPrime(n: Int): Int {\n    for (i in n downTo 1) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            val length = si.length\n            var flag = true\n            for (j in 1..length) {\n                if (j.toString()!in si) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                return i\n            }\n        }\n    }\n    return -1\n}",
                "fun codedTriangleNumbers(words: List<String>): Int {\n    var result = 0\n    for (word in words) {\n        var value = 0\n        for (c in word) {\n            value += c.toInt() - 64\n        }\n        val n = kotlin.math.sqrt(value * 2.0).toInt()\n        if (n * (n + 1) == value * 2) {\n            result += 1\n        }\n    }\n    return result\n}",
                "fun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return s\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun subStringDivisibility(n: Int): Int {\n    var result = 0\n    val primes = listOf(2, 3, 5, 7, 11, 13, 17)\n    val s = (0 until n + 1).joinToString(\"\")\n    for (i in genPermutations(s)) {\n        var flag = true\n        for (j in 1 until n - 1) {\n            if (i.substring(j, j + 3).toInt() % primes[j - 1]!= 0) {\n                flag = false\n                break\n            }\n        }\n        if (flag) {\n            result += i.toInt()\n        }\n    }\n    return result\n}",
                "fun pentagonNumbers(n: Int): Int {\n    val pentagon = mutableSetOf<Int>()\n    for (i in 1 until n) {\n        pentagon.add(i * (3 * i - 1) / 2)\n    }\n    var result = -1\n    for (j in pentagon) {\n        for (k in pentagon) {\n            if (j + k in pentagon && k - j in pentagon) {\n                if (result == -1 || k - j < result) {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
                "fun triangularPentagonalAndHexagonal(n: Int): Int {\n    val ps = mutableSetOf<Int>()\n    var i = 1\n    var c = 0.5 * i * (3 * i - 1)\n    while (c < n) {\n        i += 1\n        ps.add(c)\n        c = 0.5 * i * (3 * i - 1)\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    var result = -1\n    while (c < n) {\n        i += 1\n        if (c in ps) {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3 until sqrt(n).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun goldbachsOtherConjecture(n: Int): Int {\n    var result = -1\n    for (i in 9999 downTo n step 2) {\n        val upper = sqrt(i / 2.0).toInt()\n        var flag = false\n        for (j in 0..upper) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true\n                break\n            }\n        }\n        if (!flag) {\n            result = i\n        }\n    }\n    return result\n}",
                "fun primeFactors(n: Int): Int {\n    var num = n\n    val factors = mutableListOf<Int>()\n    var i = 2\n    while (i * i <= num) {\n        if (num % i == 0) {\n            num /= i\n            factors.add(i)\n        } else {\n            i++\n        }\n    }\n    if (num > 1) {\n        factors.add(num)\n    }\n    return factors.size\n}\n\nfun distinctPrimesFactors(n: Int): Int {\n    for (i in n until 1000000) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i\n        }\n    }\n    return -1\n}",
                "fun selfPowers(n: Int): String {\n    val digits = IntArray(10)\n    for (i in 1..n) {\n        val tempDigits = IntArray(10)\n        tempDigits[0] = 1\n        for (j in 0 until i) {\n            var carry = 0\n            for (k in 0 until 10) {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for (j in 0 until 10) {\n            digits[j] += tempDigits[j]\n            if digits[j] >= 10 {\n                digits[j] -= 10\n                if j < 9 {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    var result = \"\"\n    for (i in 9 downTo 0) {\n        result += digits[i].toString()\n    }\n    return result\n}",
                "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3 until sqrt(n).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in 0 until s.length) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun primePermutations(n: Int): String {\n    for (i in n downTo 999 step 1) {\n        if (isPrime(i)) {\n            val permutations = genPermutations(i.toString())\n            val candidates = mutableSetOf<Int>()\n            for (j in permutations) {\n                val candidate = j.toInt()\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.add(candidate)\n                }\n            }\n            for (m in candidates) {\n                if (m + (m - i) in candidates) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString()\n                }\n            }\n        }\n    }\n    return \"\"\n}",
                "fun consecutivePrimeSum(limit: Int): Int {\n    val sieve = BooleanArray(limit) { true }\n    val primes = mutableListOf<Int>()\n    for (i in 2 until limit) {\n        if (sieve[i]) {\n            primes.add(i)\n            for (j in i * 2 until limit step i) {\n                sieve[j] = false\n            }\n        }\n    }\n    var maxLength = 0\n    var maxPrime = 0\n    for (i in primes.indices) {\n        for (j in i + maxLength until primes.size) {\n            val s = primes.subList(i, j).sum()\n            if (s >= limit) {\n                break\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
            ],
            "php": [
                "function multiplesOf3And5($n) {\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 3 === 0 || $i % 5 === 0) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function evenFibonacciNumbers($n) {\n    $result = 0;\n    $a = 1;\n    $b = 2;\n    while ($a < $n) {\n        if ($a % 2 === 0) {\n            $result += $a;\n        }\n        $tmp = $a;\n        $a = $b;\n        $b = $tmp + $b;\n    }\n    return $result;\n}",
                "function largestPrimeFactor($n) {\n    $result = $n;\n    $i = 2;\n    while ($i * $i <= $result) {\n        if ($result % $i) {\n            $i += 1;\n        } else {\n            $result = intval($result / $i);\n        }\n    }\n    return $result;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i]!== $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction largestPalindromeProduct($n) {\n    $result = 0;\n    for ($i = 100; $i < 1000; $i++) {\n        for ($j = $i; $j < 1000; $j++) {\n            $prod = $i * $j;\n            if (isPalindrome(strval($prod)) && $prod > $result && $prod < $n) {\n                $result = $prod;\n            }\n        }\n    }\n    return $result;\n}",
                "function smallestMultiple($n) {\n    $result = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($result % $i!== 0) {\n            for ($j = 1; $j <= $n; $j++) {\n                if (($result * $j) % $i === 0) {\n                    $result *= $j;\n                    break;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function sumSquareDifference($n) {\n    $sqrSum = 0;\n    $numSum = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $sqrSum += $i * $i;\n        $numSum += $i;\n    }\n    return $numSum * $numSum - $sqrSum;\n}",
                "function nthPrime($n) {\n    $primes = [2];\n    $i = 3;\n    while (count($primes) < $n) {\n        foreach ($primes as $p) {\n            if ($i % $p === 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    return $primes[count($primes) - 1];\n}",
                "function largestProductInASeries($s, $k) {\n    $result = 0;\n    for ($i = 0; $i < strlen($s) - $k; $i++) {\n        $product = 1;\n        for ($j = 0; $j < $k; $j++) {\n            $product *= intval(substr($s, $i + $j, 1));\n        }\n        $result = max($result, $product);\n    }\n    return $result;\n}",
                "function specialPythagoreanTriplet($n) {\n    for ($a = 1; $a < $n; $a++) {\n        for ($b = $a; $b < $n; $b++) {\n            $c = $n - $a - $b;\n            if ($a * $a + $b * $b === $c * $c) {\n                return $a * $b * $c;\n            }\n        }\n    }\n    return -1;\n}",
                "function summationOfPrimes($n) {\n    $primes = [2];\n    $i = 3;\n    while ($i <= $n) {\n        foreach ($primes as $p) {\n            if ($i % $p === 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                array_push($primes, $i);\n                break;\n            }\n        }\n        $i += 2;\n    }\n    $result = 0;\n    foreach ($primes as $prime) {\n        $result += $prime;\n    }\n    return $result;\n}",
                "function largestProductInAGrid($grid) {\n    $result = 0;\n    for ($i = 0; $i < count($grid) - 3; $i++) {\n        for ($j = 0; $j < count($grid[$i]) - 3; $j++) {\n            $p1 = 1;\n            $p2 = 1;\n            $p3 = 1;\n            $p4 = 1;\n            for ($k = 0; $k < 4; $k++) {\n                $p1 *= $grid[$i + $k][$j];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p2 *= $grid[$i][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p3 *= $grid[$i + $k][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p4 *= $grid[$i + $k][$j + 3 - $k];\n            }\n            $result = max($result, $p1, $p2, $p3, $p4);\n        }\n    }\n    return $result;\n}",
                "function highlyDivisibleTriangularNumber($n) {\n    for ($i = 1; $i < 100000000; $i++) {\n        $result = $i * ($i + 1) / 2;\n        $count = 0;\n        for ($j = 1; intval(sqrt($result)) + 1 >= $j; $j++) {\n            if ($result % $j === 0) {\n                $count += 2;\n            }\n            if ($j * $j === $result) {\n                $count -= 1;\n            }\n        }\n        if ($count > $n) {\n            return intval($result);\n        }\n    }\n    return -1;\n}",
                "function largeSum($numbers) {\n    $digits = array_fill(0, 60, 0);\n    for ($i = 0; $i < 50; $i++) {\n        $tmp = 0;\n        foreach ($numbers as $num) {\n            $tmp += intval(substr($num, 49 - $i));\n        }\n        for ($j = $i; $j < 60; $j++) {\n            $digits[$j] += $tmp % 10;\n            if ($digits[$j] >= 10) {\n                $digits[$j + 1] += $digits[$j] / 10;\n                $digits[$j] %= 10;\n            }\n            $tmp = floor($tmp / 10);\n            if ($tmp == 0) {\n                break;\n            }\n        }\n    }\n    for ($i = 59; $i >= 0; $i--) {\n        if ($digits[$i]!= 0) {\n            $result = '';\n            for ($j = $i; $j >= $i - 10; $j--) {\n                $result.= strval($digits[$j]);\n            }\n            return $result;\n        }\n    }\n}",
                "function longestCollatzSequence($n) {\n    $longest = 0;\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $chain = 1;\n        $num = $i;\n        while ($num!== 1) {\n            if ($num % 2 === 0) {\n                $num = $num / 2;\n            } else {\n                $num = 3 * $num + 1;\n            }\n            $chain += 1;\n        }\n        if ($chain > $longest) {\n            $longest = $chain;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function latticePaths($m, $n) {\n    $grid = [];\n    for ($i = 0; $i <= $m; $i++) {\n        $grid[$i] = array_fill(0, $n + 1, 0);\n    }\n    for ($i = 0; $i <= $m; $i++) {\n        $grid[0][$i] = 1;\n    }\n    for ($i = 1; $i <= $m; $i++) {\n        for ($j = 1; $j <= $n; $j++) {\n            $grid[$i][$j] = $grid[$i - 1][$j] + $grid[$i][$j - 1];\n        }\n    }\n    return $grid[$m][$n];\n}",
                "function powerDigitSum($n) {\n    $digits = [2];\n    for ($i = 1; $i < $n; $i++) {\n        $carry = 0;\n        foreach ($digits as $j => $digit) {\n            $temp = $digit * 2 + $carry;\n            $digits[$j] = $temp % 10;\n            $carry = $temp // 10;\n        }\n        if ($carry) {\n            array_push($digits, $carry);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function numberToWords($n) {\n    $ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    $teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    $tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if ($n === 1000) {\n        return \"one thousand\";\n    } elseif ($n >= 100) {\n        if ($n % 100 === 0) {\n            return $ones[$n // 100]. \" hundred\";\n        } else {\n            return $ones[$n // 100]. \" hundred and \". numberToWords($n % 100);\n        }\n    } elseif ($n >= 20) {\n        $suf = \"\";\n        if ($n % 10!== 0) {\n            $suf = \" \". $ones[$n % 10];\n        }\n        return $tens[$n // 10]. $suf;\n    } elseif ($n >= 10) {\n        return $teens[$n - 10];\n    } else {\n        return $ones[$n];\n    }\n}",
                "function maximumPathSumI($triangle) {\n    $curr = $triangle[count($triangle) - 1];\n    for ($i = count($triangle) - 2; $i >= 0; $i--) {\n        $next = $triangle[$i];\n        for ($j = 0; $j < count($next); $j++) {\n            $next[$j] += max($curr[$j], $curr[$j + 1]);\n        }\n        $curr = $next;\n    }\n    return $curr[0];\n}",
                "function countingSundays($y1, $y2) {\n    $day = 0;\n    $count = 0;\n    for ($year = 1900; $year <= $y2; $year++) {\n        for ($month = 1; $month <= 12; $month++) {\n            if ($year >= $y1 && $day % 7 === 6) {\n                $count += 1;\n            }\n            if ($month === 4 || $month === 6 || $month === 9 || $month === 11) {\n                $day += 30;\n            } elseif ($month === 2) {\n                if ($year % 4 === 0 && ($year % 100!== 0 || $year % 400 === 0)) {\n                    $day += 29;\n                } else {\n                    $day += 28;\n                }\n            } else {\n                $day += 31;\n            }\n        }\n    }\n    return $count;\n}",
                "function factorialDigitSum($n) {\n    $digits = [1];\n    for ($i = 1; $i <= $n; $i++) {\n        $carry = 0;\n        foreach ($digits as $j => $digit) {\n            $digits[$j] = $digit * $i + $carry;\n            $carry = intval($digits[$j] / 10);\n            $digits[$j] %= 10;\n        }\n        while ($carry) {\n            array_push($digits, $carry % 10);\n            $carry = intval($carry / 10);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
                "function d($n) {\n    $result = 1;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i === 0) {\n            $result += $i;\n            if ($i!== $n / $i) {\n                $result += $n / $i;\n            }\n        }\n    }\n    return $result;\n}\n\nfunction amicableNumbers($n) {\n    $result = 0;\n    for ($a = 2; $a <= $n; $a++) {\n        $b = d($a);\n        if ($a!== $b && $a === d($b)) {\n            $result += $a;\n        }\n    }\n    return $result;\n}",
                "function namesScores($names, $queries) {\n    $sNames = $names;\n    sort($sNames);\n    $result = 0;\n    for ($i = 0; $i < count($sNames); $i++) {\n        $x = 0;\n        foreach (str_split($sNames[$i]) as $c) {\n            $x += ord($c) - 64;\n        }\n        if (in_array($sNames[$i], $queries)) {\n            $result += $x * ($i + 1);\n        }\n    }\n    return $result;\n}",
                "function isAbundant($n) {\n    if ($n < 12) {\n        return false;\n    }\n    $sumDivisors = 1;\n    for ($i = 2; $i <= intval(sqrt($n)); $i++) {\n        if ($n % $i === 0) {\n            $sumDivisors += $i;\n            if ($i!== $n / $i) {\n                $sumDivisors += $n / $i;\n            }\n        }\n    }\n    return $sumDivisors > $n;\n}\n\nfunction nonAbundantSums($n) {\n    $abundants = [];\n    for ($i = 12; $i <= $n; $i++) {\n        if (isAbundant($i)) {\n            array_push($abundants, $i);\n        }\n    }\n    $abundantSums = [];\n    foreach ($abundants as $i) {\n        foreach ($abundants as $j) {\n            array_push($abundantSums, $i + $j);\n        }\n    }\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!in_array($i, $abundantSums)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function lexicographicPermutations($n) {\n    $result = '';\n    $digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    $x = $n - 1;\n    for ($i = 10; $i > 0; $i--) {\n        $fact = 1;\n        for ($j = 1; $j < $i; $j++) {\n            $fact *= $j;\n        }\n        $idx = $x / $fact;\n        $result.= strval($digits[$idx]);\n        array_splice($digits, $idx, 1);\n        $x -= $idx * $fact;\n    }\n    return $result;\n}",
                "function nDigitFibonacciNumber($n) {\n    $a = [1];\n    $b = [1];\n    $i = 2;\n    while (count($b) < $n) {\n        $carry = 0;\n        $c = $b;\n        for ($j = 0; $j < count($b); $j++) {\n            if ($j < count($a)) {\n                $b[$j] = $a[$j] + $b[$j] + $carry;\n            } else {\n                $b[$j] = $b[$j] + $carry;\n            }\n            $carry = $b[$j] / 10;\n            $b[$j] = $b[$j] % 10;\n        }\n        if ($carry) {\n            array_push($b, $carry);\n        }\n        $a = $c;\n        $i = $i + 1;\n    }\n    return $i;\n}",
                "function reciprocalCycles($n) {\n    $result = 0;\n    $max_length = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $remainders = [];\n        $remainder = 1;\n        while ($remainder!== 0 &&!in_array($remainder, $remainders)) {\n            array_push($remainders, $remainder);\n            $remainder = ($remainder * 10) % $i;\n        }\n        $length = 0;\n        if ($remainder!== 0) {\n            $length = count($remainders) - array_search($remainder, $remainders);\n        }\n        if ($length > $max_length) {\n            $max_length = $length;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction quadraticPrimes($n) {\n    $maxPrimes = 0;\n    $result = 0;\n    for ($a = -$n + 1; $a <= $n; $a += 2) {\n        for ($b = -$n + 1; $b <= $n; $b += 2) {\n            $x = 0;\n            while (true) {\n                if ($x * $x + $a * $x + $b < 2) {\n                    break;\n                }\n                if (!isPrime($x * $x + $a * $x + $b)) {\n                    break;\n                }\n                $x += 1;\n            }\n            if ($x > $maxPrimes) {\n                $maxPrimes = $x;\n                $result = $a * $b;\n            }\n        }\n    }\n    return $result;\n}",
                "function numberSpiralDiagonals($n) {\n    $result = 1;\n    for ($i = 3; $i <= $n; $i += 2) {\n        $result += 4 * $i * $i - 6 * $i + 6;\n    }\n    return $result;\n}",
                "function distinctPowers($n) {\n    $result = 0;\n    $xs = [];\n    for ($i = 2; $i <= $n; $i++) {\n        $primes = [2, 3, 5, 7];\n        $powers = [0, 0, 0, 0];\n        $num = $i;\n        for ($j = 0; $j < count($primes); $j++) {\n            while ($num % $primes[$j] === 0) {\n                $num //= $primes[$j];\n                $powers[$j] += 1;\n            }\n        }\n        if ($num!== 1) {\n            $result += $n - 1;\n            continue;\n        }\n        for ($j = 2; $j <= $n; $j++) {\n            $pstr = sprintf(\"%d-%d-%d-%d\", $powers[0] * $j, $powers[1] * $j, $powers[2] * $j, $powers[3] * $j);\n            if (!in_array($pstr, $xs)) {\n                array_push($xs, $pstr);\n            }\n        }\n    }\n    $result += count($xs);\n    return $result;\n}",
                "function digitNthPowers($n) {\n    $result = 0;\n    for ($i = 2; $i < 4 * 10 ** $n; $i++) {\n        $digitsSum = 0;\n        foreach (str($i) as $digit) {\n            $digitsSum += intval($digit) ** $n;\n        }\n        if ($i === $digitsSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function coinSums($n) {\n    $coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    $ways = array_fill(0, $n + 1, 0);\n    $ways[0] = 1;\n    foreach ($coins as $coin) {\n        for ($i = $coin; $i <= $n; $i++) {\n            $ways[$i] += $ways[$i - $coin];\n        }\n    }\n    return $ways[$n];\n}",
                "function pandigitalProducts($n) {\n    $products = [];\n    $s = implode('', range(1, $n+1));\n    for ($a = 1; $a < 100; $a++) {\n        for ($b = 1; $b < 10000; $b++) {\n            $c = $a * $b;\n            $chars = str_split(strval($a). strval($b). strval($c));\n            sort($chars);\n            if (implode('', $chars) === $s) {\n                array_push($products, $c);\n            }\n        }\n    }\n    $result = 0;\n    foreach ($products as $product) {\n        $result += $product;\n    }\n    return $result;\n}",
                "function digitCancelingFractions($m) {\n    $numer = 1;\n    $denom = 1;\n    for ($d = 10; $d < $m; $d++) {\n        for ($n = 10; $n < $d; $n++) {\n            $n0 = $n % 10;\n            $n1 = $n // 10;\n            $d0 = $d % 10;\n            $d1 = $d // 10;\n            if (($n1 == $d0 and $n0 * $d == $n * $d1) or ($n0 == $d1 and $n1 * $d == $n * $d0)) {\n                $numer *= $n;\n                $denom *= $d;\n            }\n        }\n    }\n    $a = $numer;\n    $b = $denom;\n    while ($b) {\n        $a = $b;\n        $b = $a % $b;\n    }\n    return $denom // $a;\n}",
                "function digitFactorials($n) {\n    $result = 0;\n    for ($i = 3; $i < $n; $i++) {\n        $factSum = 0;\n        foreach (strval($i) as $digit) {\n            $fact = 1;\n            for ($j = 1; $j < intval($digit) + 1; $j++) {\n                $fact *= $j;\n            }\n            $factSum += $fact;\n        }\n        if ($i == $factSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction circularPrimes($n) {\n    $count = 0;\n    for ($i = 2; $i <= $n; $i++) {\n        if (isPrime($i)) {\n            $rotations = [];\n            for ($j = 0; $j < strlen(strval($i)); $j++) {\n                array_push($rotations, intval(substr(strval($i), $j). substr(strval($i), 0, $j)));\n            }\n            $flag = true;\n            foreach ($rotations as $x) {\n                if (!isPrime($x)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}",
                "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i]!== $s[strlen($s) - 1 - $i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction doubleBasePalindromes($n) {\n    $result = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $str_i = strval($i);\n        $bin_i = strval(bindec($i));\n        if (isPalindrome($str_i) && isPalindrome($bin_i)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction truncatablePrimes($n) {\n    $result = 0;\n    for ($i = 10; $i <= $n; $i++) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $flag = true;\n            for ($j = 1; $j < strlen($si); $j++) {\n                $p1 = intval(substr($si, $j));\n                $p2 = intval(substr($si, 0, $j));\n                if (!isPrime($p1) ||!isPrime($p2)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $result += $i;\n            }\n        }\n    }\n    return $result;\n}",
                "function pandigitalMultiples($n) {\n    $result = -1;\n    for ($i = 2; $i <= $n; $i++) {\n        $cprod = '';\n        for ($j = 1; $j <= 9; $j++) {\n            $cprod.= strval($i * $j);\n            if (strlen($cprod) === 9) {\n                if (join('', array_unique(str_split($cprod))) === '123456789') {\n                    $result = max($result, intval($cprod));\n                    break;\n                }\n            } elseif (strlen($cprod) > 9) {\n                break;\n            }\n        }\n    }\n    return $result;\n}",
                "function integerRightTriangles($n) {\n    $maxSol = 0;\n    $result = 0;\n    for ($p = 3; $p <= $n; $p++) {\n        $sol = 0;\n        for ($a = 1; $a < $p / 2; $a++) {\n            for ($b = $a; $b < $p / 2; $b++) {\n                $c = $p - $a - $b;\n                if ($a * $a + $b * $b === $c * $c) {\n                    $sol += 1;\n                }\n            }\n        }\n        if ($sol > $maxSol) {\n            $maxSol = $sol;\n            $result = $p;\n        }\n    }\n    return $result;\n}",
                "function champernowneConstant($b) {\n    $s = '';\n    for ($i = 1; $i < pow($b, 6); $i++) {\n        $s.= strval($i);\n    }\n    $result = 1;\n    for ($i = 7; $i >= 0; $i--) {\n        $result *= intval(substr($s, pow($b, $i) - 1, 1));\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction pandigitalPrime($n) {\n    for ($i = $n - 1; $i > 0; $i--) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $length = strlen($si);\n            $flag = true;\n            for ($j = 1; $j <= $length; $j++) {\n                if (strval($j)!== $si[$j - 1]) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                return $i;\n            }\n        }\n    }\n    return -1;\n}",
                "function codedTriangleNumbers($words) {\n    $result = 0;\n    foreach ($words as $word) {\n        $value = 0;\n        foreach (str_split($word) as $c) {\n            $value += ord($c) - 64;\n        }\n        $n = intval(sqrt($value * 2));\n        if ($n * ($n + 1) === $value * 2) {\n            $result += 1;\n        }\n    }\n    return $result;\n}",
                "function genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return $s;\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, $perm. substr($s, 0, 1). substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction subStringDivisibility($n) {\n    $result = 0;\n    $primes = [2, 3, 5, 7, 11, 13, 17];\n    $s = implode('', range(0, $n));\n    foreach (genPermutations($s) as $i) {\n        $flag = true;\n        for ($j = 1; $j < $n - 1; $j++) {\n            if (intval(substr($i, $j, 3)) % $primes[$j - 1]!== 0) {\n                $flag = false;\n                break;\n            }\n        }\n        if ($flag) {\n            $result += intval($i);\n        }\n    }\n    return $result;\n}",
                "function pentagonNumbers($n) {\n    $pentagon = [];\n    for ($i = 1; $i < $n; $i++) {\n        array_push($pentagon, $i * ($i * 3 - 1) / 2);\n    }\n    $result = -1;\n    foreach ($pentagon as $j) {\n        foreach ($pentagon as $k) {\n            if (in_array($j + $k, $pentagon) && in_array($k - $j, $pentagon)) {\n                if ($result === -1 || $k - $j < $result) {\n                    $result = $k - $j;\n                }\n            }\n        }\n    }\n    return $result;\n}",
                "function triangularPentagonalAndHexagonal($n) {\n    $ps = [];\n    $i = 1;\n    $c = 0.5 * $i * (3 * $i - 1);\n    while ($c < $n) {\n        $i += 1;\n        array_push($ps, $c);\n        $c = 0.5 * $i * (3 * $i - 1);\n    }\n    $i = 1;\n    $c = $i * (2 * $i - 1);\n    $result = -1;\n    while ($c < $n) {\n        $i += 1;\n        if (in_array($c, $ps)) {\n            $result = $c;\n        }\n        $c = $i * (2 * $i - 1);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction goldbachsOtherConjecture($n) {\n    $result = -1;\n    for ($i = 9999; $i >= $n; $i -= 2) {\n        $upper = intval(sqrt($i / 2));\n        $flag = false;\n        for ($j = 0; $j <= $upper; $j++) {\n            if (isPrime($i - 2 * $j * $j)) {\n                $flag = true;\n                break;\n            }\n        }\n        if (!$flag) {\n            $result = $i;\n        }\n    }\n    return $result;\n}",
                "function primeFactors($n) {\n    $num = $n;\n    $factors = [];\n    $i = 2;\n    while ($i * $i <= $num) {\n        if ($num % $i) {\n            $i += 1;\n        } else {\n            $num /= $i;\n            array_push($factors, $i);\n        }\n    }\n    if ($num > 1) {\n        array_push($factors, $num);\n    }\n    return count(array_unique($factors));\n}\n\nfunction distinctPrimesFactors($n) {\n    for ($i = $n; $i < 1000000; $i++) {\n        if (primeFactors($i) === 4 && primeFactors($i + 1) === 4 && primeFactors($i + 2) === 4 && primeFactors($i + 3) === 4) {\n            return $i;\n        }\n    }\n    return -1;\n}",
                "function selfPowers($n) {\n    $digits = array_fill(0, 10, 0);\n    for ($i = 1; $i <= $n; $i++) {\n        $tempDigits = array_fill(0, 10, 0);\n        $tempDigits[0] = 1;\n        for ($j = 0; $j < $i; $j++) {\n            $carry = 0;\n            for ($k = 0; $k < 10; $k++) {\n                $tempDigits[$k] = $tempDigits[$k] * $i + $carry;\n                $carry = intval($tempDigits[$k] / 10);\n                $tempDigits[$k] %= 10;\n            }\n        }\n        for ($j = 0; $j < 10; $j++) {\n            $digits[$j] += $tempDigits[$j];\n            if ($digits[$j] >= 10) {\n                $digits[$j] -= 10;\n                if ($j < 9) {\n                    $digits[$j + 1] += 1;\n                }\n            }\n        }\n    }\n    $result = \"\";\n    for ($i = 9; $i >= 0; $i--) {\n        $result.= strval($digits[$i]);\n    }\n    return $result;\n}",
                "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return $s;\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            array_push($result, $perm. substr($s, 0, 1). substr($perm, $i));\n        }\n    }\n    return $result;\n}\n\nfunction primePermutations($n) {\n    for ($i = $n; $i >= 999; $i -= 1) {\n        if (isPrime($i)) {\n            $permutations = genPermutations(strval($i));\n            $candidates = [];\n            foreach ($permutations as $j) {\n                $candidate = intval($j);\n                if ($candidate > $i && isPrime($candidate)) {\n                    array_push($candidates, $candidate);\n                }\n            }\n            foreach ($candidates as $m) {\n                if ($m + ($m - $i) in $candidates) {\n                    return strval($i). strval($m). strval($m + ($m - $i));\n                }\n            }\n        }\n    }\n    return '';\n}",
                "function consecutivePrimeSum($limit) {\n    $sieve = array_fill(0, $limit, true);\n    $primes = [];\n    for ($i = 2; $i < $limit; $i++) {\n        if ($sieve[$i]) {\n            array_push($primes, $i);\n            for ($j = $i * 2; $j < $limit; $j += $i) {\n                $sieve[$j] = false;\n            }\n        }\n    }\n    $maxLength = 0;\n    $maxPrime = 0;\n    for ($i = 0; $i < count($primes); $i++) {\n        for ($j = $i + $maxLength; $j < count($primes); $j++) {\n            $s = array_sum(array_slice($primes, $i, $j - $i + 1));\n            if ($s >= $limit) {\n                break;\n            }\n            if ($sieve[$s] && $j - $i > $maxLength) {\n                $maxLength = $j - $i;\n                $maxPrime = $s;\n            }\n        }\n    }\n    return $maxPrime;\n}"
            ],
            "ruby": [
                "def multiples_of_3_and_5(n)\n    result = 0\n    (0...n).each do |i|\n        if i % 3 == 0 or i % 5 == 0\n            result += i\n        end\n    end\n    result\nend",
                "def even_fibonacci_numbers(n)\n    result = 0\n    a = 1\n    b = 2\n    while a < n\n        if a % 2 == 0\n            result += a\n        end\n        tmp = a\n        a = b\n        b = tmp + b\n    end\n    result\nend",
                "def largest_prime_factor(n)\n    result = n\n    i = 2\n    while i * i <= result\n        if result % i\n            i += 1\n        else\n            result //= i\n        end\n    end\n    result\nend",
                "def is_palindrome(s)\n    for i in 0...(s.length / 2)\n        if s[i]!= s[s.length - i - 1]\n            return false\n        end\n    end\n    return true\nend\n\ndef largest_palindrome_product(n)\n    result = 0\n    (100...1000).each do |i|\n        (i...1000).each do |j|\n            prod = i * j\n            if is_palindrome(prod.to_s) && prod > result && prod < n\n                result = prod\n            end\n        end\n    end\n    result\nend",
                "def smallest_multiple(n)\n    result = 1\n    (1...n + 1).each do |i|\n        if result % i!= 0\n            (1...n + 1).each do |j|\n                if (result * j) % i == 0\n                    result *= j\n                    break\n                end\n            end\n        end\n    end\n    result\nend",
                "def sum_square_difference(n)\n    sqr_sum = 0\n    num_sum = 0\n    (1...n + 1).each do |i|\n        sqr_sum += i * i\n        num_sum += i\n    end\n    num_sum * num_sum - sqr_sum\nend",
                "def nth_prime(n)\n    primes = [2]\n    i = 3\n    while primes.length < n\n        for p in primes\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n        end\n        i += 2\n    end\n    primes[-1]\nend",
                "def largest_product_in_a_series(s, k)\n    result = 0\n    (0...(s.length - k)).each do |i|\n        product = 1\n        (0...k).each do |j|\n            product *= s[i + j].to_i\n        end\n        result = [result, product].max\n    end\n    result\nend",
                "def special_pythagorean_triplet(n)\n    (1...n).each do |a|\n        (a...n).each do |b|\n            c = n - a - b\n            if a * a + b * b == c * c\n                return a * b * c\n            end\n        end\n    end\n    -1\nend",
                "def summation_of_primes(n)\n    primes = [2]\n    i = 3\n    while i <= n\n        for p in primes\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n        end\n        i += 2\n    end\n    result = 0\n    primes.each do |prime|\n        result += prime\n    end\n    result\nend",
                "def largest_product_in_a_grid(grid)\n    result = 0\n    (0...grid.length - 3).each do |i|\n        (0...grid[i].length - 3).each do |j|\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            (0...4).each do |k|\n                p1 *= grid[i + k][j]\n            end\n            (0...4).each do |k|\n                p2 *= grid[i][j + k]\n            end\n            (0...4).each do |k|\n                p3 *= grid[i + k][j + k]\n            end\n            (0...4).each do |k|\n                p4 *= grid[i + k][j + 3 - k]\n            end\n            result = [result, p1, p2, p3, p4].max\n        end\n    end\n    result\nend",
                "def highly_divisible_triangular_number(n)\n    for i in (1..100000000)\n        result = i * (i + 1) / 2\n        count = 0\n        (1..Math.sqrt(result).to_i).each do |j|\n            if result % j == 0\n                count += 2\n            end\n            if j * j == result\n                count -= 1\n            end\n        end\n        if count > n\n            return result\n        end\n    end\n    -1\nend",
                "def large_sum(numbers)\n    digits = [0] * 60\n    (0...50).each do |i|\n        tmp = 0\n        numbers.each do |num|\n            tmp += num[49 - i].to_i\n        end\n        (i...60).each do |j|\n            digits[j] += tmp % 10\n            if digits[j] >= 10\n                digits[j + 1] += digits[j] // 10\n                digits[j] %= 10\n            end\n            tmp //= 10\n            break if tmp == 0\n        end\n    end\n    result = ''\n    (59...0).step(-1) do |i|\n        if digits[i]!= 0\n            (i...i - 10).step(-1) do |j|\n                result += digits[j].to_s\n            end\n            return result\n        end\n    end\nend",
                "def longest_collatz_sequence(n)\n    longest = 0\n    result = 0\n    (1...n).each do |i|\n        chain = 1\n        num = i\n        while num!= 1\n            if num % 2 == 0\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end\n            chain += 1\n        end\n        if chain > longest\n            longest = chain\n            result = i\n        end\n    end\n    result\nend",
                "def lattice_paths(m, n)\n    grid = Array.new(m + 1) { Array.new(n + 1, 0) }\n    (0...m).each do |i|\n        grid[i][0] = 1\n    end\n    (0...n).each do |j|\n        grid[0][j] = 1\n    end\n    (1...m).each do |i|\n        (1...n).each do |j|\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        end\n    end\n    grid[m][n]\nend",
                "def power_digit_sum(n)\n    digits = [2]\n    (1...n).each do |_|\n        carry = 0\n        digits.each_with_index do |digit, j|\n            temp = digit * 2 + carry\n            digits[j] = temp % 10\n            carry = temp // 10\n        end\n        if carry > 0\n            digits.push(carry)\n        end\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def number_to_words(n)\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000\n        \"one thousand\"\n    elsif n >= 100\n        if n % 100 == 0\n            ones[n // 100] + \" hundred\"\n        else\n            ones[n // 100] + \" hundred and \" + number_to_words(n % 100)\n        end\n    elsif n >= 20\n        suf = \"\"\n        if n % 10!= 0\n            suf = \" \" + ones[n % 10]\n        end\n        tens[n // 10] + suf\n    elsif n >= 10\n        teens[n - 10]\n    else\n        ones[n]\n    end\nend",
                "def maximum_path_sum_i(triangle)\n    curr = triangle[-1].dup\n    (triangle.length - 2).downto(0) do |i|\n        next = triangle[i].dup\n        (next.length).times do |j|\n            next[j] += [curr[j], curr[j + 1]].max\n        end\n        curr = next\n    end\n    curr[0]\nend",
                "def counting_sundays(y1, y2)\n    day = 0\n    count = 0\n    (1900...y2 + 1).each do |year|\n        (1...13).each do |month|\n            if year >= y1 and day % 7 == 6\n                count += 1\n            end\n            if month in [4, 6, 9, 11]\n                day += 30\n            elsif month == 2\n                if year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n                    day += 29\n                else\n                    day += 28\n                end\n            else\n                day += 31\n            end\n        end\n    end\n    count\nend",
                "def factorial_digit_sum(n)\n    digits = [1]\n    (1...n+1).each do |i|\n        carry = 0\n        digits.each_with_index do |digit, j|\n            digits[j] = digit * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        end\n        while carry > 0\n            digits.push(carry % 10)\n            carry /= 10\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
                "def d(n)\n    result = 1\n    (2...Math.sqrt(n).ceil).each do |i|\n        if n % i == 0\n            result += i\n            if i!= n / i\n                result += n / i\n            end\n        end\n    end\n    result\nend\n\ndef amicable_numbers(n)\n    result = 0\n    (2...n).each do |a|\n        b = d(a)\n        if a!= b && a == d(b)\n            result += a\n        end\n    end\n    result\nend",
                "def names_scores(names, queries)\n    s_names = names.sort\n    result = 0\n    s_names.each_with_index do |name, i|\n        x = 0\n        name.each_char do |c|\n            x += c.ord - 64\n        end\n        if name in queries\n            result += x * (i + 1)\n        end\n    end\n    result\nend",
                "def is_abundant(n)\n    if n < 12\n        return false\n    end\n    sum_divisors = 1\n    (2...Math.sqrt(n).ceil).each do |i|\n        if n % i == 0\n            sum_divisors += i\n            if i!= n / i\n                sum_divisors += n / i\n        end\n    end\n    sum_divisors > n\nend\n\ndef non_abundant_sums(n)\n    abundants = []\n    (12...n).each do |i|\n        if is_abundant(i)\n            abundants.push(i)\n        end\n    end\n    abundant_sums = Set.new\n    abundants.each do |i|\n        abundants.each do |j|\n            abundant_sums.add(i + j)\n        end\n    end\n    result = 0\n    (0...n).each do |i|\n        if!abundant_sums.include?(i)\n            result += i\n        end\n    end\n    result\nend",
                "def lexicographic_permutations(n)\n    result = ''\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    (10...1).each do |i|\n        fact = 1\n        (1...i).each do |j|\n            fact *= j\n        end\n        idx = x / fact\n        result += digits[idx].to_s\n        digits.delete_at(idx)\n        x -= idx * fact\n    end\n    result\nend",
                "def n_digit_fibonacci_number(n)\n    a = [1]\n    b = [1]\n    i = 2\n    while b.length < n\n        carry = 0\n        c = b.dup\n        b.each_with_index do |b_j, j|\n            if j < a.length\n                b[j] = a[j] + b_j + carry\n            else\n                b[j] = b_j + carry\n            end\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        end\n        if carry > 0\n            b.push(carry)\n        end\n        a = c\n        i = i + 1\n    end\n    i\nend",
                "def reciprocal_cycles(n)\n    result = 0\n    max_length = 0\n    (1...n).each do |i|\n        remainders = []\n        remainder = 1\n        while remainder!= 0 &&!remainders.include?(remainder)\n            remainders.push(remainder)\n            remainder = (remainder * 10) % i\n        length = 0\n        if remainder!= 0\n            length = remainders.length - remainders.index(remainder)\n        end\n        if length > max_length\n            max_length = length\n            result = i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3...(Math.sqrt(n).to_i + 1)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef quadratic_primes(n)\n    max_primes = 0\n    result = 0\n    (-n + 1...n).step(2) do |a|\n        (-n + 1...n).step(2) do |b|\n            x = 0\n            while true\n                if x * x + a * x + b < 2\n                    break\n                end\n                if not is_prime(x * x + a * x + b)\n                    break\n                end\n                x += 1\n            end\n            if x > max_primes\n                max_primes = x\n                result = a * b\n            end\n        end\n    end\n    result\nend",
                "def number_spiral_diagonals(n)\n    result = 1\n    (3...n + 1).step(2) do |i|\n        result += 4 * i * i - 6 * i + 6\n    end\n    result\nend",
                "def distinct_powers(n)\n    result = 0\n    xs = Set.new\n    (2...n + 1).each do |i|\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        primes.each_with_index do |prime, j|\n            while num % prime == 0\n                num //= prime\n                powers[j] += 1\n        end\n        if num!= 1\n            result += n - 1\n            next\n        end\n        (2...n + 1).each do |j|\n            pstr = \"#{powers[0] * j}-#{powers[1] * j}-#{powers[2] * j}-#{powers[3] * j}\"\n            xs.add(pstr)\n        end\n    end\n    result += xs.length\n    result\nend",
                "def digit_nth_powers(n)\n    result = 0\n    (2..(4 * 10 ** n)).each do |i|\n        digits_sum = 0\n        str(i).each_char do |digit|\n            digits_sum += digit.to_i ** n\n        end\n        if i == digits_sum\n            result += i\n        end\n    end\n    result\nend",
                "def coin_sums(n)\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    coins.each do |coin|\n        (coin...n + 1).each do |i|\n            ways[i] += ways[i - coin]\n        end\n    end\n    ways[n]\nend",
                "def pandigital_products(n)\n    products = Set.new\n    s = (1..n).to_a.join\n    (1..99).each do |a|\n        (1..9999).each do |b|\n            c = a * b\n            chars = [a, b, c].map(&:to_s).sort\n            if chars.join == s\n                products.add(c)\n            end\n        end\n    end\n    result = 0\n    products.each do |product|\n        result += product\n    end\n    result\nend",
                "def digit_canceling_fractions(m)\n    numer = 1\n    denom = 1\n    (10...m).each do |d|\n        (10...d).each do |n|\n            n0, n1 = n % 10, n / 10\n            d0, d1 = d % 10, d / 10\n            if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0)\n                numer *= n\n                denom *= d\n            end\n        end\n    end\n    a, b = numer, denom\n    while b\n        a, b = b, a % b\n    end\n    denom / a\nend",
                "def digit_factorials(n)\n    result = 0\n    (3...n).each do |i|\n        fact_sum = 0\n        str(i).each_char do |digit|\n            fact = 1\n            (1...digit.to_i).each do |j|\n                fact *= j\n            end\n            fact_sum += fact\n        end\n        if i == fact_sum\n            result += i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3...Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef circular_primes(n)\n    count = 0\n    (2...n).each do |i|\n        if is_prime(i)\n            rotations = Set.new\n            (0...(str(i).length)).each do |j|\n                rotations.add(str(i)[j..-1] + str(i)[0...j])\n            end\n            flag = true\n            rotations.each do |x|\n                if not is_prime(x.to_i)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                count += 1\n            end\n        end\n    end\n    count\nend",
                "def is_palindrome(s)\n    for i in (0...s.length / 2)\n        if s[i]!= s[-(i + 1)]\n            return false\n        end\n    end\n    return true\nend\n\ndef double_base_palindromes(n)\n    result = 0\n    (1...n).each do |i|\n        str_i = i.to_s\n        bin_i = (i.to_s(2)).sub(/^0b/, '')\n        if is_palindrome(str_i) and is_palindrome(bin_i)\n            result += i\n        end\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3...Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef truncatable_primes(n)\n    result = 0\n    (10...n).each do |i|\n        if is_prime(i)\n            si = i.to_s\n            flag = true\n            (1...si.length).each do |j|\n                p1 = si[j..-1].to_i\n                p2 = si[0...j].to_i\n                if not is_prime(p1) or not is_prime(p2)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                result += i\n            end\n        end\n    end\n    result\nend",
                "def pandigital_multiples(n)\n    result = -1\n    (2...n + 1).each do |i|\n        cprod = ''\n        (1...10).each do |j|\n            cprod += i * j.to_s\n            if cprod.length == 9\n                if cprod.chars.sort.join == '123456789'\n                    result = [result, cprod.to_i].max\n                    break\n                end\n            elsif cprod.length > 9\n                break\n            end\n        end\n    end\n    result\nend",
                "def integer_right_triangles(n)\n    max_sol = 0\n    result = 0\n    (3...n + 1).each do |p|\n        sol = 0\n        (1...p // 2).each do |a|\n            (a...p // 2).each do |b|\n                c = p - a - b\n                if a * a + b * b == c * c\n                    sol += 1\n                end\n            end\n        end\n        if sol > max_sol\n            max_sol = sol\n            result = p\n        end\n    end\n    result\nend",
                "def champernowne_constant(b)\n    s = ''\n    (1...b**6).each do |i|\n        s += i.to_s\n    end\n    result = 1\n    (0...7).each do |i|\n        result *= s[b**i - 1].to_i\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3...Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef pandigital_prime(n)\n    (n-1).downto(1) do |i|\n        if is_prime(i)\n            si = i.to_s\n            length = si.length\n            flag = true\n            (1...length).each do |j|\n                if j.to_s not in si\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                return i\n        end\n    end\n    return -1\nend",
                "def coded_triangle_numbers(words)\n    result = 0\n    words.each do |word|\n        value = 0\n        word.each_char do |c|\n            value += c.ord - 64\n        end\n        n = Math.sqrt(value * 2).to_i\n        if n * (n + 1) == value * 2\n            result += 1\n        end\n    end\n    result\nend",
                "def gen_permutations(s)\n    if s.length <= 1\n        return s\n    result = []\n    s[1..-1].gen_permutations.each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0:1] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef sub_string_divisibility(n)\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = ''.join(str(i) for i in (0...n + 1))\n    gen_permutations(s).each do |i|\n        flag = true\n        (1...n - 1).each do |j|\n            if i[j..j + 2].to_i % primes[j - 1]!= 0\n                flag = false\n                break\n            end\n        end\n        if flag\n            result += i.to_i\n        end\n    end\n    result\nend",
                "def pentagon_numbers(n)\n    pentagon = Set.new\n    (1...n).each do |i|\n        pentagon.add(i * (3 * i - 1) // 2)\n    end\n    result = -1\n    pentagon.each do |j|\n        pentagon.each do |k|\n            if pentagon.include?(j + k) && pentagon.include?(k - j)\n                if result == -1 || k - j < result\n                    result = k - j\n                end\n            end\n        end\n    end\n    result\nend",
                "def triangular_pentagonal_and_hexagonal(n)\n    ps = Set.new\n    i = 1\n    c = 0.5 * i * (3 * i - 1)\n    while c < n\n        i += 1\n        ps.add(c)\n        c = 0.5 * i * (3 * i - 1)\n    end\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n\n        i += 1\n        if c in ps\n            result = c\n        end\n        c = i * (2 * i - 1)\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3...(Math.sqrt(n).to_i + 1)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef goldbachs_other_conjecture(n)\n    result = -1\n    (9999...n).step(-2) do |i|\n        upper = (Math.sqrt(i / 2.0).to_i)\n        flag = false\n        (0...(upper + 1)).each do |j|\n            if is_prime(i - 2 * j * j)\n                flag = true\n                break\n            end\n        end\n        if not flag\n            result = i\n        end\n    end\n    result\nend",
                "def prime_factors(n)\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num\n        if num % i\n            i += 1\n        else\n            num //= i\n            factors.push(i)\n        end\n    end\n    if num > 1\n        factors.push(num)\n    end\n    factors.length\nend\n\ndef distinct_primes_factors(n)\n    (n...1000000).each do |i|\n        if prime_factors(i) == 4 and prime_factors(i + 1) == 4 and prime_factors(i + 2) == 4 and prime_factors(i + 3) == 4\n            return i\n        end\n    end\n    -1\nend",
                "def self_powers(n)\n    digits = [0] * 10\n    (1..n).each do |i|\n        temp_digits = [0] * 10\n        temp_digits[0] = 1\n        (0...i).each do |j|\n            carry = 0\n            (0...10).each do |k|\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] / 10\n                temp_digits[k] %= 10\n        end\n        (0...10).each do |j|\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10\n                digits[j] -= 10\n                if j < 9\n                    digits[j + 1] += 1\n        end\n    end\n    result = \"\"\n    (9...0).each do |i|\n        result += digits[i].to_s\n    end\n    result\nend",
                "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3...(Math.sqrt(n).to_i + 1)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    return true\nend\n\ndef gen_permutations(s)\n    if s.length <= 1\n        return s\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0:1] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef prime_permutations(n)\n    (n...999).step(-1) do |i|\n        if is_prime(i)\n            permutations = gen_permutations(i.to_s)\n            candidates = Set.new\n            permutations.each do |j|\n                candidate = j.to_i\n                if candidate > i && is_prime(candidate)\n                    candidates.add(candidate)\n                end\n            end\n            candidates.each do |m|\n                if m + (m - i) in candidates\n                    return i.to_s + m.to_s + (m + (m - i)).to_s\n                end\n            end\n        end\n    end\n    ''\nend",
                "def consecutive_prime_sum(limit)\n    sieve = Array.new(limit, true)\n    primes = []\n    (2...limit).each do |i|\n        if sieve[i]\n            primes.push(i)\n            (i * 2...limit).step(i) do |j|\n                sieve[j] = false\n            end\n        end\n    end\n    max_length = 0\n    max_prime = 0\n    primes.each_with_index do |p, i|\n        (i + max_length...primes.length).each do |j|\n            s = primes[i...j].reduce(:+)\n            if s >= limit\n                break\n            end\n            if sieve[s] && j - i > max_length\n                max_length = j - i\n                max_prime = s\n            end\n        end\n    end\n    max_prime\nend"
            ],
            "rust": [
                "fn multiples_of_3_and_5(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..n {\n        if i % 3 == 0 || i % 5 == 0 {\n            result += i;\n        }\n    }\n    result\n}",
                "fn even_fibonacci_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut a = 1;\n    let mut b = 2;\n    while a < n {\n        if a % 2 == 0 {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    result\n}",
                "fn largest_prime_factor(n: i32) -> i32 {\n    let mut result = n;\n    let mut i = 2;\n    while i * i <= result {\n        if result % i == 0 {\n            result /= i;\n        } else {\n            i += 1;\n        }\n    }\n    result\n}",
                "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s.chars().nth(i).unwrap()!= s.chars().nth(s.len() - i - 1).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n\nfn largest_palindrome_product(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 100..1000 {\n        for j in i..1000 {\n            let prod = i * j;\n            if is_palindrome(&prod.to_string()) && prod > result && prod < n {\n                result = prod;\n            }\n        }\n    }\n    result\n}",
                "fn smallest_multiple(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 1..=n {\n        if result % i!= 0 {\n            for j in 1..=n {\n                if (result * j) % i == 0 {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn sum_square_difference(n: i32) -> i32 {\n    let mut sqr_sum = 0;\n    let mut num_sum = 0;\n    for i in 1..=n {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    num_sum * num_sum - sqr_sum\n}",
                "fn nth_prime(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while primes.len() < n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    primes[primes.len() - 1]\n}",
                "fn largest_product_in_a_series(s: &String, k: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..s.len() - k as usize {\n        let mut product = 1;\n        for j in 0..k as usize {\n            product *= s[i + j].parse::<i32>().unwrap();\n        }\n        result = std::cmp::max(result, product);\n    }\n    result\n}",
                "fn special_pythagorean_triplet(n: i32) -> i32 {\n    for a in 1..n {\n        for b in a..n {\n            let c = n - a - b;\n            if a * a + b * b == c * c {\n                return a * b * c;\n            }\n        }\n    }\n    -1\n}",
                "fn summation_of_primes(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while i <= n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let mut result = 0;\n    for prime in &primes {\n        result += prime;\n    }\n    result\n}",
                "fn largest_product_in_a_grid(grid: &Vec<Vec<i32>>) -> i32 {\n    let mut result = 0;\n    for i in 0..grid.len() - 3 {\n        for j in 0..grid[i].len() - 3 {\n            let mut p1 = 1;\n            let mut p2 = 1;\n            let mut p3 = 1;\n            let mut p4 = 1;\n            for k in 0..4 {\n                p1 *= grid[i + k][j];\n            }\n            for k in 0..4 {\n                p2 *= grid[i][j + k];\n            }\n            for k in 0..4 {\n                p3 *= grid[i + k][j + k];\n            }\n            for k in 0..4 {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max(result, p1, p2, p3, p4);\n        }\n    }\n    result\n}",
                "fn highly_divisible_triangular_number(n: i32) -> i32 {\n    for i in 1..100000000 {\n        let result = i * (i + 1) / 2;\n        let mut count = 0;\n        for j in 1..(result as f64).sqrt() as i32 + 1 {\n            if result % j == 0 {\n                count += 2;\n            }\n            if j * j == result {\n                count -= 1;\n            }\n        }\n        if count > n {\n            return result;\n        }\n    }\n    -1\n}",
                "fn large_sum(numbers: &Vec<String>) -> String {\n    let mut digits = vec![0; 60];\n    for i in 0..50 {\n        let mut tmp = 0;\n        for num in numbers {\n            tmp += num.chars().nth(49 - i).unwrap().to_digit(10).unwrap() as i32;\n        }\n        for j in i..60 {\n            digits[j] += tmp % 10;\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if tmp == 0 {\n                break;\n            }\n        }\n    }\n    let mut result = String::new();\n    for i in (0..59).rev() {\n        if digits[i]!= 0 {\n            for j in i..i - 10 {\n                result.push_str(&digits[j].to_string());\n            }\n            break;\n        }\n    }\n    result\n}",
                "fn longest_collatz_sequence(n: i32) -> i32 {\n    let mut longest = 0;\n    let mut result = 0;\n    for i in 1..n {\n        let mut chain = 1;\n        let mut num = i;\n        while num!= 1 {\n            if num % 2 == 0 {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if chain > longest {\n            longest = chain;\n            result = i;\n        }\n    }\n    result\n}",
                "fn lattice_paths(m: i32, n: i32) -> i32 {\n    let mut grid = vec![vec![0; n as usize + 1]; m as usize + 1];\n    for i in 0..m + 1 {\n        grid[i][0] = 1;\n    }\n    for j in 0..n + 1 {\n        grid[0][j] = 1;\n    }\n    for i in 1..m + 1 {\n        for j in 1..n + 1 {\n            grid[i as usize][j as usize] = grid[(i - 1) as usize][j as usize] + grid[i as usize][(j - 1) as usize];\n        }\n    }\n    grid[m as usize][n as usize]\n}",
                "fn power_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![2];\n    for _ in 1..n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if carry!= 0 {\n            digits.push(carry);\n        }\n    }\n    digits.iter().sum()\n}",
                "fn number_to_words(n: i32) -> String {\n    let ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if n == 1000 {\n        return \"one thousand\".to_string();\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n / 100].to_string() + \" hundred\".to_string();\n        } else {\n            return ones[n / 100].to_string() + \" hundred and \".to_string() + number_to_words(n % 100);\n        }\n    } else if n >= 20 {\n        let mut suf = \"\".to_string();\n        if n % 10!= 0 {\n            suf = \" \".to_string() + ones[n % 10].to_string();\n        }\n        return tens[n / 10].to_string() + suf;\n    } else if n >= 10 {\n        return teens[n - 10].to_string();\n    } else {\n        return ones[n].to_string();\n    }\n}",
                "fn maximum_path_sum_i(triangle: &Vec<Vec<i32>>) -> i32 {\n    let mut curr = triangle.last().unwrap().clone();\n    for i in (0..triangle.len() - 2).rev() {\n        let mut next = triangle[i].clone();\n        for j in 0..next.len() {\n            next[j] += max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    curr[0]\n}",
                "fn counting_sundays(y1: i32, y2: i32) -> i32 {\n    let mut day = 0;\n    let mut count = 0;\n    for year in 1900..=y2 {\n        for month in 1..=12 {\n            if year >= y1 && day % 7 == 6 {\n                count += 1;\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30;\n            } else if month == 2 {\n                if year % 4 == 0 && (year % 100!= 0 || year % 400 == 0) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    count\n}",
                "fn factorial_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![1];\n    for i in 1..=n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while carry > 0 {\n            digits.push(carry % 10);\n            carry /= 10;\n        }\n    }\n    digits.iter().sum()\n}",
                "fn d(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 2..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            result += i;\n            if i!= n / i {\n                result += n / i;\n            }\n        }\n    }\n    result\n}\n\nfn amicable_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    for a in 2..n {\n        let b = d(a);\n        if a!= b && a == d(b) {\n            result += a;\n        }\n    }\n    result\n}",
                "fn names_scores(names: &Vec<String>, queries: &Vec<String>) -> i32 {\n    let mut s_names = names.clone();\n    s_names.sort();\n    let mut result = 0;\n    for (i, name) in s_names.iter().enumerate() {\n        let mut x = 0;\n        for c in name.chars() {\n            x += c as i32 - 64;\n        }\n        if queries.contains(name) {\n            result += x * (i + 1)\n        }\n    }\n    result\n}",
                "fn is_abundant(n: i32) -> bool {\n    if n < 12 {\n        return false;\n    }\n    let mut sum_divisors = 1;\n    for i in 2..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            sum_divisors += i;\n            if i!= n / i {\n                sum_divisors += n / i;\n            }\n        }\n    }\n    sum_divisors > n\n}\n\nfn non_abundant_sums(n: i32) -> i32 {\n    let mut abundants = Vec::new();\n    for i in 12..n {\n        if is_abundant(i) {\n            abundants.push(i);\n        }\n    }\n    let mut abundant_sums = HashSet::new();\n    for i in abundants {\n        for j in abundants {\n            abundant_sums.insert(i + j);\n        }\n    }\n    let mut result = 0;\n    for i in 0..n {\n        if!abundant_sums.contains(&i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn lexicographic_permutations(n: i32) -> String {\n    let mut result = String::new();\n    let mut digits = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut x = n - 1;\n    for i in 10..1 {\n        let fact = 1;\n        for j in 1..i {\n            fact *= j;\n        }\n        let idx = x / fact;\n        result.push_str(&digits[idx].to_string());\n        digits.remove(idx);\n        x -= idx * fact;\n    }\n    result\n}",
                "fn n_digit_fibonacci_number(n: i32) -> i32 {\n    let mut a = vec![1];\n    let mut b = vec![1];\n    let mut i = 2;\n    while b.len() < n {\n        let mut carry = 0;\n        let mut c = b.clone();\n        for j in 0..b.len() {\n            if j < a.len() {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if carry > 0 {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    i\n}",
                "fn reciprocal_cycles(n: i32) -> i32 {\n    let mut result = 0;\n    let mut max_length = 0;\n    for i in 1..n {\n        let mut remainders = Vec::new();\n        let mut remainder = 1;\n        while remainder!= 0 &&!remainders.contains(&remainder) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = if remainder!= 0 {\n            remainders.len() - remainders.iter().position(|&r| r == remainder).unwrap()\n        } else {\n            0\n        };\n        if length > max_length {\n            max_length = length;\n            result = i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn quadratic_primes(n: i32) -> i32 {\n    let mut max_primes = 0;\n    let mut result = 0;\n    for a in -n + 1..n + 1 {\n        for b in -n + 1..n + 1 {\n            let mut x = 0;\n            while x * x + a * x + b < 2 {\n                x += 1;\n            }\n            if x > max_primes {\n                max_primes = x;\n                result = a * b;\n            }\n        }\n    }\n    result\n}",
                "fn number_spiral_diagonals(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 3..n + 1 {\n        if i % 2 == 1 {\n            result += 4 * i * i - 6 * i + 6;\n        }\n    }\n    result\n}",
                "fn distinct_powers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut xs = HashSet::new();\n    for i in 2..=n {\n        let mut primes = vec![2, 3, 5, 7];\n        let mut powers = vec![0, 0, 0, 0];\n        let mut num = i;\n        for j in 0..primes.len() {\n            while num % primes[j] == 0 {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if num!= 1 {\n            result += n - 1;\n            continue;\n        }\n        for j in 2..=n {\n            let pstr = format!(\"{}-{}-{}-{}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.len() as i32;\n    result\n}",
                "fn digit_nth_powers(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 2..4 * 10_i32.pow(n) {\n        let mut digits_sum = 0;\n        for digit in i.to_string().chars() {\n            digits_sum += digit.to_digit(10).unwrap() as i32.pow(n);\n        }\n        if i == digits_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn coin_sums(n: i32) -> i32 {\n    let coins = vec![1, 2, 5, 10, 20, 50, 100, 200];\n    let mut ways = vec![0; n as usize + 1];\n    ways[0] = 1;\n    for coin in coins {\n        for i in coin..=n {\n            ways[i as usize] += ways[(i - coin) as usize];\n        }\n    }\n    ways[n as usize]\n}",
                "fn pandigital_products(n: i32) -> i32 {\n    let mut products = HashSet::new();\n    let s = (1..=n).map(|i| i.to_string()).collect::<String>();\n    for a in 1..100 {\n        for b in 1..10000 {\n            let c = a * b;\n            let chars = vec![a.to_string(), b.to_string(), c.to_string()];\n            chars.sort();\n            if chars.iter().collect::<String>() == s {\n                products.insert(c);\n            }\n        }\n    }\n    products.iter().sum()\n}",
                "fn digit_canceling_fractions(m: i32) -> i32 {\n    let mut numer = 1;\n    let mut denom = 1;\n    for d in 10..m {\n        for n in 10..d {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let mut a = numer;\n    let mut b = denom;\n    while b!= 0 {\n        a %= b;\n        std::mem::swap(&mut a, &mut b);\n    }\n    denom / a\n}",
                "fn digit_factorials(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 3..n {\n        let mut fact_sum = 0;\n        for digit in i.to_string().chars() {\n            let mut fact = 1;\n            for j in 1..digit.to_string().parse::<i32>().unwrap() + 1 {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if i == fact_sum {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn circular_primes(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 2..n {\n        if is_prime(i) {\n            let mut rotations = HashSet::new();\n            for j in 0..(i as f64).log10() as usize {\n                rotations.insert(i.to_string()[j..].to_string() + &i.to_string()[..j]);\n            }\n            let mut flag = true;\n            for x in rotations {\n                if!is_prime(x.parse::<i32>().unwrap()) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
                "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s.chars().nth(i).unwrap()!= s.chars().rev().nth(i).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n\nfn double_base_palindromes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 1..n {\n        let str_i = i.to_string();\n        let bin_i = format!(\"{:b}\", i);\n        if is_palindrome(&str_i) && is_palindrome(&bin_i) {\n            result += i;\n        }\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn truncatable_primes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 10..n {\n        if is_prime(i) {\n            let si = i.to_string();\n            let mut flag = true;\n            for j in 1..si.len() {\n                let p1 = si[j..].parse::<i32>().unwrap();\n                let p2 = si[..si.len() - j].parse::<i32>().unwrap();\n                if!is_prime(p1) ||!is_prime(p2) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                result += i;\n            }\n        }\n    }\n    result\n}",
                "fn pandigital_multiples(n: i32) -> i32 {\n    let mut result = -1;\n    for i in 2..=n {\n        let mut cprod = String::new();\n        for j in 1..=9 {\n            cprod.push_str(&i.to_string() * &j.to_string());\n            if cprod.len() == 9 {\n                if cprod.chars().sorted().collect::<String>() == \"123456789\" {\n                    result = result.max(cprod.parse::<i32>().unwrap());\n                }\n                break;\n            } else if cprod.len() > 9 {\n                break;\n            }\n        }\n    }\n    result\n}",
                "fn integer_right_triangles(n: i32) -> i32 {\n    let mut max_sol = 0;\n    let mut result = 0;\n    for p in 3..=n {\n        let mut sol = 0;\n        for a in 1..(p / 2) + 1 {\n            for b in a..(p / 2) + 1 {\n                let c = p - a - b;\n                if a * a + b * b == c * c {\n                    sol += 1;\n                }\n            }\n        }\n        if sol > max_sol {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    result\n}",
                "fn champernowne_constant(b: i32) -> i32 {\n    let mut s = String::new();\n    for i in 1..b.pow(6) {\n        s.push_str(&i.to_string());\n    }\n    let mut result = 1;\n    for i in 0..7 {\n        result *= s[b.pow(i) - 1..].parse::<i32>().unwrap();\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..(n as f64).sqrt() as i32 + 1 {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn pandigital_prime(n: i32) -> i32 {\n    for i in (n-1)..1 {\n        if is_prime(i) {\n            let si = i.to_string();\n            let length = si.len();\n            let mut flag = true;\n            for j in 1..length + 1 {\n                if j.to_string()!= si.chars().nth(j - 1).unwrap().to_string() {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                return i;\n            }\n        }\n    }\n    -1\n}",
                "fn coded_triangle_numbers(words: &Vec<String>) -> i32 {\n    let mut result = 0;\n    for word in words {\n        let mut value = 0;\n        for c in word.chars() {\n            value += c as i32 - 64;\n        }\n        let n = (value as f64).sqrt() as i32;\n        if n * (n + 1) == value * 2 {\n            result += 1;\n        }\n    }\n    result\n}",
                "fn gen_permutations(s: &String) -> Vec<String> {\n    let mut result = Vec::new();\n    if s.len() <= 1 {\n        return vec![s.to_string()];\n    }\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn sub_string_divisibility(n: i32) -> i32 {\n    let mut result = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17];\n    let s = (0..=n).map(|i| i.to_string()).collect::<String>();\n    for i in gen_permutations(&s) {\n        let mut flag = true;\n        for j in 1..(n - 1) {\n            if i[j..j + 3].parse::<i32>().unwrap() % primes[j - 1]!= 0 {\n                flag = false;\n                break;\n            }\n        }\n        if flag {\n            result += i.parse::<i32>().unwrap();\n        }\n    }\n    result\n}",
                "fn pentagon_numbers(n: i32) -> i32 {\n    let mut pentagon = HashSet::new();\n    for i in 1..n {\n        pentagon.insert(i * (3 * i - 1) / 2);\n    }\n    let mut result = -1;\n    for j in pentagon {\n        for k in pentagon.clone() {\n            if j + k == k - j && k - j!= 0 {\n                if result == -1 || k - j < result {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    result\n}",
                "fn triangular_pentagonal_and_hexagonal(n: i32) -> i32 {\n    let mut ps = HashSet::new();\n    let mut i = 1;\n    let mut c = 0.5 * i * (3 * i - 1);\n    while c < n {\n        i += 1;\n        ps.insert(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let mut result = -1;\n    while c < n {\n        i += 1;\n        if ps.contains(&c) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn goldbachs_other_conjecture(n: i32) -> i32 {\n    let mut result = -1;\n    for i in (9999..n).rev().step_by(2) {\n        let upper = ((i as f64).sqrt() as i32);\n        let mut flag = false;\n        for j in 0..=upper {\n            if is_prime(i - 2 * j * j) {\n                flag = true;\n                break;\n            }\n        }\n        if!flag {\n            result = i;\n            break;\n        }\n    }\n    result\n}",
                "fn prime_factors(n: i32) -> i32 {\n    let mut num = n;\n    let mut factors = Vec::new();\n    let mut i = 2;\n    while i * i <= num {\n        if num % i == 0 {\n            num /= i;\n            factors.push(i);\n        } else {\n            i += 1;\n        }\n    }\n    if num > 1 {\n        factors.push(num);\n    }\n    factors.len() as i32\n}\n\nfn distinct_primes_factors(n: i32) -> i32 {\n    for i in n..1000000 {\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4 {\n            return i;\n        }\n    }\n    -1\n}",
                "fn self_powers(n: i32) -> String {\n    let mut digits = vec![0; 10];\n    for i in 1..=n {\n        let mut temp_digits = vec![0; 10];\n        temp_digits[0] = 1;\n        for j in 0..i {\n            let mut carry = 0;\n            for k in 0..10 {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for j in 0..10 {\n            digits[j] += temp_digits[j];\n            if digits[j] >= 10 {\n                digits[j] -= 10;\n                if j < 9 {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let mut result = String::new();\n    for i in 9..0 {\n        result.push_str(&digits[i].to_string());\n    }\n    result\n}",
                "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in 3..=((n as f64).sqrt() as i32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.clone()];\n    }\n    let mut result = Vec::new();\n    for perm in gen_permutations(&s[1..]) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn prime_permutations(n: i32) -> String {\n    for i in (n..=999).rev() {\n        if is_prime(i) {\n            let permutations = gen_permutations(&i.to_string());\n            let mut candidates = HashSet::new();\n            for j in permutations {\n                let candidate = j.parse::<i32>().unwrap();\n                if candidate > i && is_prime(candidate) {\n                    candidates.insert(candidate);\n                }\n            }\n            for m in candidates {\n                if m + (m - i) in candidates {\n                    return i.to_string() + &m.to_string() + &(m + (m - i)).to_string();\n                }\n            }\n        }\n    }\n    \"\".to_string()\n}",
                "fn consecutive_prime_sum(limit: i32) -> i32 {\n    let mut sieve = vec![true; limit as usize];\n    let mut primes = Vec::new();\n    for i in 2..limit {\n        if sieve[i as usize] {\n            primes.push(i);\n            for j in (i * 2)..limit {\n                if j % i == 0 {\n                    sieve[j as usize] = false;\n                }\n            }\n        }\n    }\n    let mut max_length = 0;\n    let mut max_prime = 0;\n    for i in 0..primes.len() {\n        for j in (i + max_length)..primes.len() {\n            let s = primes[i..j].iter().sum();\n            if s >= limit {\n                break;\n            }\n            if sieve[s as usize] && j - i > max_length {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    max_prime\n}"
            ],
            "scala": [
                "def multiplesOf3And5(n: Int): Int = {\n  var result = 0\n  for (i <- 0 until n) {\n    if (i % 3 == 0 || i % 5 == 0) {\n      result += i\n    }\n  }\n  result\n}",
                "def evenFibonacciNumbers(n: Int): Int = {\n  var result = 0\n  var a = 1\n  var b = 2\n  while (a < n) {\n    if (a % 2 == 0) {\n      result += a\n    }\n    val tmp = a\n    a = b\n    b = tmp + b\n  }\n  result\n}",
                "def largestPrimeFactor(n: Int): Int = {\n  var result = n\n  var i = 2\n  while (i * i <= result) {\n    if (result % i == 0) {\n      result /= i\n    } else {\n      i += 1\n    }\n  }\n  result\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i)!= s(s.length - i - 1)) {\n      return false\n    }\n  }\n  true\n}\n\ndef largestPalindromeProduct(n: Int): Int = {\n  var result = 0\n  for (i <- 100 to 999) {\n    for (j <- i to 999) {\n      val prod = i * j\n      if (isPalindrome(prod.toString) && prod > result && prod < n) {\n        result = prod\n      }\n    }\n  }\n  result\n}",
                "def smallestMultiple(n: Int): Int = {\n  var result = 1\n  for (i <- 1 to n) {\n    if (result % i!= 0) {\n      for (j <- 1 to n) {\n        if ((result * j) % i == 0) {\n          result *= j\n          break\n        }\n      }\n    }\n  }\n  result\n}",
                "def sumSquareDifference(n: Int): Int = {\n  var sqrSum = 0\n  var numSum = 0\n  for (i <- 1 to n) {\n    sqrSum += i * i\n    numSum += i\n  }\n  numSum * numSum - sqrSum\n}",
                "def nthPrime(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (primes.length < n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  primes.last\n}",
                "def largestProductInASeries(s: String, k: Int): Int = {\n  var result = 0\n  for (i <- 0 until s.length - k) {\n    var product = 1\n    for (j <- 0 until k) {\n      product *= s(i + j).asDigit\n    }\n    result = math.max(result, product)\n  }\n  result\n}",
                "def specialPythagoreanTriplet(n: Int): Int = {\n  for (a <- 1 to n) {\n    for (b <- a to n) {\n      val c = n - a - b\n      if (a * a + b * b == c * c) {\n        return a * b * c\n      }\n    }\n  }\n  -1\n}",
                "def summationOfPrimes(n: Int): Int = {\n  val primes = collection.mutable.ArrayBuffer[Int](2)\n  var i = 3\n  while (i <= n) {\n    for (p <- primes) {\n      if (i % p == 0) {\n        break\n      }\n      if (p * p > i) {\n        primes += i\n        break\n      }\n    }\n    i += 2\n  }\n  var result = 0\n  for (prime <- primes) {\n    result += prime\n  }\n  result\n}",
                "def largestProductInAGrid(grid: collection.Seq[collection.Seq[Int]]): Int = {\n  var result = 0\n  for (i <- 0 until grid.length - 3) {\n    for (j <- 0 until grid(i).length - 3) {\n      val p1 = grid(i)(j) * grid(i + 1)(j) * grid(i + 2)(j) * grid(i + 3)(j)\n      val p2 = grid(i)(j) * grid(i)(j + 1) * grid(i)(j + 2) * grid(i)(j + 3)\n      val p3 = grid(i)(j) * grid(i + 1)(j + 1) * grid(i + 2)(j + 2) * grid(i + 3)(j + 3)\n      val p4 = grid(i)(j + 3) * grid(i + 1)(j + 2) * grid(i + 2)(j + 1) * grid(i + 3)(j)\n      result = math.max(result, p1, p2, p3, p4)\n    }\n  }\n  result\n}",
                "def highlyDivisibleTriangularNumber(n: Int): Int = {\n  for (i <- 1 to 100000000) {\n    val result = i * (i + 1) / 2\n    var count = 0\n    for (j <- 1 to math.sqrt(result).toInt) {\n      if (result % j == 0) {\n        count += 2\n      }\n      if (j * j == result) {\n        count -= 1\n      }\n    }\n    if (count > n) {\n      return result\n    }\n  }\n  -1\n}",
                "def largeSum(numbers: collection.Seq[String]): String = {\n  val digits = Array.fill(60)(0)\n  for (i <- 0 until 50) {\n    var tmp = 0\n    for (num <- numbers) {\n      tmp += num(49 - i).toInt\n    }\n    for (j <- i until 60) {\n      digits(j) += tmp % 10\n      if digits(j) >= 10 {\n        digits(j + 1) += digits(j) / 10\n        digits(j) %= 10\n      }\n      tmp /= 10\n      if tmp == 0 {\n        break\n      }\n    }\n  }\n  for (i <- 59 until 0 by -1) {\n    if digits(i)!= 0 {\n      var result = \"\"\n      for (j <- i until i - 10 by -1) {\n        result += digits(j).toString\n      }\n      return result\n    }\n  }\n  \"\"\n}",
                "def longestCollatzSequence(n: Int): Int = {\n  var longest = 0\n  var result = 0\n  for (i <- 1 until n) {\n    var chain = 1\n    var num = i\n    while (num!= 1) {\n      if (num % 2 == 0) {\n        num = num / 2\n      } else {\n        num = 3 * num + 1\n      }\n      chain += 1\n    }\n    if (chain > longest) {\n      longest = chain\n      result = i\n    }\n  }\n  result\n}",
                "def latticePaths(m: Int, n: Int): Int = {\n  val grid = Array.ofDim[Int](m + 1, n + 1)\n  for (i <- 0 until m + 1) {\n    grid(i)(0) = 1\n  }\n  for (j <- 0 until n + 1) {\n    grid(0)(j) = 1\n  }\n  for (i <- 1 until m + 1) {\n    for (j <- 1 until n + 1) {\n      grid(i)(j) = grid(i - 1)(j) + grid(i)(j - 1)\n    }\n  }\n  grid(m)(n)\n}",
                "def powerDigitSum(n: Int): Int = {\n  val digits = collection.mutable.ArrayBuffer[Int](2)\n  for (_ <- 1 until n) {\n    var carry = 0\n    for (j <- digits.indices) {\n      val temp = digits(j) * 2 + carry\n      digits(j) = temp % 10\n      carry = temp / 10\n    }\n    if (carry!= 0) {\n      digits += carry\n    }\n  }\n  digits.sum\n}",
                "def numberToWords(n: Int): String = {\n  val ones = Array(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n  val teens = Array(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n  val tens = Array(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n  if (n == 1000) {\n    \"one thousand\"\n  } else if (n >= 100) {\n    if (n % 100 == 0) {\n      ones(n / 100) + \" hundred\"\n    } else {\n      ones(n / 100) + \" hundred and \" + numberToWords(n % 100)\n    }\n  } else if (n >= 20) {\n    val suf = if (n % 10!= 0) \" \" + ones(n % 10) else \"\"\n    tens(n / 10) + suf\n  } else if (n >= 10) {\n    teens(n - 10)\n  } else {\n    ones(n)\n  }\n}",
                "def maximumPathSumI(triangle: collection.Seq[collection.Seq[Int]]): Int = {\n  val curr = triangle.last.to[collection.mutable.ArrayBuffer]\n  for (i <- triangle.length - 2 to 0 by -1) {\n    val next = triangle(i).to[collection.mutable.ArrayBuffer]\n    for (j <- 0 until next.length) {\n      next(j) += math.max(curr(j), curr(j + 1))\n    }\n    curr.clear()\n    curr ++= next\n  }\n  curr(0)\n}",
                "def countingSundays(y1: Int, y2: Int): Int = {\n  var day = 0\n  var count = 0\n  for (year <- 1900 to y2) {\n    for (month <- 1 to 12) {\n      if (year >= y1 && day % 7 == 6) {\n        count += 1\n      }\n      if (month == 4 || month == 6 || month == 9 || month == 11) {\n        day += 30\n      } else if (month == 2) {\n        if (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {\n          day += 29\n        } else {\n          day += 28\n        }\n      } else {\n        day += 31\n      }\n    }\n  }\n  count\n}",
                "def factorialDigitSum(n: Int): Int = {\n  val digits = collection.mutable.ArrayBuffer[Int](1)\n  for (i <- 1 until n + 1) {\n    var carry = 0\n    for (j <- digits.indices) {\n      digits(j) = digits(j) * i + carry\n      carry = digits(j) / 10\n      digits(j) %= 10\n    }\n    while (carry > 0) {\n      digits += carry % 10\n      carry /= 10\n    }\n  }\n  digits.sum\n}",
                "def d(n: Int): Int = {\n  var result = 1\n  for (i <- 2 to math.sqrt(n).toInt) {\n    if (n % i == 0) {\n      result += i\n      if (i!= n / i) {\n        result += n / i\n      }\n    }\n  }\n  result\n}\n\ndef amicableNumbers(n: Int): Int = {\n  var result = 0\n  for (a <- 2 to n) {\n    val b = d(a)\n    if (a!= b && a == d(b)) {\n      result += a\n    }\n  }\n  result\n}",
                "def namesScores(names: collection.Seq[String], queries: collection.Seq[String]): Int = {\n  val sNames = names.sorted\n  var result = 0\n  for ((name, i) <- sNames.zipWithIndex) {\n    var x = 0\n    for (c <- name) {\n      x += c - 'A' + 1\n    }\n    if (name.exists(queries.contains)) {\n      result += x * (i + 1)\n    }\n  }\n  result\n}",
                "def isAbundant(n: Int): Boolean = {\n  if (n < 12) {\n    false\n  } else {\n    var sumDivisors = 1\n    for (i <- 2 to math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        sumDivisors += i\n        if (i!= n / i) {\n          sumDivisors += n / i\n        }\n      }\n    }\n    sumDivisors > n\n  }\n}\n\ndef nonAbundantSums(n: Int): Int = {\n  val abundants = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 12 until n) {\n    if (isAbundant(i)) {\n      abundants += i\n    }\n  }\n  val abundantSums = collection.mutable.Set[Int]()\n  for (i <- abundants) {\n    for (j <- abundants) {\n      abundantSums += i + j\n    }\n  }\n  var result = 0\n  for (i <- 0 until n) {\n    if (!abundantSums.contains(i)) {\n      result += i\n    }\n  }\n  result\n}",
                "def lexicographicPermutations(n: Int): String = {\n  val result = new StringBuilder()\n  val digits = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n  var x = n - 1\n  for (i <- 10 to 1 by -1) {\n    var fact = 1\n    for (j <- 1 to i - 1) {\n      fact *= j\n    }\n    val idx = x / fact\n    result.append(digits(idx))\n    digits.remove(idx)\n    x -= idx * fact\n  }\n  result.toString\n}",
                "def nDigitFibonacciNumber(n: Int): Int = {\n  val a = collection.mutable.ArrayBuffer[Int](1)\n  val b = collection.mutable.ArrayBuffer[Int](1)\n  var i = 2\n  while (b.length < n) {\n    var carry = 0\n    val c = b.clone()\n    for (j <- 0 until b.length) {\n      if (j < a.length) {\n        b(j) = a(j) + b(j) + carry\n      } else {\n        b(j) = b(j) + carry\n      }\n      carry = b(j) / 10\n      b(j) = b(j) % 10\n    }\n    if (carry > 0) {\n      b += carry\n    }\n    a = c\n    i += 1\n  }\n  i\n}",
                "def reciprocalCycles(n: Int): Int = {\n  var result = 0\n  var maxLength = 0\n  for (i <- 1 until n) {\n    var remainders = collection.mutable.ArrayBuffer[Int]()\n    var remainder = 1\n    while (remainder!= 0 &&!remainders.contains(remainder)) {\n      remainders += remainder\n      remainder = (remainder * 10) % i\n    }\n    var length = 0\n    if (remainder!= 0) {\n      length = remainders.length - remainders.indexOf(remainder)\n    }\n    if (length > maxLength) {\n      maxLength = length\n      result = i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef quadraticPrimes(n: Int): Int = {\n  var maxPrimes = 0\n  var result = 0\n  for (a <- -n + 1 until n by 2) {\n    for (b <- -n + 1 until n by 2) {\n      var x = 0\n      while (true) {\n        if (x * x + a * x + b < 2) {\n          break\n        }\n        if (!isPrime(x * x + a * x + b)) {\n          break\n        }\n        x += 1\n      }\n      if (x > maxPrimes) {\n        maxPrimes = x\n        result = a * b\n      }\n    }\n  }\n  result\n}",
                "def numberSpiralDiagonals(n: Int): Int = {\n  var result = 1\n  for (i <- 3 to n by 2) {\n    result += 4 * i * i - 6 * i + 6\n  }\n  result\n}",
                "def distinctPowers(n: Int): Int = {\n  var result = 0\n  val xs = collection.mutable.Set[String]()\n  for (i <- 2 to n) {\n    val primes = Array(2, 3, 5, 7)\n    val powers = Array(0, 0, 0, 0)\n    var num = i\n    for (j <- 0 until primes.length) {\n      while (num % primes(j) == 0) {\n        num /= primes(j)\n        powers(j) += 1\n      }\n    }\n    if (num!= 1) {\n      result += n - 1\n      continue\n    }\n    for (j <- 2 to n) {\n      val pstr = s\"${powers(0) * j}-${powers(1) * j}-${powers(2) * j}-${powers(3) * j}\"\n      xs += pstr\n    }\n  }\n  result += xs.size\n  result\n}",
                "def digitNthPowers(n: Int): Int = {\n  var result = 0\n  for (i <- 2 to 4 * 10.pow(n).toInt) {\n    var digitsSum = 0\n    for (digit <- i.toString) {\n      digitsSum += digit.toInt.pow(n)\n    }\n    if (i == digitsSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def coinSums(n: Int): Int = {\n  val coins = Array(1, 2, 5, 10, 20, 50, 100, 200)\n  val ways = Array.fill(n + 1)(0)\n  ways(0) = 1\n  for (coin <- coins) {\n    for (i <- coin to n) {\n      ways(i) += ways(i - coin)\n    }\n  }\n  ways(n)\n}",
                "def pandigitalProducts(n: Int): Int = {\n  val products = collection.mutable.Set[Int]()\n  val s = (1 to n).map(_.toString).mkString\n  for (a <- 1 to 99) {\n    for (b <- 1 to 9999) {\n      val c = a * b\n      val chars = List(a.toString, b.toString, c.toString).sorted\n      if (chars.mkString == s) {\n        products += c\n      }\n    }\n  }\n  products.sum\n}",
                "def digitCancelingFractions(m: Int): Int = {\n  var numer = 1\n  var denom = 1\n  for (d <- 10 until m) {\n    for (n <- 10 until d) {\n      val n0 = n % 10\n      val n1 = n / 10\n      val d0 = d % 10\n      val d1 = d / 10\n      if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n        numer *= n\n        denom *= d\n      }\n    }\n  }\n  var a = numer\n  var b = denom\n  while (b!= 0) {\n    val temp = b\n    b = a % b\n    a = temp\n  }\n  denom / a\n}",
                "def digitFactorials(n: Int): Int = {\n  var result = 0\n  for (i <- 3 until n) {\n    var factSum = 0\n    for (digit <- i.toString) {\n      var fact = 1\n      for (j <- 1 to digit.toInt) {\n        fact *= j\n      }\n      factSum += fact\n    }\n    if (i == factSum) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef circularPrimes(n: Int): Int = {\n  var count = 0\n  for (i <- 2 until n) {\n    if (isPrime(i)) {\n      val rotations = collection.mutable.Set[Int]()\n      for (j <- 0 until i.toString.length) {\n        rotations += i.toString.substring(j) + i.toString.substring(0, j).toInt\n      }\n      var flag = true\n      for (x <- rotations) {\n        if (!isPrime(x)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        count += 1\n      }\n    }\n  }\n  count\n}",
                "def isPalindrome(s: String): Boolean = {\n  for (i <- 0 until s.length / 2) {\n    if (s(i)!= s(s.length - 1 - i)) {\n      return false\n    }\n  }\n  true\n}\n\ndef doubleBasePalindromes(n: Int): Int = {\n  var result = 0\n  for (i <- 1 until n) {\n    val strI = i.toString\n    val binI = Integer.toBinaryString(i)\n    if (isPalindrome(strI) && isPalindrome(binI)) {\n      result += i\n    }\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef truncatablePrimes(n: Int): Int = {\n  var result = 0\n  for (i <- 10 until n) {\n    if (isPrime(i)) {\n      val si = i.toString\n      var flag = true\n      for (j <- 1 until si.length) {\n        val p1 = si.substring(j).toInt\n        val p2 = si.substring(0, j).toInt\n        if (!isPrime(p1) ||!isPrime(p2)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        result += i\n      }\n    }\n  }\n  result\n}",
                "def pandigitalMultiples(n: Int): Int = {\n  var result = -1\n  for (i <- 2 to n) {\n    var cprod = \"\"\n    for (j <- 1 to 9) {\n      cprod += i * j\n      if (cprod.length == 9) {\n        if (cprod.sorted == \"123456789\") {\n          result = math.max(result, cprod.toInt)\n          break\n        }\n      } else if (cprod.length > 9) {\n        break\n      }\n    }\n  }\n  result\n}",
                "def integerRightTriangles(n: Int): Int = {\n  var maxSol = 0\n  var result = 0\n  for (p <- 3 to n) {\n    var sol = 0\n    for (a <- 1 to p / 2) {\n      for (b <- a to p / 2) {\n        val c = p - a - b\n        if (a * a + b * b == c * c) {\n          sol += 1\n        }\n      }\n    }\n    if (sol > maxSol) {\n      maxSol = sol\n      result = p\n    }\n  }\n  result\n}",
                "def champernowneConstant(b: Int): Int = {\n  var s = \"\"\n  for (i <- 1 until b.pow(6)) {\n    s += i.toString\n  }\n  var result = 1\n  for (i <- 0 until 7) {\n    result *= s(b.pow(i).toInt - 1).toInt\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var i = 3\n    while (i <= math.sqrt(n).toInt) {\n      if (n % i == 0) {\n        return false\n      }\n      i += 2\n    }\n    true\n  }\n}\n\ndef pandigitalPrime(n: Int): Int = {\n  var i = n - 1\n  while (i >= 1) {\n    if (isPrime(i)) {\n      val si = i.toString\n      val length = si.length\n      var flag = true\n      for (j <- 1 to length) {\n        if (j.toString.toInt.toString.contains(si)) {\n          flag = false\n          break\n        }\n      }\n      if (flag) {\n        return i\n      }\n    }\n    i -= 1\n  }\n  -1\n}",
                "def codedTriangleNumbers(words: collection.Seq[String]): Int = {\n  var result = 0\n  for (word <- words) {\n    var value = 0\n    for (c <- word) {\n      value += c.toInt - 64\n    }\n    val n = math.sqrt(value * 2).toInt\n    if (n * (n + 1) == value * 2) {\n      result += 1\n    }\n  }\n  result\n}",
                "def genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    return Seq(s)\n  }\n  val result = collection.mutable.ArrayBuffer[String]()\n  for (perm <- genPermutations(s.substring(1))) {\n    for (i <- 0 until s.length) {\n      result += perm.substring(0, i) + s.substring(0, 1) + perm.substring(i)\n    }\n  }\n  result\n}\n\ndef subStringDivisibility(n: Int): Int = {\n  var result = 0\n  val primes = Seq(2, 3, 5, 7, 11, 13, 17)\n  val s = (0 until n + 1).map(_.toString).mkString\n  for (i <- genPermutations(s)) {\n    var flag = true\n    for (j <- 1 until n - 1) {\n      if (i.substring(j, j + 3).toInt % primes(j - 1)!= 0) {\n        flag = false\n        break\n      }\n    }\n    if (flag) {\n      result += i.toInt\n    }\n  }\n  result\n}",
                "def pentagonNumbers(n: Int): Int = {\n  val pentagon = collection.mutable.Set[Int]()\n  for (i <- 1 until n) {\n    pentagon += i * (3 * i - 1) / 2\n  }\n  var result = -1\n  for (j <- pentagon) {\n    for (k <- pentagon) {\n      if (j + k).exists(pentagon) && (k - j).exists(pentagon) {\n        if (result == -1 || (k - j) < result) {\n          result = k - j\n        }\n      }\n    }\n  }\n  result\n}",
                "def triangularPentagonalAndHexagonal(n: Int): Int = {\n  val ps = collection.mutable.Set[Int]()\n  var i = 1\n  var c = 0.5 * i * (3 * i - 1)\n  while (c < n) {\n    i += 1\n    ps += c\n    c = 0.5 * i * (3 * i - 1)\n  }\n  i = 1\n  c = i * (2 * i - 1)\n  var result = -1\n  while (c < n) {\n    i += 1\n    if (c in ps) {\n      result = c\n    }\n    c = i * (2 * i - 1)\n  }\n  result\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    var flag = false\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n      if (n % i == 0) {\n        flag = true\n        break\n      }\n    }\n   !flag\n  }\n}\n\ndef goldbachsOtherConjecture(n: Int): Int = {\n  var result = -1\n  for (i <- 9999 to n by -2) {\n    val upper = math.sqrt(i / 2).toInt\n    var flag = false\n    for (j <- 0 to upper) {\n      if (isPrime(i - 2 * j * j)) {\n        flag = true\n        break\n      }\n    }\n    if (!flag) {\n      result = i\n    }\n  }\n  result\n}",
                "def primeFactors(n: Int): Int = {\n  var num = n\n  var factors = collection.mutable.ArrayBuffer[Int]()\n  var i = 2\n  while (i * i <= num) {\n    if (num % i == 0) {\n      num /= i\n      factors += i\n    } else {\n      i += 1\n    }\n  }\n  if (num > 1) {\n    factors += num\n  }\n  factors.size\n}\n\ndef distinctPrimesFactors(n: Int): Int = {\n  for (i <- n until 1000000) {\n    if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n      return i\n    }\n  }\n  -1\n}",
                "def selfPowers(n: Int): String = {\n  val digits = Array.fill(10)(0)\n  for (i <- 1 to n) {\n    val tempDigits = Array.fill(10)(0)\n    tempDigits(0) = 1\n    for (j <- 0 until i) {\n      var carry = 0\n      for (k <- 0 until 10) {\n        tempDigits(k) = tempDigits(k) * i + carry\n        carry = tempDigits(k) / 10\n        tempDigits(k) %= 10\n      }\n    }\n    for (j <- 0 until 10) {\n      digits(j) += tempDigits(j)\n      if (digits(j) >= 10) {\n        digits(j) -= 10\n        if (j < 9) {\n          digits(j + 1) += 1\n        }\n      }\n    }\n  }\n  digits.reverse.mkString\n}",
                "def isPrime(n: Int): Boolean = {\n  if (n < 2) {\n    false\n  } else if (n == 2) {\n    true\n  } else if (n % 2 == 0) {\n    false\n  } else {\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n      if (n % i == 0) {\n        return false\n      }\n    }\n    true\n  }\n}\n\ndef genPermutations(s: String): collection.Seq[String] = {\n  if (s.length <= 1) {\n    s\n  } else {\n    val result = collection.mutable.ArrayBuffer[String]()\n    for (perm <- genPermutations(s.substring(1))) {\n      for (i <- 0 until s.length) {\n        result += perm.substring(0, i) + s.substring(0, 1) + perm.substring(i)\n      }\n    }\n    result\n  }\n}\n\ndef primePermutations(n: Int): String = {\n  for (i <- n to 999 by -1) {\n    if (isPrime(i)) {\n      val permutations = genPermutations(i.toString)\n      val candidates = collection.mutable.Set[Int]()\n      for (j <- permutations) {\n        val candidate = j.toInt\n        if (candidate > i && isPrime(candidate)) {\n          candidates += candidate\n        }\n      }\n      for (m <- candidates) {\n        if (m + (m - i) in candidates) {\n          return i.toString + m.toString + (m + (m - i)).toString\n        }\n      }\n    }\n  }\n  \"\"\n}",
                "def consecutivePrimeSum(limit: Int): Int = {\n  val sieve = Array.fill(limit)(true)\n  val primes = collection.mutable.ArrayBuffer[Int]()\n  for (i <- 2 until limit) {\n    if (sieve(i)) {\n      primes += i\n      for (j <- i * 2 until limit by i) {\n        sieve(j) = false\n      }\n    }\n  }\n  var maxLength = 0\n  var maxPrime = 0\n  for (i <- primes.indices) {\n    for (j <- i + maxLength until primes.length) {\n      val s = primes.slice(i, j).sum\n      if (s >= limit) {\n        break\n      }\n      if (sieve(s) && j - i > maxLength) {\n        maxLength = j - i\n        maxPrime = s\n      }\n    }\n  }\n  maxPrime\n}"
            ]
        }
    }
}