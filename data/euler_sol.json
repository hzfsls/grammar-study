{
    "python": {
        "Euler001": "def multiples_of_3_and_5(n: int) -> int:\n    result = 0\n    for i in range(n):\n        if i % 3 == 0 or i % 5 == 0:\n            result += i\n    return result",
        "Euler002": "def even_fibonacci_numbers(n: int) -> int:\n    result = 0\n    a = 1\n    b = 2\n    while a < n:\n        if a % 2 == 0:\n            result += a\n        tmp = a\n        a = b\n        b = tmp + b\n    return result",
        "Euler003": "def largest_prime_factor(n: int) -> int:\n    result = n\n    i = 2\n    while i * i <= result:\n        if result % i:\n            i += 1\n        else:\n            result //= i\n    return result",
        "Euler004": "def is_palindrome(s: str) -> bool:\n    for i in range(len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True\n\ndef largest_palindrome_product(n: int) -> int:\n    result = 0\n    for i in range(100, 1000):\n        for j in range(i, 1000):\n            prod = i * j\n            if is_palindrome(str(prod)) and prod > result and prod < n:\n                result = prod\n    return result",
        "Euler005": "def smallest_multiple(n: int) -> int:\n    result = 1\n    for i in range(1, n + 1):\n        if result % i != 0:\n            for j in range(1, n + 1):\n                if (result * j) % i == 0:\n                    result *= j\n                    break\n    return result",
        "Euler006": "def sum_square_difference(n: int) -> int:\n    sqr_sum = 0\n    num_sum = 0\n    for i in range(1, n + 1):\n        sqr_sum += i * i\n        num_sum += i\n    return num_sum * num_sum - sqr_sum",
        "Euler007": "def nth_prime(n: int) -> int:\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for p in primes:\n            if i % p == 0:\n                break\n            if p * p > i:\n                primes.append(i)\n                break\n        i += 2\n    return primes[-1]",
        "Euler008": "def largest_product_in_a_series(s: str, k: int) -> int:\n    result = 0\n    for i in range(len(s) - k):\n        product = 1\n        for j in range(k):\n            product *= int(s[i + j])\n        result = max(result, product)\n    return result",
        "Euler009": "def special_pythagorean_triplet(n: int) -> int:\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - a - b\n            if a * a + b * b == c * c:\n                return a * b * c\n    return -1",
        "Euler010": "def summation_of_primes(n: int) -> int:\n    primes = [2]\n    i = 3\n    while i <= n:\n        for p in primes:\n            if i % p == 0:\n                break\n            if p * p > i:\n                primes.append(i)\n                break\n        i += 2\n    result = 0\n    for prime in primes:\n        result += prime\n    return result",
        "Euler011": "def largest_product_in_a_grid(grid: list[list[int]]) -> int:\n    result = 0\n    for i in range(len(grid) - 3):\n        for j in range(len(grid[i]) - 3):\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            for k in range(4):\n                p1 *= grid[i + k][j]\n            for k in range(4):\n                p2 *= grid[i][j + k]\n            for k in range(4):\n                p3 *= grid[i + k][j + k]\n            for k in range(4):\n                p4 *= grid[i + k][j + 3 - k]\n            result = max(result, p1, p2, p3, p4)\n    return result",
        "Euler012": "def highly_divisible_triangular_number(n: int) -> int:\n    for i in range(1, 100000000):\n        result = i * (i + 1) // 2\n        count = 0\n        for j in range(1, int(math.sqrt(result)) + 1):\n            if result % j == 0:\n                count += 2\n            if j * j == result:\n                count -= 1\n        if count > n:\n            return result\n    return -1",
        "Euler013": "def large_sum(numbers: list[str]) -> str:\n    digits = [0] * 60\n    for i in range(50):\n        tmp = 0\n        for num in numbers:\n            tmp += int(num[49 - i])\n        for j in range(i, 60):\n            digits[j] += tmp % 10\n            if digits[j] >= 10:\n                digits[j + 1] += digits[j] // 10\n                digits[j] %= 10\n            tmp //= 10\n            if tmp == 0:\n                break\n    for i in range(59, -1, -1):\n        if digits[i] != 0:\n            result = ''\n            for j in range(i, i - 10, -1):\n                result += str(digits[j])\n            return result",
        "Euler014": "def longest_collatz_sequence(n: int) -> int:\n    longest = 0\n    result = 0\n    for i in range(1, n):\n        chain = 1\n        num = i\n        while num != 1:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = 3 * num + 1\n            chain += 1\n        if chain > longest:\n            longest = chain\n            result = i\n    return result",
        "Euler015": "def lattice_paths(m: int, n: int) -> int:\n    grid = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        grid[i][0] = 1\n    for j in range(n + 1):\n        grid[0][j] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n    return grid[m][n]",
        "Euler016": "def power_digit_sum(n: int) -> int:\n    digits = [2]\n    for _ in range(1, n):\n        carry = 0\n        for j in range(len(digits)):\n            temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp // 10\n        if carry:\n            digits.append(carry)\n    result = 0\n    for digit in digits:\n        result += digit\n    return result",
        "Euler017": "def number_to_words(n: int) -> str:\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000:\n        return \"one thousand\"\n    elif n >= 100:\n        if n % 100 == 0:\n            return ones[n // 100] + \" hundred\"\n        else:\n            return ones[n // 100] + \" hundred and \" + number_to_words(n % 100)\n    elif n >= 20:\n        suf = \"\"\n        if n % 10 != 0:\n            suf = \" \" + ones[n % 10]\n        return tens[n // 10] + suf\n    elif n >= 10:\n        return teens[n - 10]\n    else:\n        return ones[n]",
        "Euler018": "def maximum_path_sum_i(triangle: list[list[int]]) -> int:\n    curr = triangle[-1].copy()\n    for i in range(len(triangle) - 2, -1, -1):\n        next = triangle[i].copy()\n        for j in range(len(next)):\n            next[j] += max(curr[j], curr[j + 1])\n        curr = next\n    return curr[0]",
        "Euler019": "def counting_sundays(y1: int, y2: int) -> int:\n    day = 0\n    count = 0\n    for year in range(1900, y2 + 1):\n        for month in range(1, 13):\n            if year >= y1 and day % 7 == 6:\n                count += 1\n            if month in [4, 6, 9, 11]:\n                day += 30\n            elif month == 2:\n                if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n                    day += 29\n                else:\n                    day += 28\n            else:\n                day += 31\n    return count",
        "Euler020": "def factorial_digit_sum(n: int) -> int:\n    digits = [1]\n    for i in range(1, n+1):\n        carry = 0\n        for j in range(len(digits)):\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] // 10\n            digits[j] %= 10\n        while carry:\n            digits.append(carry % 10)\n            carry //= 10\n    result = 0\n    for digit in digits:\n        result += digit\n    return result",
        "Euler021": "def d(n: int) -> int:\n    result = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef amicable_numbers(n: int) -> int:\n    result = 0\n    for a in range(2, n):\n        b = d(a)\n        if a != b and a == d(b):\n            result += a\n    return result",
        "Euler022": "def names_scores(names: list[str], queries: list[str]) -> int:\n    s_names = sorted(names)\n    result = 0\n    for i, name in enumerate(s_names):\n        x = 0\n        for c in name:\n            x += ord(c) - 64\n        if name in queries:\n            result += x * (i + 1)\n    return result",
        "Euler023": "def is_abundant(n: int) -> bool:\n    if n < 12:\n        return False\n    sum_divisors = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors > n\n\ndef non_abundant_sums(n: int) -> int:\n    abundants = []\n    for i in range(12, n):\n        if is_abundant(i):\n            abundants.append(i)\n    abundant_sums = set()\n    for i in abundants:\n        for j in abundants:\n            abundant_sums.add(i + j)\n    result = 0\n    for i in range(n):\n        if i not in abundant_sums:\n            result += i\n    return result",
        "Euler024": "def lexicographic_permutations(n: int) -> str:\n    result = ''\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    for i in range(10, 0, -1):\n        fact = 1\n        for j in range(1, i):\n            fact *= j\n        idx = x // fact\n        result += str(digits[idx])\n        digits.pop(idx)\n        x -= idx * fact\n    return result",
        "Euler025": "def n_digit_fibonacci_number(n: int) -> int:\n    a = [1]\n    b = [1]\n    i = 2\n    while len(b) < n:\n        carry = 0\n        c = b.copy()\n        for j in range(len(b)):\n            if j < len(a):\n                b[j] = a[j] + b[j] + carry\n            else:\n                b[j] = b[j] + carry\n            carry = b[j] // 10\n            b[j] = b[j] % 10\n        if carry:\n            b.append(carry)\n        a = c\n        i = i + 1\n    return i",
        "Euler026": "def reciprocal_cycles(n: int) -> int:\n    result = 0\n    max_length = 0\n    for i in range(1, n):\n        remainders = []\n        remainder = 1\n        while remainder != 0 and remainder not in remainders:\n            remainders.append(remainder)\n            remainder = (remainder * 10) % i\n        length = 0\n        if remainder != 0:\n            length = len(remainders) - remainders.index(remainder)\n        if length > max_length:\n            max_length = length\n            result = i\n    return result",
        "Euler027": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef quadratic_primes(n: int) -> int:\n    max_primes = 0\n    result = 0\n    for a in range(-n + 1, n, 2):\n        for b in range(-n + 1, n, 2):\n            x = 0\n            while True:\n                if x * x + a * x + b < 2:\n                    break\n                if not is_prime(x * x + a * x + b):\n                    break\n                x += 1\n            if x > max_primes:\n                max_primes = x\n                result = a * b\n    return result",
        "Euler028": "def number_spiral_diagonals(n: int) -> int:\n    result = 1\n    for i in range(3, n + 1, 2):\n        result += 4 * i * i - 6 * i + 6\n    return result",
        "Euler029": "def distinct_powers(n: int) -> int:\n    result = 0\n    xs = set()\n    for i in range(2, n + 1):\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        for j in range(len(primes)):\n            while num % primes[j] == 0:\n                num //= primes[j]\n                powers[j] += 1\n        if num != 1:\n            result += n - 1\n            continue\n        for j in range(2, n + 1):\n            pstr = f\"{powers[0] * j}-{powers[1] * j}-{powers[2] * j}-{powers[3] * j}\"\n            xs.add(pstr)\n    result += len(xs)\n    return result",
        "Euler030": "def digit_nth_powers(n: int) -> int:\n    result = 0\n    for i in range(2, 4 * 10 ** n):\n        digits_sum = 0\n        for digit in str(i):\n            digits_sum += int(digit) ** n\n        if i == digits_sum:\n            result += i\n    return result",
        "Euler031": "def coin_sums(n: int) -> int:\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    for coin in coins:\n        for i in range(coin, n + 1):\n            ways[i] += ways[i - coin]\n    return ways[n]",
        "Euler032": "def pandigital_products(n: int) -> int:\n    products = set()\n    s = ''.join(str(i) for i in range(1, n+1))\n    for a in range(1, 100):\n        for b in range(1, 10000):\n            c = a * b\n            chars = list(str(a) + str(b) + str(c))\n            chars.sort()\n            if ''.join(chars) == s:\n                products.add(c)\n    result = 0\n    for product in products:\n        result += product\n    return result",
        "Euler033": "def digit_canceling_fractions(m: int) -> int:\n    numer = 1\n    denom = 1\n    for d in range(10, m):\n        for n in range(10, d):\n            n0, n1 = n % 10, n // 10\n            d0, d1 = d % 10, d // 10\n            if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0):\n                numer *= n\n                denom *= d\n    a, b = numer, denom\n    while b:\n        a, b = b, a % b\n    return denom // a",
        "Euler034": "def digit_factorials(n: int) -> int:\n    result = 0\n    for i in range(3, n):\n        fact_sum = 0\n        for digit in str(i):\n            fact = 1\n            for j in range(1, int(digit) + 1):\n                fact *= j\n            fact_sum += fact\n        if i == fact_sum:\n            result += i\n    return result",
        "Euler035": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef circular_primes(n: int) -> int:\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            rotations = set()\n            si = str(i)\n            for j in range(len(si)):\n                rotations.add(int(si[j:] + si[:j]))\n            flag = True\n            for x in rotations:\n                if not is_prime(x):\n                    flag = False\n                    break\n            if flag:\n                count += 1\n    return count",
        "Euler036": "def is_palindrome(s: str) -> bool:\n    for i in range(len(s) // 2):\n        if s[i] != s[-(i + 1)]:\n            return False\n    return True\n\ndef double_base_palindromes(n: int) -> int:\n    result = 0\n    for i in range(1, n):\n        str_i = str(i)\n        bin_i = str(bin(i)[2:])\n        if is_palindrome(str_i) and is_palindrome(bin_i):\n            result += i\n    return result",
        "Euler037": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef truncatable_primes(n: int) -> int:\n    result = 0\n    for i in range(10, n):\n        if is_prime(i):\n            si = str(i)\n            flag = True\n            for j in range(1, len(si)):\n                p1 = int(si[j:])\n                p2 = int(si[:-j])\n                if not is_prime(p1) or not is_prime(p2):\n                    flag = False\n                    break\n            if flag:\n                result += i\n    return result",
        "Euler038": "def pandigital_multiples(n: int) -> int:\n    result = -1\n    for i in range(2, n + 1):\n        cprod = ''\n        for j in range(1, 10):\n            cprod += str(i * j)\n            if len(cprod) == 9:\n                if ''.join(sorted(cprod)) == '123456789':\n                    result = max(result, int(cprod))\n                    break\n            elif len(cprod) > 9:\n                break\n    return result",
        "Euler039": "def integer_right_triangles(n: int) -> int:\n    max_sol = 0\n    result = 0\n    for p in range(3, n + 1):\n        sol = 0\n        for a in range(1, p // 2):\n            for b in range(a, p // 2):\n                c = p - a - b\n                if a * a + b * b == c * c:\n                    sol += 1\n        if sol > max_sol:\n            max_sol = sol\n            result = p\n    return result",
        "Euler040": "def champernowne_constant(b: int) -> int:\n    s = ''\n    for i in range(1, b**6):\n        s += str(i)\n    result = 1\n    for i in range(7):\n        result *= int(s[b**i - 1])\n    return result",
        "Euler041": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef pandigital_prime(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if is_prime(i):\n            si = str(i)\n            length = len(si)\n            flag = True\n            for j in range(1, length + 1):\n                if str(j) not in si:\n                    flag = False\n                    break\n            if flag:\n                return i\n    return -1",
        "Euler042": "def coded_triangle_numbers(words: list[str]) -> int:\n    result = 0\n    for word in words:\n        value = 0\n        for c in word:\n            value += ord(c) - 64\n        n = int(math.sqrt(value * 2))\n        if n * (n + 1) == value * 2:\n            result += 1\n    return result",
        "Euler043": "def gen_permutations(s: str) -> list[str]:\n    if len(s) <= 1:\n        return s\n    result = []\n    for perm in gen_permutations(s[1:]):\n        for i in range(len(s)):\n            result.append(perm[:i] + s[0:1] + perm[i:])\n    return result\n\n\ndef sub_string_divisibility(n: int) -> int:\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = ''.join(str(i) for i in range(n + 1))\n    for i in gen_permutations(s):\n        flag = True\n        for j in range(1, n - 1):\n            if int(i[j:j + 3]) % primes[j - 1] != 0:\n                flag = False\n                break\n        if flag:\n            result += int(i)\n    return result",
        "Euler044": "def pentagon_numbers(n: int) -> int:\n    pentagon = set()\n    for i in range(1, n):\n        pentagon.add(i * (3 * i - 1) // 2)\n    result = -1\n    for j in pentagon:\n        for k in pentagon:\n            if j + k in pentagon and k - j in pentagon:\n                if result == -1 or k - j < result:\n                    result = k - j\n    return result",
        "Euler045": "def triangular_pentagonal_and_hexagonal(n: int) -> int:\n    ps = set()\n    i = 1\n    c = 0.5 * i * (3 * i - 1)\n    while c < n:\n        i += 1\n        ps.add(c)\n        c = 0.5 * i * (3 * i - 1)     \n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n:\n        i += 1\n        if c in ps:\n            result = c\n        c = i * (2 * i - 1)\n    return result",
        "Euler046": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef goldbachs_other_conjecture(n: int) -> int:\n    result = -1\n    for i in range(9999, n, -2):\n        upper = int(math.sqrt(i // 2))\n        flag = False\n        for j in range(0, upper + 1):\n            if is_prime(i - 2 * j * j):\n                flag = True\n                break\n        if not flag:\n            result = i\n    return result",
        "Euler047": "def prime_factors(n: int) -> int:\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num:\n        if num % i:\n            i += 1\n        else:\n            num //= i\n            factors.append(i)\n    if num > 1:\n        factors.append(num)\n    return len(set(factors))\n\ndef distinct_primes_factors(n: int) -> int:\n    for i in range(n, 1000000):\n        if prime_factors(i) == 4 and prime_factors(i + 1) == 4 and prime_factors(i + 2) == 4 and prime_factors(i + 3) == 4:\n            return i\n    return -1",
        "Euler048": "def self_powers(n: int) -> str:\n    digits = [0] * 10\n    for i in range(1, n + 1):\n        temp_digits = [0] * 10\n        temp_digits[0] = 1\n        for j in range(i):\n            carry = 0\n            for k in range(10):\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] // 10\n                temp_digits[k] %= 10\n        for j in range(10):\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10:\n                digits[j] -= 10\n                if j < 9:\n                    digits[j + 1] += 1\n    result = \"\"\n    for i in range(9, -1, -1):\n        result += str(digits[i])\n    return result",
        "Euler049": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef gen_permutations(s: str) -> list[str]:\n    if len(s) <= 1:\n        return s\n    result = []\n    for perm in gen_permutations(s[1:]):\n        for i in range(len(s)):\n            result.append(perm[:i] + s[0:1] + perm[i:])\n    return result\n\ndef prime_permutations(n: int) -> str:\n    for i in range(n, 999, -1):\n        if is_prime(i):\n            permutations = gen_permutations(str(i))\n            candidates = set()\n            for j in permutations:\n                candidate = int(j)\n                if candidate > i and is_prime(candidate):\n                    candidates.add(candidate)\n            for m in candidates:\n                if m + (m - i) in candidates:\n                    return str(i) + str(m) + str(m + (m - i))\n    return ''",
        "Euler050": "def consecutive_prime_sum(limit: int) -> int:\n    sieve = [True] * limit\n    primes = []\n    for i in range(2, limit):\n        if sieve[i]:\n            primes.append(i)\n            for j in range(i * 2, limit, i):\n                sieve[j] = False\n    max_length = 0\n    max_prime = 0\n    for i in range(len(primes)):\n        for j in range(i + max_length, len(primes)):\n            s = sum(primes[i:j])\n            if s >= limit:\n                break\n            if sieve[s] and j - i > max_length:\n                max_length = j - i\n                max_prime = s\n    return max_prime"
    },
    "cpp": {
        "Euler001": "int multiplesOf3And5(int n) {\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler002": "int evenFibonacciNumbers(int n) {\n    int result = 0;\n    int a = 1;\n    int b = 2;\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a;\n        }\n        int tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
        "Euler003": "int largestPrimeFactor(int n) {\n    int result = n;\n    int i = 2;\n    while (i * i <= result) {\n        if (result % i) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
        "Euler004": "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - (i + 1)]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint largestPalindromeProduct(int n) {\n    int result = 0;\n    for (int i = 100; i < 1000; i++) {\n        for (int j = i; j < 1000; j++) {\n            int prod = i * j;\n            if (isPalindrome(to_string(prod)) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
        "Euler005": "int smallestMultiple(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        if (result % i != 0) {\n            for (int j = 1; j <= n; j++) {\n                if ((result * j) % i == 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
        "Euler006": "int sumSquareDifference(int n) {\n    int sqr_sum = 0;\n    int num_sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    return num_sum * num_sum - sqr_sum;\n}",
        "Euler007": "int nthPrime(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (primes.size() < n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes.back();\n}",
        "Euler008": "int largestProductInASeries(const string& s, int k) {\n    int result = 0;\n    for (int i = 0; i < s.length() - k; i++) {\n        int product = 1;\n        for (int j = 0; j < k; j++) {\n            product *= s[i + j] - '0';\n        }\n        result = max(result, product);\n    }\n    return result;\n}",
        "Euler009": "int specialPythagoreanTriplet(int n) {\n    for (int a = 1; a < n; a++) {\n        for (int b = a; b < n; b++) {\n            int c = n - a - b;\n            if (a * a + b * b == c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
        "Euler010": "int summationOfPrimes(int n) {\n    vector<int> primes = {2};\n    int i = 3;\n    while (i <= n) {\n        for (int p : primes) {\n            if (i % p == 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push_back(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    int result = 0;\n    for (int prime : primes) {\n        result += prime;\n    }\n    return result;\n}",
        "Euler011": "int largestProductInAGrid(const vector<vector<int>>& grid) {\n    int result = 0;\n    for (int i = 0; i < grid.size() - 3; i++) {\n        for (int j = 0; j < grid[i].size() - 3; j++) {\n            int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (int k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (int k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (int k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = max({result, p1, p2, p3, p4});\n        }\n    }\n    return result;\n}",
        "Euler012": "int highlyDivisibleTriangularNumber(int n) {\n    for (int i = 1; i < 100000000; i++) {\n        int result = i * (i + 1) / 2;\n        int count = 0;\n        for (int j = 1; j <= (int)sqrt(result); j++) {\n            if (result % j == 0) {\n                count += 2;\n            }\n            if (j * j == result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
        "Euler013": "string largeSum(const vector<string>& numbers) {\n    vector<int> digits(60, 0);\n    for (int i = 0; i < 50; i++) {\n        int tmp = 0;\n        for (auto num : numbers) {\n            tmp += num[49 - i] - '0';\n        }\n        for (int j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if (tmp == 0) {\n                break;\n            }\n        }\n    }\n    for (int i = 59; i >= 0; i--) {\n        if (digits[i] != 0) {\n            string result;\n            for (int j = i; j > i - 10; j--) {\n                result += to_string(digits[j]);\n            }\n            return result;\n        }\n    }\n    return \"\";\n}",
        "Euler014": "int longestCollatzSequence(int n) {\n    int longest = 0;\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        int chain = 1;\n        int num = i;\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
        "Euler015": "int latticePaths(int m, int n) {\n    vector<vector<int>> grid(m + 1, vector<int>(n + 1, 0));\n    for (int i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (int j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
        "Euler016": "int powerDigitSum(int n) {\n    vector<int> digits = {2};\n    for (int i = 1; i < n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            int temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if (carry) {\n            digits.push_back(carry);\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
        "Euler017": "string numberToWords(int n) {\n    vector<string> ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    vector<string> teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n    vector<string> tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n    if (n == 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\";\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        string suf = \"\";\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[n / 10] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }\n}",
        "Euler018": "int maximumPathSumI(const vector<vector<int>>& triangle) {\n    vector<int> curr = triangle.back();\n    for (int i = triangle.size() - 2; i >= 0; i--) {\n        vector<int> next = triangle[i];\n        for (int j = 0; j < next.size(); j++) {\n            next[j] += max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
        "Euler019": "int countingSundays(int y1, int y2) {\n    int day = 0;\n    int count = 0;\n    for (int year = 1900; year <= y2; year++) {\n        for (int month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 == 6) {\n                count++;\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30;\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
        "Euler020": "int factorialDigitSum(int n) {\n    vector<int> digits = {1};\n    for (int i = 1; i <= n; i++) {\n        int carry = 0;\n        for (int j = 0; j < digits.size(); j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while (carry) {\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    }\n    int result = 0;\n    for (int digit : digits) {\n        result += digit;\n    }\n    return result;\n}",
        "Euler021": "int d(int n) {\n    int result = 1;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            result += i;\n            if (i != n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nint amicableNumbers(int n) {\n    int result = 0;\n    for (int a = 2; a < n; a++) {\n        int b = d(a);\n        if (a != b && a == d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
        "Euler022": "int namesScores(const vector<string>& names, const vector<string>& queries) {\n    vector<string> s_names = names;\n    sort(s_names.begin(), s_names.end());\n    int result = 0;\n    for (int i = 0; i < s_names.size(); i++) {\n        int x = 0;\n        for (int j = 0; j < s_names[i].size(); j++) {\n            x += s_names[i][j] - 64;\n        }\n        if (find(queries.begin(), queries.end(), s_names[i]) != queries.end()) {\n            result += x * (i + 1);\n        }\n    }\n    return result;\n}",
        "Euler023": "bool isAbundant(int n) {\n    if (n < 12) {\n        return false;\n    }\n    int sumDivisors = 1;\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            sumDivisors += i;\n            if (i != n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nint nonAbundantSums(int n) {\n    vector<int> abundants;\n    for (int i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push_back(i);\n        }\n    }\n    set<int> abundantSums;\n    for (int i : abundants) {\n        for (int j : abundants) {\n            abundantSums.insert(i + j);\n        }\n    }\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        if (abundantSums.find(i) == abundantSums.end()) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler024": "string lexicographicPermutations(int n) {\n    string result = \"\";\n    vector<int> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int x = n - 1;\n    for (int i = 10; i > 0; i--) {\n        int fact = 1;\n        for (int j = 1; j < i; j++) {\n            fact *= j;\n        }\n        int idx = x / fact;\n        result += to_string(digits[idx]);\n        digits.erase(digits.begin() + idx);\n        x -= idx * fact;\n    }\n    return result;\n}",
        "Euler025": "int nDigitFibonacciNumber(int n) {\n    vector<int> a = {1};\n    vector<int> b = {1};\n    int i = 2;\n    while (b.size() < n) {\n        int carry = 0;\n        vector<int> c = b;\n        for (int j = 0; j < b.size(); j++) {\n            if (j < a.size()) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if (carry) {\n            b.push_back(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
        "Euler026": "int reciprocalCycles(int n) {\n    int result = 0;\n    int max_length = 0;\n    for (int i = 1; i < n; i++) {\n        vector<int> remainders;\n        int remainder = 1;\n        while (remainder != 0 && find(remainders.begin(), remainders.end(), remainder) == remainders.end()) {\n            remainders.push_back(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        int length = 0;\n        if (remainder != 0) {\n            length = remainders.size() - (find(remainders.begin(), remainders.end(), remainder) - remainders.begin());\n        }\n        if (length > max_length) {\n            max_length = length;\n            result = i;\n        }\n    }\n    return result;\n}",
        "Euler027": "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint quadraticPrimes(int n) {\n    int maxPrimes = 0;\n    int result = 0;\n    for (int a = -n + 1; a < n; a += 2) {\n        for (int b = -n + 1; b < n; b += 2) {\n            int x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
        "Euler028": "int numberSpiralDiagonals(int n) {\n    int result = 1;\n    for (int i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
        "Euler029": "int distinctPowers(int n) {\n    int result = 0;\n    unordered_set<string> xs;\n    for (int i = 2; i <= n; i++) {\n        vector<int> primes = {2, 3, 5, 7};\n        vector<int> powers = {0, 0, 0, 0};\n        int num = i;\n        for (int j = 0; j < primes.size(); j++) {\n            while (num % primes[j] == 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num != 1) {\n            result += n - 1;\n            continue;\n        }\n        for (int j = 2; j <= n; j++) {\n            string pstr = format(\"{}-{}-{}-{}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.size();\n    return result;\n}",
        "Euler030": "int digitNthPowers(int n) {\n    int result = 0;\n    for (int i = 2; i < 4 * pow(10, n); i++) {\n        int digit_sum = 0;\n        for (char digit : to_string(i)) {\n            digit_sum += pow(digit - '0', n);\n        }\n        if (i == digit_sum) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler031": "int coinSums(int n) {\n    vector<int> coins = {1, 2, 5, 10, 20, 50, 100, 200};\n    vector<int> ways(n + 1, 0);\n    ways[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
        "Euler032": "int pandigitalProducts(int n) {\n    unordered_set<int> products;\n    string s;\n    for (int i = 1; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (int a = 1; a < 100; a++) {\n        for (int b = 1; b < 10000; b++) {\n            int c = a * b;\n            string chars = to_string(a) + to_string(b) + to_string(c);\n            sort(chars.begin(), chars.end());\n            if (chars == s) {\n                products.insert(c);\n            }\n        }\n    }\n    int result = 0;\n    for (int product : products) {\n        result += product;\n    }\n    return result;\n}",
        "Euler033": "int digitCancelingFractions(int m) {\n    int numer = 1;\n    int denom = 1;\n    for (int d = 10; d < m; d++) {\n        for (int n = 10; n < d; n++) {\n            int n0 = n % 10;\n            int n1 = n / 10;\n            int d0 = d % 10;\n            int d1 = d / 10;\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    int a = numer;\n    int b = denom;\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return denom / a;\n}",
        "Euler034": "int digitFactorials(int n) {\n    int result = 0;\n    for (int i = 3; i < n; i++) {\n        int factSum = 0;\n        for (char digit : to_string(i)) {\n            int fact = 1;\n            for (int j = 1; j <= digit - '0'; j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i == factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler035": "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint circularPrimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            unordered_set<int> rotations;\n            string si = to_string(i);\n            for (int j = 0; j < si.size(); j++) {\n                rotations.insert(stoi(si.substr(j) + si.substr(0, j)));\n            }\n            bool flag = true;\n            for (int x : rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "Euler036": "bool isPalindrome(const string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - (i + 1)]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint doubleBasePalindromes(int n) {\n    int result = 0;\n    for (int i = 1; i < n; i++) {\n        string str_i = to_string(i);\n        string bin_i = bitset<32>(i).to_string();\n        bin_i.erase(0, min(bin_i.find_first_not_of('0'), bin_i.size() - 1));\n        if (isPalindrome(str_i) && isPalindrome(bin_i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler037": "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint truncatablePrimes(int n) {\n    int result = 0;\n    for (int i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            bool flag = true;\n            for (int j = 1; j < si.size(); j++) {\n                int p1 = stoi(si.substr(j));\n                int p2 = stoi(si.substr(0, si.size() - j));\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
        "Euler038": "int pandigitalMultiples(int n) {\n    int result = -1;\n    for (int i = 2; i <= n; i++) {\n        string cprod;\n        for (int j = 1; j < 10; j++) {\n            cprod += to_string(i * j);\n            if (cprod.length() == 9) {\n                string chars = cprod;\n                sort(chars.begin(), chars.end());\n                if (chars == \"123456789\") {\n                    result = max(result, stoi(cprod));\n                    break;\n                }\n            } else if (cprod.length() > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
        "Euler039": "int integerRightTriangles(int n) {\n    int max_sol = 0;\n    int result = 0;\n    for (int p = 3; p <= n; p++) {\n        int sol = 0;\n        for (int a = 1; a < p / 2; a++) {\n            for (int b = a; b < p / 2; b++) {\n                int c = p - a - b;\n                if (a * a + b * b == c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > max_sol) {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
        "Euler040": "int champernowneConstant(int b) {\n    string s = \"\";\n    for (int i = 1; i < pow(b, 6); i++) {\n        s += to_string(i);\n    }\n    int result = 1;\n    for (int i = 0; i < 7; i++) {\n        result *= s[pow(b, i) - 1] - '0';\n    }\n    return result;\n}",
        "Euler041": "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint pandigitalPrime(int n) {\n    for (int i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            string si = to_string(i);\n            int length = si.length();\n            bool flag = true;\n            for (int j = 1; j <= length; j++) {\n                if (si.find(to_string(j)) == string::npos) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
        "Euler042": "int codedTriangleNumbers(const vector<string>& words) {\n    int result = 0;\n    for (const string& word : words) {\n        int value = 0;\n        for (char c : word) {\n            value += c - 64;\n        }\n        int n = int(sqrt(value * 2));\n        if (n * (n + 1) == value * 2) {\n            result++;\n        }\n    }\n    return result;\n}",
        "Euler043": "vector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s[0] + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nint subStringDivisibility(int n) {\n    int result = 0;\n    vector<int> primes = {2, 3, 5, 7, 11, 13, 17};\n    string s;\n    for (int i = 0; i <= n; i++) {\n        s += to_string(i);\n    }\n    for (const string& i : genPermutations(s)) {\n        bool flag = true;\n        for (int j = 1; j < n - 1; j++) {\n            if (stoi(i.substr(j, 3)) % primes[j - 1] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += stoi(i);\n        }\n    }\n    return result;\n}",
        "Euler044": "int pentagonNumbers(int n) {\n    unordered_set<int> pentagon;\n    for (int i = 1; i < n; i++) {\n        pentagon.insert(i * (3 * i - 1) / 2);\n    }\n    int result = -1;\n    for (int j : pentagon) {\n        for (int k : pentagon) {\n            if (pentagon.count(j + k) && pentagon.count(k - j)) {\n                if (result == -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
        "Euler045": "int triangularPentagonalAndHexagonal(int n) {\n    unordered_set<int> ps;\n    int i = 1;\n    int c = 0.5 * i * (3 * i - 1);\n    while (c < n) {\n        i++;\n        ps.insert(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    int result = -1;\n    while (c < n) {\n        i++;\n        if (ps.find(c) != ps.end()) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
        "Euler046": "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint goldbachsOtherConjecture(int n) {\n    int result = -1;\n    for (int i = 9999; i > n; i -= 2) {\n        int upper = sqrt(i / 2);\n        bool flag = false;\n        for (int j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
        "Euler047": "int primeFactors(int n) {\n    int num = n;\n    vector<int> factors;\n    int i = 2;\n    while (i * i <= num) {\n        if (num % i) {\n            i++;\n        } else {\n            num /= i;\n            factors.push_back(i);\n        }\n    }\n    if (num > 1) {\n        factors.push_back(num);\n    }\n    unordered_set<int> s(factors.begin(), factors.end());\n    return s.size();\n}\n\nint distinctPrimesFactors(int n) {\n    for (int i = n; i < 1000000; i++) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
        "Euler048": "string selfPowers(int n) {\n    int digits[10] = {0};\n    for (int i = 1; i <= n; i++) {\n        int temp_digits[10] = {0};\n        temp_digits[0] = 1;\n        for (int j = 0; j < i; j++) {\n            int carry = 0;\n            for (int k = 0; k < 10; k++) {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for (int j = 0; j < 10; j++) {\n            digits[j] += temp_digits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    string result = \"\";\n    for (int i = 9; i >= 0; i--) {\n        result += to_string(digits[i]);\n    }\n    return result;\n}",
        "Euler049": "bool isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= int(sqrt(n)); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<string> genPermutations(const string& s) {\n    if (s.size() <= 1) {\n        return {s};\n    }\n    vector<string> result;\n    for (const string& perm : genPermutations(s.substr(1))) {\n        for (int i = 0; i < s.size(); i++) {\n            result.push_back(perm.substr(0, i) + s[0] + perm.substr(i));\n        }\n    }\n    return result;\n}\n\nstring primePermutations(int n) {\n    for (int i = n; i > 999; --i) {\n        if (isPrime(i)) {\n            vector<string> permutations = genPermutations(to_string(i));\n            unordered_set<int> candidates;\n            for (string j : permutations) {\n                int candidate = stoi(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.insert(candidate);\n                }\n            }\n            for (int m : candidates) {\n                if (candidates.count(m + (m - i))) {\n                    return to_string(i) + to_string(m) + to_string(m + (m - i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
        "Euler050": "int consecutivePrimeSum(int limit) {\n    vector<bool> sieve(limit, true);\n    vector<int> primes;\n    for (int i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n            for (int j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    int max_length = 0;\n    int max_prime = 0;\n    for (int i = 0; i < primes.size(); i++) {\n        for (int j = i + max_length; j < primes.size(); j++) {\n            int s = 0;\n            for (int k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > max_length) {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    return max_prime;\n}"
    },
    "csharp": {
        "Euler001": "class Global {\n    public static int MultiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler002": "class Global {\n    public static int EvenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
        "Euler003": "class Global {\n    public static int LargestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i != 0) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler004": "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i] != s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int LargestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (IsPalindrome(prod.ToString()) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler005": "class Global {\n    public static int SmallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i != 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler006": "class Global {\n    public static int SumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
        "Euler007": "class Global {\n    public static int NthPrime(int n) {\n        List<int> primes = new List<int> {2};\n        int i = 3;\n        while (primes.Count < n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes.Last();\n    }\n}",
        "Euler008": "class Global {\n    public static int LargestProductInASeries(string s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.Length - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= s[i + j] - '0';\n            }\n            result = Math.Max(result, product);\n        }\n        return result;\n    }\n}",
        "Euler009": "class Global {\n    public static int SpecialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "Euler010": "class Global {\n    public static int SummationOfPrimes(int n) {\n        List<int> primes = new List<int> {2};\n        int i = 3;\n        while (i <= n) {\n            foreach (int p in primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.Add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        foreach (int prime in primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
        "Euler011": "class Global {\n    public static int LargestProductInAGrid(IList<IList<int>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.Count - 3; i++) {\n            for (int j = 0; j < grid[i].Count - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid[i + k][j];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid[i][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid[i + k][j + k];\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid[i + k][j + 3 - k];\n                }\n                result = new int[] {result, p1, p2, p3, p4}.Max();\n            }\n        }\n        return result;\n    }\n}",
        "Euler012": "class Global {\n    public static int HighlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int)Math.Sqrt(result); j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }    \n}",
        "Euler013": "class Global {\n    public static string LargeSum(IList<string> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            foreach (var num in numbers) {\n                tmp += num[49 - i] - '0';\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i] != 0) {\n                string result = \"\";\n                for (int j = i; j > i - 10; j--) {\n                    result += digits[j].ToString();\n                }\n                return result;\n            }\n        }\n        return \"\";\n    }\n}",
        "Euler014": "class Global {\n    public static int LongestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler015": "class Global {\n    public static int LatticePaths(int m, int n) {\n        int[,] grid = new int[m + 1, n + 1];\n        for (int i = 0; i <= m; i++) {\n            grid[i, 0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0, j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i, j] = grid[i - 1, j] + grid[i, j - 1];\n            }\n        }\n        return grid[m, n];\n    }\n}",
        "Euler016": "class Global {\n    public static int PowerDigitSum(int n) {\n        List<int> digits = new List<int> {2};\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                int temp = digits[j] * 2 + carry;\n                digits[j] = temp % 10;\n                carry = temp / 10;\n            }\n            if (carry != 0) {\n                digits.Add(carry);\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
        "Euler017": "class Global {\n    public static string NumberToWords(int n) {\n        string[] ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        string[] teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        string[] tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            string suf = \"\";\n            if (n % 10 != 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
        "Euler018": "class Global {\n    public static int MaximumPathSumI(IList<IList<int>> triangle) {\n        List<int> curr = triangle.Last().ToList();\n        for (int i = triangle.Count - 2; i >= 0; i--) {\n            List<int> next = triangle[i].ToList();\n            for (int j = 0; j < next.Count; j++) {\n                next[j] += Math.Max(curr[j], curr[j + 1]);\n            }\n            curr = next;\n        }\n        return curr[0];\n    }\n}",
        "Euler019": "class Global {\n    public static int CountingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count++;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
        "Euler020": "class Global {\n    public static int FactorialDigitSum(int n) {\n        List<int> digits = new List<int> {1};\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.Count; j++) {\n                digits[j] = digits[j] * i + carry;\n                carry = digits[j] / 10;\n                digits[j] %= 10;\n            }\n            while (carry != 0) {\n                digits.Add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        foreach (int digit in digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
        "Euler021": "class Global {\n    public static int D(int n) {\n        int result = 1;\n        for (int i = 2; i <= Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i != n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int AmicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = D(a);\n            if (a != b && a == D(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
        "Euler022": "class Global {\n    public static int NamesScores(IList<string> names, IList<string> queries) {\n        var sNames = names.OrderBy(x => x).ToList();\n        var result = 0;\n        for (var i = 0; i < sNames.Count; i++) {\n            var x = 0;\n            foreach (var c in sNames[i]) {\n                x += c - 64;\n            }\n            if (queries.Contains(sNames[i])) {\n                result += x * (i + 1);\n            }\n        }\n        return result;\n    }\n}",
        "Euler023": "class Global {\n    public static bool IsAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= Math.Sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i != n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int NonAbundantSums(int n) {\n        List<int> abundants = new List<int>();\n        for (int i = 12; i < n; i++) {\n            if (IsAbundant(i)) {\n                abundants.Add(i);\n            }\n        }\n        HashSet<int> abundantSums = new HashSet<int>();\n        foreach (int i in abundants) {\n            foreach (int j in abundants) {\n                abundantSums.Add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.Contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler024": "class Global {\n    public static string LexicographicPermutations(int n) {\n        string result = \"\";\n        List<int> digits = new List<int> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += digits[idx].ToString();\n            digits.RemoveAt(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
        "Euler025": "class Global {\n    public static int NDigitFibonacciNumber(int n) {\n        List<int> a = new List<int> {1};\n        List<int> b = new List<int> {1};\n        int i = 2;\n        while (b.Count < n) {\n            int carry = 0;\n            List<int> c = new List<int>(b);\n            for (int j = 0; j < b.Count; j++) {\n                if (j < a.Count) {\n                    b[j] = a[j] + b[j] + carry;\n                } else {\n                    b[j] = b[j] + carry;\n                }\n                carry = b[j] / 10;\n                b[j] = b[j] % 10;\n            }\n            if (carry != 0) {\n                b.Add(carry);\n            }\n            a = new List<int>(c);\n            i = i + 1;\n        }\n        return i;\n    }\n}",
        "Euler026": "class Global {\n    public static int ReciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            List<int> remainders = new List<int>();\n            int remainder = 1;\n            while (remainder != 0 && !remainders.Contains(remainder)) {\n                remainders.Add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder != 0) {\n                length = remainders.Count - remainders.IndexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler027": "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int QuadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!IsPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x++;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler028": "class Global {\n    public static int NumberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
        "Euler029": "class Global {\n    public static int DistinctPowers(int n) {\n        int result = 0;\n        HashSet<string> xs = new HashSet<string>();\n        for (int i = 2; i <= n; i++) {\n            List<int> primes = new List<int> {2, 3, 5, 7};\n            List<int> powers = new List<int> {0, 0, 0, 0};\n            int num = i;\n            for (int j = 0; j < primes.Count; j++) {\n                while (num % primes[j] == 0) {\n                    num /= primes[j];\n                    powers[j] += 1;\n                }\n            }\n            if (num != 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                string pstr = string.Format(\"{0}-{1}-{2}-{3}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n                xs.Add(pstr);\n            }\n        }\n        result += xs.Count;\n        return result;\n    }\n}",
        "Euler030": "class Global {\n    public static int DigitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * Math.Pow(10, n); i++) {\n            int digitsSum = 0;\n            foreach (char digit in i.ToString()) {\n                digitsSum += (int)Math.Pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler031": "class Global {\n    public static int CoinSums(int n) {\n        int[] coins = {1, 2, 5, 10, 20, 50, 100, 200};\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        foreach (int coin in coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
        "Euler032": "class Global {\n    public static int PandigitalProducts(int n) {\n        HashSet<int> products = new HashSet<int>();\n        string s = \"\";\n        for (int i = 1; i <= n; i++) {\n            s += i.ToString();\n        }\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                char[] chars = (a.ToString() + b.ToString() + c.ToString()).ToCharArray();\n                Array.Sort(chars);\n                if (new string(chars) == s) {\n                    products.Add(c);\n                }\n            }\n        }\n        int result = 0;\n        foreach (int product in products) {\n            result += product;\n        }\n        return result;\n    }\n}",
        "Euler033": "class Global {\n    public static int DigitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
        "Euler034": "class Global {\n    public static int DigitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            foreach (char digit in i.ToString()) {\n                int fact = 1;\n                for (int j = 1; j <= digit - '0'; j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler035": "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int CircularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (IsPrime(i)) {\n                HashSet<int> rotations = new HashSet<int>();\n                string si = i.ToString();\n                for (int j = 0; j < si.Length; j++) {\n                    rotations.Add(int.Parse(si.Substring(j) + si.Substring(0, j)));\n                }\n                bool flag = true;\n                foreach (int x in rotations) {\n                    if (!IsPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
        "Euler036": "class Global {\n    public static bool IsPalindrome(string s) {\n        for (int i = 0; i < s.Length / 2; i++) {\n            if (s[i] != s[s.Length - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int DoubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            string strI = i.ToString();\n            string binI = Convert.ToString(i, 2);\n            if (IsPalindrome(strI) && IsPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler037": "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int TruncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                bool flag = true;\n                for (int j = 1; j < si.Length; j++) {\n                    int p1 = int.Parse(si.Substring(j));\n                    int p2 = int.Parse(si.Substring(0, si.Length - j));\n                    if (!IsPrime(p1) || !IsPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler038": "class Global {\n    public static int PandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            string cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += (i * j).ToString();\n                if (cprod.Length == 9) {\n                    char[] chars = cprod.ToCharArray();\n                    Array.Sort(chars);\n                    if (new string(chars) == \"123456789\") {\n                        result = Math.Max(result, int.Parse(cprod));\n                        break;\n                    }\n                } else if (cprod.Length > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler039": "class Global {\n    public static int IntegerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol++;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
        "Euler040": "class Global {\n    public static int ChampernowneConstant(int b) {\n        string s = \"\";\n        for (int i = 1; i < Math.Pow(b, 6); i++) {\n            s += i.ToString();\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            result *= s[(int)Math.Pow(b, i) - 1] - '0';\n        }\n        return result;\n    }\n}",
        "Euler041": "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int PandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (IsPrime(i)) {\n                string si = i.ToString();\n                int length = si.Length;\n                bool flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (!si.Contains(j.ToString())) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "Euler042": "class Global {\n    public static int CodedTriangleNumbers(IList<string> words) {\n        int result = 0;\n        foreach (string word in words) {\n            int value = 0;\n            foreach (char c in word) {\n                value += c - 64;\n            }\n            int n = (int)Math.Sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
        "Euler043": "class Global {\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        List<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int SubStringDivisibility(int n) {\n        int result = 0;\n        List<int> primes = new List<int> { 2, 3, 5, 7, 11, 13, 17 };\n        string s = \"\";\n        for (int i = 0; i <= n; i++) {\n            s += i.ToString();\n        }\n        foreach (string i in GenPermutations(s)) {\n            bool flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (int.Parse(i.Substring(j, 3)) % primes[j - 1] != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += int.Parse(i);\n            }\n        }\n        return result;\n    }\n}",
        "Euler044": "class Global {\n    public static int PentagonNumbers(int n) {\n        HashSet<int> pentagon = new HashSet<int>();\n        for (int i = 1; i < n; i++) {\n            pentagon.Add(i * (3 * i - 1) / 2);\n        }\n        int result = -1;\n        foreach (int j in pentagon) {\n            foreach (int k in pentagon) {\n                if (pentagon.Contains(j + k) && pentagon.Contains(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler045": "class Global {\n    public static int TriangularPentagonalAndHexagonal(int n) {\n        HashSet<int> ps = new HashSet<int>();\n        int i = 1;\n        int c = (int)(0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i++;\n            ps.Add(c);\n            c = (int)(0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i++;\n            if (ps.Contains(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
        "Euler046": "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int GoldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i > n; i -= 2) {\n            int upper = (int)Math.Sqrt(i / 2);\n            bool flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (IsPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler047": "class Global {\n    public static int PrimeFactors(int n) {\n        int num = n;\n        List<int> factors = new List<int>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i != 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.Add(i);\n            }\n        }\n        if (num > 1) {\n            factors.Add(num);\n        }\n        return factors.Distinct().Count();\n    }\n\n    public static int DistinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
        "Euler048": "class Global {\n    public static string SelfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        string result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += digits[i].ToString();\n        }\n        return result;\n    }\n}",
        "Euler049": "class Global {\n    public static bool IsPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.Sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static IList<string> GenPermutations(string s) {\n        if (s.Length <= 1) {\n            return new List<string> { s };\n        }\n        List<string> result = new List<string>();\n        foreach (string perm in GenPermutations(s.Substring(1))) {\n            for (int i = 0; i < s.Length; i++) {\n                result.Add(perm.Substring(0, i) + s[0] + perm.Substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static string PrimePermutations(int n) {\n        for (int i = n; i > 999; --i) {\n            if (IsPrime(i)) {\n                var permutations = GenPermutations(i.ToString());\n                var candidates = new HashSet<int>();\n                foreach (var j in permutations) {\n                    var candidate = int.Parse(j);\n                    if (candidate > i && IsPrime(candidate)) {\n                        candidates.Add(candidate);\n                    }\n                }\n                foreach (var m in candidates) {\n                    if (candidates.Contains(m + (m - i))) {\n                        return i.ToString() + m.ToString() + (m + (m - i)).ToString();\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
        "Euler050": "class Global {\n    public static int ConsecutivePrimeSum(int limit) {\n        bool[] sieve = new bool[limit];\n        Array.Fill(sieve, true);\n        List<int> primes = new List<int>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.Add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.Count; i++) {\n            for (int j = i + maxLength; j < primes.Count; j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes[k];\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
    },
    "go": {
        "Euler001": "func MultiplesOf3And5(n int) int {\n    result := 0\n    for i := 0; i < n; i++ {\n        if i % 3 == 0 || i % 5 == 0 {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler002": "func EvenFibonacciNumbers(n int) int {\n    result := 0\n    a := 1\n    b := 2\n    for a < n {\n        if a % 2 == 0 {\n            result += a\n        }\n        tmp := a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
        "Euler003": "func LargestPrimeFactor(n int) int {\n    result := n\n    i := 2\n    for i * i <= result {\n        if result % i != 0 {\n            i += 1\n        } else {\n            result /= i\n        }\n    }\n    return result\n}",
        "Euler004": "func IsPalindrome(s string) bool {\n    for i := 0; i < len(s) / 2; i++ {\n        if s[i] != s[len(s) - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc LargestPalindromeProduct(n int) int {\n    result := 0\n    for i := 100; i < 1000; i++ {\n        for j := i; j < 1000; j++ {\n            prod := i * j\n            if IsPalindrome(strconv.Itoa(prod)) && prod > result && prod < n {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
        "Euler005": "func SmallestMultiple(n int) int {\n    result := 1\n    for i := 1; i <= n; i++ {\n        if result % i != 0 {\n            for j := 1; j <= n; j++ {\n                if (result * j) % i == 0 {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
        "Euler006": "func SumSquareDifference(n int) int {\n    sqrSum := 0\n    numSum := 0\n    for i := 1; i <= n; i++ {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
        "Euler007": "func NthPrime(n int) int {\n    primes := []int{2}\n    i := 3\n    for len(primes) < n {\n        for _, p := range primes {\n            if i % p == 0 {\n                break\n            }\n            if p * p > i {\n                primes = append(primes, i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes[len(primes) - 1]\n}",
        "Euler008": "func LargestProductInASeries(s string, k int) int {\n    result := 0\n    for i := 0; i < len(s) - k; i++ {\n        product := 1\n        for j := 0; j < k; j++ {\n            product *= int(s[i + j] - '0')\n        }\n        result = max(result, product)\n    }\n    return result\n}",
        "Euler009": "func SpecialPythagoreanTriplet(n int) int {\n    for a := 1; a < n; a++ {\n        for b := a; b < n; b++ {\n            c := n - a - b\n            if a * a + b * b == c * c {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
        "Euler010": "func SummationOfPrimes(n int) int {\n    primes := []int{2}\n    i := 3\n    for i <= n {\n        for _, p := range primes {\n            if i % p == 0 {\n                break\n            }\n            if p * p > i {\n                primes = append(primes, i)\n                break\n            }\n        }\n        i += 2\n    }\n    result := 0\n    for _, prime := range primes {\n        result += prime\n    }\n    return result\n}",
        "Euler011": "func LargestProductInAGrid(grid [][]int) int {\n    result := 0\n    for i := 0; i < len(grid) - 3; i++ {\n        for j := 0; j < len(grid[i]) - 3; j++ {\n            p1, p2, p3, p4 := 1, 1, 1, 1\n            for k := 0; k < 4; k++ {\n                p1 *= grid[i + k][j]\n            }\n            for k := 0; k < 4; k++ {\n                p2 *= grid[i][j + k]\n            }\n            for k := 0; k < 4; k++ {\n                p3 *= grid[i + k][j + k]\n            }\n            for k := 0; k < 4; k++ {\n                p4 *= grid[i + k][j + 3 - k]\n            }\n            result = max(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
        "Euler012": "func HighlyDivisibleTriangularNumber(n int) int {\n    for i := 1; i < 100000000; i++ {\n        result := i * (i + 1) / 2\n        count := 0\n        for j := 1; j <= int(math.Sqrt(float64(result))); j++ {\n            if result % j == 0 {\n                count += 2\n            }\n            if j * j == result {\n                count -= 1\n            }\n        }\n        if count > n {\n            return result\n        }\n    }\n    return -1\n}",
        "Euler013": "func LargeSum(numbers []string) string {\n    digits := make([]int, 60)\n    for i := 0; i < 50; i++ {\n        tmp := 0\n        for _, num := range numbers {\n            tmp += int(num[49 - i] - '0')\n        }\n        for j := i; j < 60; j++ {\n            digits[j] += tmp % 10\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if tmp == 0 {\n                break\n            }\n        }\n    }\n    for i := 59; i >= 0; i-- {\n        if digits[i] != 0 {\n            result := \"\"\n            for j := i; j > i - 10; j-- {\n                result += strconv.Itoa(digits[j])\n            }\n            return result\n        }\n    }\n    return \"\"\n}",
        "Euler014": "func LongestCollatzSequence(n int) int {\n    longest := 0\n    result := 0\n    for i := 1; i < n; i++ {\n        chain := 1\n        num := i\n        for num != 1 {\n            if num % 2 == 0 {\n                num = num / 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain++\n        }\n        if chain > longest {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
        "Euler015": "func LatticePaths(m int, n int) int {\n    grid := make([][]int, m + 1)\n    for i := 0; i <= m; i++ {\n        grid[i] = make([]int, n + 1)\n        grid[i][0] = 1\n    }\n    for j := 0; j <= n; j++ {\n        grid[0][j] = 1\n    }\n    for i := 1; i <= m; i++ {\n        for j := 1; j <= n; j++ {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
        "Euler016": "func PowerDigitSum(n int) int {\n    digits := []int{2}\n    for i := 1; i < n; i++ {\n        carry := 0\n        for j := 0; j < len(digits); j++ {\n            temp := digits[j]*2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if carry != 0 {\n            digits = append(digits, carry)\n        }\n    }\n    result := 0\n    for _, digit := range digits {\n        result += digit\n    }\n    return result\n}",
        "Euler017": "func NumberToWords(n int) string {\n    ones := []string{\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    teens := []string{\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"}\n    tens := []string{\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"}\n    if n == 1000 {\n        return \"one thousand\"\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            return ones[n / 100] + \" hundred\"\n        } else {\n            return ones[n / 100] + \" hundred and \" + NumberToWords(n % 100)\n        }\n    } else if n >= 20 {\n        suf := \"\"\n        if n % 10 != 0 {\n            suf = \" \" + ones[n % 10]\n        }\n        return tens[n / 10] + suf\n    } else if n >= 10 {\n        return teens[n - 10]\n    } else {\n        return ones[n]\n    }\n}",
        "Euler018": "func MaximumPathSumI(triangle [][]int) int {\n    curr := make([]int, len(triangle[len(triangle) - 1]))\n    copy(curr, triangle[len(triangle) - 1])\n    for i := len(triangle) - 2; i >= 0; i-- {\n        next := make([]int, len(triangle[i]))\n        copy(next, triangle[i])\n        for j := 0; j < len(next); j++ {\n            next[j] += int(math.Max(float64(curr[j]), float64(curr[j + 1])))\n        }\n        curr = next\n    }\n    return curr[0]\n}",
        "Euler019": "func CountingSundays(y1 int, y2 int) int {\n    day := 0\n    count := 0\n    for year := 1900; year <= y2; year++ {\n        for month := 1; month <= 12; month++ {\n            if year >= y1 && day % 7 == 6 {\n                count++\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30\n            } else if month == 2 {\n                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
        "Euler020": "func FactorialDigitSum(n int) int {\n    digits := []int{1}\n    for i := 1; i <= n; i++ {\n        carry := 0\n        for j := 0; j < len(digits); j++ {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        for carry != 0 {\n            digits = append(digits, carry % 10)\n            carry /= 10\n        }\n    }\n    result := 0\n    for _, digit := range digits {\n        result += digit\n    }\n    return result\n}",
        "Euler021": "func D(n int) int {\n    result := 1\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n % i == 0 {\n            result += i\n            if i != n / i {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfunc AmicableNumbers(n int) int {\n    result := 0\n    for a := 2; a < n; a++ {\n        b := D(a)\n        if a != b && a == D(b) {\n            result += a\n        }\n    }\n    return result\n}",
        "Euler022": "func NamesScores(names []string, queries []string) int {\n    sNames := slices.Clone(names)\n    slices.Sort(sNames)\n    result := 0\n    for i, name := range sNames {\n        x := 0\n        for _, c := range name {\n            x += int(c) - 64\n        }\n        for _, query := range queries {\n            if query == name {\n                result += x * (i + 1)\n                break\n            }\n        }\n    }\n    return result\n}",
        "Euler023": "func IsAbundant(n int) bool {\n    if n < 12 {\n        return false\n    }\n    sumDivisors := 1\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n % i == 0 {\n            sumDivisors += i\n            if i != n / i {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfunc NonAbundantSums(n int) int {\n    abundants := []int{}\n    for i := 12; i < n; i++ {\n        if IsAbundant(i) {\n            abundants = append(abundants, i)\n        }\n    }\n    abundantSums := map[int]bool{}\n    for _, i := range abundants {\n        for _, j := range abundants {\n            abundantSums[i + j] = true\n        }\n    }\n    result := 0\n    for i := 0; i < n; i++ {\n        if !abundantSums[i] {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler024": "func LexicographicPermutations(n int) string {\n    result := \"\"\n    digits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    x := n - 1\n    for i := 10; i > 0; i-- {\n        fact := 1\n        for j := 1; j < i; j++ {\n            fact *= j\n        }\n        idx := x / fact\n        result += strconv.Itoa(digits[idx])\n        digits = append(digits[:idx], digits[idx+1:]...)\n        x -= idx * fact\n    }\n    return result\n}",
        "Euler025": "func NDigitFibonacciNumber(n int) int {\n    a := []int{1}\n    b := []int{1}\n    i := 2\n    for len(b) < n {\n        carry := 0\n        c := make([]int, len(b))\n        copy(c, b)\n        for j := 0; j < len(b); j++ {\n            if j < len(a) {\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        }\n        if carry != 0 {\n            b = append(b, carry)\n        }\n        a = make([]int, len(c))\n        copy(a, c)\n        i = i + 1\n    }\n    return i\n}",
        "Euler026": "func ReciprocalCycles(n int) int {\n    result := 0\n    maxLength := 0\n    for i := 1; i < n; i++ {\n        remainders := []int{}\n        remainder := 1\n        for remainder != 0 && !slices.Contains(remainders, remainder) {\n            remainders = append(remainders, remainder)\n            remainder = (remainder * 10) % i\n        }\n        length := 0\n        if remainder != 0 {\n            length = len(remainders) - slices.Index(remainders, remainder)\n        }\n        if length > maxLength {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}",
        "Euler027": "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc QuadraticPrimes(n int) int {\n    maxPrimes := 0\n    result := 0\n    for a := -n + 1; a < n; a += 2 {\n        for b := -n + 1; b < n; b += 2 {\n            x := 0\n            for {\n                if x*x+a*x+b < 2 {\n                    break\n                }\n                if !IsPrime(x*x+a*x+b) {\n                    break\n                }\n                x++\n            }\n            if x > maxPrimes {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
        "Euler028": "func NumberSpiralDiagonals(n int) int {\n    result := 1\n    for i := 3; i <= n; i += 2 {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
        "Euler029": "func DistinctPowers(n int) int {\n    result := 0\n    xs := map[string]bool{}\n    for i := 2; i <= n; i++ {\n        primes := []int{2, 3, 5, 7}\n        powers := []int{0, 0, 0, 0}\n        num := i\n        for j := 0; j < len(primes); j++ {\n            for num % primes[j] == 0 {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if num != 1 {\n            result += n - 1\n            continue\n        }\n        for j := 2; j <= n; j++ {\n            pstr := fmt.Sprintf(\"%d-%d-%d-%d\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j)\n            xs[pstr] = true\n        }\n    }\n    result += len(xs)\n    return result\n}",
        "Euler030": "func DigitNthPowers(n int) int {\n    result := 0\n    for i := 2; i < 4 * int(math.Pow(10, float64(n))); i++ {\n        digitsSum := 0\n        for _, digit := range strconv.Itoa(i) {\n            digitInt, _ := strconv.Atoi(string(digit))\n            digitsSum += int(math.Pow(float64(digitInt), float64(n)))\n        }\n        if i == digitsSum {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler031": "func CoinSums(n int) int {\n    coins := []int{1, 2, 5, 10, 20, 50, 100, 200}\n    ways := make([]int, n + 1)\n    ways[0] = 1\n    for _, coin := range coins {\n        for i := coin; i <= n; i++ {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
        "Euler032": "func PandigitalProducts(n int) int {\n    products := map[int]bool{}\n    s := \"\"\n    for i := 1; i <= n; i++ {\n        s += strconv.Itoa(i)\n    }\n    for a := 1; a < 100; a++ {\n        for b := 1; b < 10000; b++ {\n            c := a * b\n            chars := []rune(strconv.Itoa(a) + strconv.Itoa(b) + strconv.Itoa(c))\n            slices.Sort(chars)\n            if string(chars) == s {\n                products[c] = true\n            }\n        }\n    }\n    result := 0\n    for product := range products {\n        result += product\n    }\n    return result\n}",
        "Euler033": "func DigitCancelingFractions(m int) int {\n    numer := 1\n    denom := 1\n    for d := 10; d < m; d++ {\n        for n := 10; n < d; n++ {\n            n0 := n % 10\n            n1 := n / 10\n            d0 := d % 10\n            d1 := d / 10\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    a := numer\n    b := denom\n    for b != 0 {\n        temp := b\n        b = a % b\n        a = temp\n    }\n    return denom / a\n}",
        "Euler034": "func DigitFactorials(n int) int {\n    result := 0\n    for i := 3; i < n; i++ {\n        factSum := 0\n        for _, digit := range strconv.Itoa(i) {\n            fact := 1\n            for j := 1; j <= int(digit - '0'); j++ {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if i == factSum {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler035": "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc CircularPrimes(n int) int {\n    count := 0\n    for i := 2; i < n; i++ {\n        if IsPrime(i) {\n            rotations := map[int]bool{}\n            si := strconv.Itoa(i)\n            for j := 0; j < len(si); j++ {\n                x, _ := strconv.Atoi(si[j:] + si[:j])\n                rotations[x] = true\n            }\n            flag := true\n            for x := range rotations {\n                if !IsPrime(x) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                count++\n            }\n        }\n    }\n    return count\n}",
        "Euler036": "func IsPalindrome(s string) bool {\n    for i := 0; i < len(s) / 2; i++ {\n        if s[i] != s[len(s) - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc DoubleBasePalindromes(n int) int {\n    result := 0\n    for i := 1; i < n; i++ {\n        strI := strconv.Itoa(i)\n        binI := strconv.FormatInt(int64(i), 2)\n        if IsPalindrome(strI) && IsPalindrome(binI) {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler037": "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TruncatablePrimes(n int) int {\n    result := 0\n    for i := 10; i < n; i++ {\n        if IsPrime(i) {\n            si := strconv.Itoa(i)\n            flag := true\n            for j := 1; j < len(si); j++ {\n                p1, _ := strconv.Atoi(si[j:])\n                p2, _ := strconv.Atoi(si[:len(si) - j])\n                if !IsPrime(p1) || !IsPrime(p2) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                result += i\n            }\n        }\n    }\n    return result\n}",
        "Euler038": "func PandigitalMultiples(n int) int {\n    result := -1\n    for i := 2; i <= n; i++ {\n        cprod := \"\"\n        for j := 1; j < 10; j++ {\n            cprod += strconv.Itoa(i * j)\n            if len(cprod) == 9 {\n                chars := strings.Split(cprod, \"\")\n                sort.Strings(chars)\n                if strings.Join(chars, \"\") == \"123456789\" {\n                    cprodInt, _ := strconv.Atoi(cprod)\n                    result = max(result, cprodInt)\n                    break\n                }\n            } else if len(cprod) > 9 {\n                break\n            }\n        }\n    }\n    return result\n}",
        "Euler039": "func IntegerRightTriangles(n int) int {\n    maxSol := 0\n    result := 0\n    for p := 3; p <= n; p++ {\n        sol := 0\n        for a := 1; a < p / 2; a++ {\n            for b := a; b < p / 2; b++ {\n                c := p - a - b\n                if a * a + b * b == c * c {\n                    sol++\n                }\n            }\n        }\n        if sol > maxSol {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
        "Euler040": "func ChampernowneConstant(b int) int {\n    s := \"\"\n    for i := 1; i < int(math.Pow(float64(b), 6)); i++ {\n        s += strconv.Itoa(i)\n    }\n    result := 1\n    for i := 0; i < 7; i++ {\n        n, _ := strconv.Atoi(string(s[int(math.Pow(float64(b), float64(i))) - 1]))\n        result *= n\n    }\n    return result\n}",
        "Euler041": "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc PandigitalPrime(n int) int {\n    for i := n - 1; i > 0; i-- {\n        if IsPrime(i) {\n            si := strconv.Itoa(i)\n            length := len(si)\n            flag := true\n            for j := 1; j <= length; j++ {\n                if !strings.Contains(si, strconv.Itoa(j)) {\n                    flag = false\n                    break\n                }\n            }\n            if flag {\n                return i\n            }\n        }\n    }\n    return -1\n}",
        "Euler042": "func CodedTriangleNumbers(words []string) int {\n    result := 0\n    for _, word := range words {\n        value := 0\n        for _, c := range word {\n            value += int(c) - 64\n        }\n        n := int(math.Sqrt(float64(value * 2)))\n        if n * (n + 1) == value * 2 {\n            result++\n        }\n    }\n    return result\n}",
        "Euler043": "func GenPermutations(s string) []string {\n    if len(s) <= 1 {\n        return []string{s}\n    }\n    result := []string{}\n    for _, perm := range GenPermutations(s[1:]) {\n        for i := 0; i < len(s); i++ {\n            result = append(result, perm[:i] + string(s[0]) + perm[i:])\n        }\n    }\n    return result\n}\n\nfunc SubStringDivisibility(n int) int {\n    result := 0\n    primes := []int{2, 3, 5, 7, 11, 13, 17}\n    s := \"\"\n    for i := 0; i <= n; i++ {\n        s += strconv.Itoa(i)\n    }\n    for _, i := range GenPermutations(s) {\n        flag := true\n        for j := 1; j < n - 1; j++ {\n            if n, _ := strconv.Atoi(i[j:j + 3]); n % primes[j - 1] != 0 {\n                flag = false\n                break\n            }\n        }\n        if flag {\n            s0, _ := strconv.Atoi(i)\n            result += s0\n        }\n    }\n    return result\n}",
        "Euler044": "func PentagonNumbers(n int) int {\n    pentagon := map[int]bool{}\n    for i := 1; i < n; i++ {\n        pentagon[i * (3 * i - 1) / 2] = true\n    }\n    result := -1\n    for j := range pentagon {\n        for k := range pentagon {\n            if pentagon[j + k] && pentagon[k - j] {\n                if result == -1 || k - j < result {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
        "Euler045": "func TriangularPentagonalAndHexagonal(n int) int {\n    ps := map[int]bool{}\n    i := 1\n    c := int(0.5 * float64(i) * (3 * float64(i) - 1))\n    for c < n {\n        i++\n        ps[c] = true\n        c = int(0.5 * float64(i) * (3 * float64(i) - 1))\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    result := -1\n    for c < n {\n        i++\n        if ps[c] {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
        "Euler046": "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc GoldbachsOtherConjecture(n int) int {\n    result := -1\n    for i := 9999; i > n; i -= 2 {\n        upper := int(math.Sqrt(float64(i / 2)))\n        flag := false\n        for j := 0; j <= upper; j++ {\n            if IsPrime(i - 2 * j * j) {\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            result = i\n        }\n    }\n    return result\n}",
        "Euler047": "func PrimeFactors(n int) int {\n    num := n\n    factors := []int{}\n    i := 2\n    for i * i <= num {\n        if num % i != 0 {\n            i++\n        } else {\n            num /= i\n            factors = append(factors, i)\n        }\n    }\n    if num > 1 {\n        factors = append(factors, num)\n    }\n    s := map[int]bool{}\n    for _, v := range factors {\n        s[v] = true\n    }\n    return len(s)\n}\n\nfunc DistinctPrimesFactors(n int) int {\n    for i := n; i < 1000000; i++ {\n        if PrimeFactors(i) == 4 && PrimeFactors(i + 1) == 4 && PrimeFactors(i + 2) == 4 && PrimeFactors(i + 3) == 4 {\n            return i\n        }\n    }\n    return -1\n}",
        "Euler048": "func SelfPowers(n int) string {\n    digits := [10]int{}\n    for i := 1; i <= n; i++ {\n        tempDigits := [10]int{}\n        tempDigits[0] = 1\n        for j := 0; j < i; j++ {\n            carry := 0\n            for k := 0; k < 10; k++ {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for j := 0; j < 10; j++ {\n            digits[j] += tempDigits[j]\n            if digits[j] >= 10 {\n                digits[j] -= 10\n                if j < 9 {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    result := \"\"\n    for i := 9; i >= 0; i-- {\n        result += strconv.Itoa(digits[i])\n    }\n    return result\n}",
        "Euler049": "func IsPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    if n == 2 {\n        return true\n    }\n    if n % 2 == 0 {\n        return false\n    }\n    for i := 3; i <= int(math.Sqrt(float64(n))); i += 2 {\n        if n % i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc GenPermutations(s string) []string {\n    if len(s) <= 1 {\n        return []string{s}\n    }\n    result := []string{}\n    for _, perm := range GenPermutations(s[1:]) {\n        for i := 0; i < len(s); i++ {\n            result = append(result, perm[:i] + string(s[0]) + perm[i:])\n        }\n    }\n    return result\n}\n\nfunc PrimePermutations(n int) string {\n    for i := n; i > 999; i-- {\n        if IsPrime(i) {\n            permutations := GenPermutations(strconv.Itoa(i))\n            candidates := map[int]bool{}\n            for _, j := range permutations {\n                candidate, _ := strconv.Atoi(j)\n                if candidate > i && IsPrime(candidate) {\n                    candidates[candidate] = true\n                }\n            }\n            for m := range candidates {\n                if candidates[m + (m - i)] {\n                    return strconv.Itoa(i) + strconv.Itoa(m) + strconv.Itoa(m + (m - i))\n                }\n            }\n        }\n    }\n    return \"\"\n}",
        "Euler050": "func ConsecutivePrimeSum(limit int) int {\n    sieve := make([]bool, limit)\n    for i := range sieve {\n        sieve[i] = true\n    }\n    primes := []int{}\n    for i := 2; i < limit; i++ {\n        if sieve[i] {\n            primes = append(primes, i)\n            for j := i * 2; j < limit; j += i {\n                sieve[j] = false\n            }\n        }\n    }\n    maxLength := 0\n    maxPrime := 0\n    for i := 0; i < len(primes); i++ {\n        for j := i + maxLength; j < len(primes); j++ {\n            s := 0\n            for k := i; k < j; k++ {\n                s += primes[k]\n            }\n            if s >= limit {\n                break\n            }\n            if sieve[s] && j - i > maxLength {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
    },
    "java": {
        "Euler001": "class Global {\n    public static int multiplesOf3And5(int n) {\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 3 == 0 || i % 5 == 0) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler002": "class Global {\n    public static int evenFibonacciNumbers(int n) {\n        int result = 0;\n        int a = 1;\n        int b = 2;\n        while (a < n) {\n            if (a % 2 == 0) {\n                result += a;\n            }\n            int tmp = a;\n            a = b;\n            b = tmp + b;\n        }\n        return result;\n    }\n}",
        "Euler003": "class Global {\n    public static int largestPrimeFactor(int n) {\n        int result = n;\n        int i = 2;\n        while (i * i <= result) {\n            if (result % i != 0) {\n                i += 1;\n            } else {\n                result /= i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler004": "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int largestPalindromeProduct(int n) {\n        int result = 0;\n        for (int i = 100; i < 1000; i++) {\n            for (int j = i; j < 1000; j++) {\n                int prod = i * j;\n                if (isPalindrome(Integer.toString(prod)) && prod > result && prod < n) {\n                    result = prod;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler005": "class Global {\n    public static int smallestMultiple(int n) {\n        int result = 1;\n        for (int i = 1; i <= n; i++) {\n            if (result % i != 0) {\n                for (int j = 1; j <= n; j++) {\n                    if ((result * j) % i == 0) {\n                        result *= j;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler006": "class Global {\n    public static int sumSquareDifference(int n) {\n        int sqrSum = 0;\n        int numSum = 0;\n        for (int i = 1; i <= n; i++) {\n            sqrSum += i * i;\n            numSum += i;\n        }\n        return numSum * numSum - sqrSum;\n    }\n}",
        "Euler007": "class Global {\n    public static int nthPrime(int n) {\n        List<Integer> primes = new ArrayList<>(Arrays.asList(2));\n        int i = 3;\n        while (primes.size() < n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        return primes.get(primes.size() - 1);\n    }\n}",
        "Euler008": "class Global {\n    public static int largestProductInASeries(String s, int k) {\n        int result = 0;\n        for (int i = 0; i < s.length() - k; i++) {\n            int product = 1;\n            for (int j = 0; j < k; j++) {\n                product *= s.charAt(i + j) - '0';\n            }\n            result = Math.max(result, product);\n        }\n        return result;\n    }\n}",
        "Euler009": "class Global {\n    public static int specialPythagoreanTriplet(int n) {\n        for (int a = 1; a < n; a++) {\n            for (int b = a; b < n; b++) {\n                int c = n - a - b;\n                if (a * a + b * b == c * c) {\n                    return a * b * c;\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "Euler010": "class Global {\n    public static int summationOfPrimes(int n) {\n        List<Integer> primes = new ArrayList<Integer>();\n        primes.add(2);\n        int i = 3;\n        while (i <= n) {\n            for (int p : primes) {\n                if (i % p == 0) {\n                    break;\n                }\n                if (p * p > i) {\n                    primes.add(i);\n                    break;\n                }\n            }\n            i += 2;\n        }\n        int result = 0;\n        for (int prime : primes) {\n            result += prime;\n        }\n        return result;\n    }\n}",
        "Euler011": "class Global {\n    public static int largestProductInAGrid(List<List<Integer>> grid) {\n        int result = 0;\n        for (int i = 0; i < grid.size() - 3; i++) {\n            for (int j = 0; j < grid.get(i).size() - 3; j++) {\n                int p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n                for (int k = 0; k < 4; k++) {\n                    p1 *= grid.get(i + k).get(j);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p2 *= grid.get(i).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p3 *= grid.get(i + k).get(j + k);\n                }\n                for (int k = 0; k < 4; k++) {\n                    p4 *= grid.get(i + k).get(j + 3 - k);\n                }\n                result = Collections.max(Arrays.asList(result, p1, p2, p3, p4));\n            }\n        }\n        return result;\n    }\n}",
        "Euler012": "class Global {\n    public static int highlyDivisibleTriangularNumber(int n) {\n        for (int i = 1; i < 100000000; i++) {\n            int result = i * (i + 1) / 2;\n            int count = 0;\n            for (int j = 1; j <= (int)Math.sqrt(result); j++) {\n                if (result % j == 0) {\n                    count += 2;\n                }\n                if (j * j == result) {\n                    count -= 1;\n                }\n            }\n            if (count > n) {\n                return result;\n            }\n        }\n        return -1;\n    }\n}",
        "Euler013": "class Global {\n    public static String largeSum(List<String> numbers) {\n        int[] digits = new int[60];\n        for (int i = 0; i < 50; i++) {\n            int tmp = 0;\n            for (String num : numbers) {\n                tmp += num.charAt(49 - i) - '0';\n            }\n            for (int j = i; j < 60; j++) {\n                digits[j] += tmp % 10;\n                if (digits[j] >= 10) {\n                    digits[j + 1] += digits[j] / 10;\n                    digits[j] %= 10;\n                }\n                tmp /= 10;\n                if (tmp == 0) {\n                    break;\n                }\n            }\n        }\n        for (int i = 59; i >= 0; i--) {\n            if (digits[i] != 0) {\n                StringBuilder result = new StringBuilder();\n                for (int j = i; j > i - 10; j--) {\n                    result.append(digits[j]);\n                }\n                return result.toString();\n            }\n        }\n        return \"\";\n    }\n}",
        "Euler014": "class Global {\n    public static int longestCollatzSequence(int n) {\n        int longest = 0;\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            int chain = 1;\n            int num = i;\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                } else {\n                    num = 3 * num + 1;\n                }\n                chain++;\n            }\n            if (chain > longest) {\n                longest = chain;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler015": "class Global {\n    public static int latticePaths(int m, int n) {\n        int[][] grid = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            grid[i][0] = 1;\n        }\n        for (int j = 0; j <= n; j++) {\n            grid[0][j] = 1;\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            }\n        }\n        return grid[m][n];\n    }\n}",
        "Euler016": "class Global {\n    public static int powerDigitSum(int n) {\n        List<Integer> digits = new ArrayList<>(List.of(2));\n        for (int i = 1; i < n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                int temp = digits.get(j) * 2 + carry;\n                digits.set(j, temp % 10);\n                carry = temp / 10;\n            }\n            if (carry != 0) {\n                digits.add(carry);\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
        "Euler017": "class Global {\n    public static String numberToWords(int n) {\n        String[] ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n        String[] teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};\n        String[] tens = {\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n        if (n == 1000) {\n            return \"one thousand\";\n        } else if (n >= 100) {\n            if (n % 100 == 0) {\n                return ones[n / 100] + \" hundred\";\n            } else {\n                return ones[n / 100] + \" hundred and \" + numberToWords(n % 100);\n            }\n        } else if (n >= 20) {\n            String suf = \"\";\n            if (n % 10 != 0) {\n                suf = \" \" + ones[n % 10];\n            }\n            return tens[n / 10] + suf;\n        } else if (n >= 10) {\n            return teens[n - 10];\n        } else {\n            return ones[n];\n        }\n    }\n}",
        "Euler018": "class Global {\n    public static int maximumPathSumI(List<List<Integer>> triangle) {\n        List<Integer> curr = new ArrayList<>(triangle.get(triangle.size() - 1));\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            List<Integer> next = new ArrayList<>(triangle.get(i));\n            for (int j = 0; j < next.size(); j++) {\n                next.set(j, next.get(j) + Math.max(curr.get(j), curr.get(j + 1)));\n            }\n            curr = next;\n        }\n        return curr.get(0);\n    }\n}",
        "Euler019": "class Global {\n    public static int countingSundays(int y1, int y2) {\n        int day = 0;\n        int count = 0;\n        for (int year = 1900; year <= y2; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (year >= y1 && day % 7 == 6) {\n                    count++;\n                }\n                if (month == 4 || month == 6 || month == 9 || month == 11) {\n                    day += 30;\n                } else if (month == 2) {\n                    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                        day += 29;\n                    } else {\n                        day += 28;\n                    }\n                } else {\n                    day += 31;\n                }\n            }\n        }\n        return count;\n    }\n}",
        "Euler020": "class Global {\n    public static int factorialDigitSum(int n) {\n        List<Integer> digits = new ArrayList<Integer>();\n        digits.add(1);\n        for (int i = 1; i <= n; i++) {\n            int carry = 0;\n            for (int j = 0; j < digits.size(); j++) {\n                digits.set(j, digits.get(j) * i + carry);\n                carry = digits.get(j) / 10;\n                digits.set(j, digits.get(j) % 10);\n            }\n            while (carry != 0) {\n                digits.add(carry % 10);\n                carry /= 10;\n            }\n        }\n        int result = 0;\n        for (int digit : digits) {\n            result += digit;\n        }\n        return result;\n    }\n}",
        "Euler021": "class Global {\n    public static int d(int n) {\n        int result = 1;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                result += i;\n                if (i != n / i) {\n                    result += n / i;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static int amicableNumbers(int n) {\n        int result = 0;\n        for (int a = 2; a < n; a++) {\n            int b = d(a);\n            if (a != b && a == d(b)) {\n                result += a;\n            }\n        }\n        return result;\n    }\n}",
        "Euler022": "class Global {\n    public static int namesScores(List<String> names, List<String> queries) {\n        List<String> sNames = new ArrayList<>(names);\n        Collections.sort(sNames);\n        int result = 0;\n        for (int i = 0; i < sNames.size(); i++) {\n            int x = 0;\n            for (int j = 0; j < sNames.get(i).length(); j++) {\n                x += sNames.get(i).charAt(j) - 64;\n            }\n            if (queries.contains(sNames.get(i))) {\n                result += x * (i + 1);\n            }\n        }\n        return result;\n    }\n}",
        "Euler023": "class Global {\n    public static boolean isAbundant(int n) {\n        if (n < 12) {\n            return false;\n        }\n        int sumDivisors = 1;\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                sumDivisors += i;\n                if (i != n / i) {\n                    sumDivisors += n / i;\n                }\n            }\n        }\n        return sumDivisors > n;\n    }\n\n    public static int nonAbundantSums(int n) {\n        List<Integer> abundants = new ArrayList<>();\n        for (int i = 12; i < n; i++) {\n            if (isAbundant(i)) {\n                abundants.add(i);\n            }\n        }\n        Set<Integer> abundantSums = new HashSet<>();\n        for (int i : abundants) {\n            for (int j : abundants) {\n                abundantSums.add(i + j);\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (!abundantSums.contains(i)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler024": "class Global {\n    public static String lexicographicPermutations(int n) {\n        String result = \"\";\n        List<Integer> digits = new ArrayList<>(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));\n        int x = n - 1;\n        for (int i = 10; i > 0; i--) {\n            int fact = 1;\n            for (int j = 1; j < i; j++) {\n                fact *= j;\n            }\n            int idx = x / fact;\n            result += digits.get(idx);\n            digits.remove(idx);\n            x -= idx * fact;\n        }\n        return result;\n    }\n}",
        "Euler025": "class Global {\n    public static int nDigitFibonacciNumber(int n) {\n        List<Integer> a = new ArrayList<Integer>(Arrays.asList(1));\n        List<Integer> b = new ArrayList<Integer>(Arrays.asList(1));\n        int i = 2;\n        while (b.size() < n) {\n            int carry = 0;\n            List<Integer> c = new ArrayList<Integer>(b);\n            for (int j = 0; j < b.size(); j++) {\n                if (j < a.size()) {\n                    b.set(j, a.get(j) + b.get(j) + carry);\n                } else {\n                    b.set(j, b.get(j) + carry);\n                }\n                carry = b.get(j) / 10;\n                b.set(j, b.get(j) % 10);\n            }\n            if (carry != 0) {\n                b.add(carry);\n            }\n            a = new ArrayList<Integer>(c);\n            i = i + 1;\n        }\n        return i;\n    }\n}",
        "Euler026": "class Global {\n    public static int reciprocalCycles(int n) {\n        int result = 0;\n        int maxLength = 0;\n        for (int i = 1; i < n; i++) {\n            List<Integer> remainders = new ArrayList<Integer>();\n            int remainder = 1;\n            while (remainder != 0 && !remainders.contains(remainder)) {\n                remainders.add(remainder);\n                remainder = (remainder * 10) % i;\n            }\n            int length = 0;\n            if (remainder != 0) {\n                length = remainders.size() - remainders.indexOf(remainder);\n            }\n            if (length > maxLength) {\n                maxLength = length;\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler027": "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int quadraticPrimes(int n) {\n        int maxPrimes = 0;\n        int result = 0;\n        for (int a = -n + 1; a < n; a += 2) {\n            for (int b = -n + 1; b < n; b += 2) {\n                int x = 0;\n                while (true) {\n                    if (x * x + a * x + b < 2) {\n                        break;\n                    }\n                    if (!isPrime(x * x + a * x + b)) {\n                        break;\n                    }\n                    x++;\n                }\n                if (x > maxPrimes) {\n                    maxPrimes = x;\n                    result = a * b;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler028": "class Global {\n    public static int numberSpiralDiagonals(int n) {\n        int result = 1;\n        for (int i = 3; i <= n; i += 2) {\n            result += 4 * i * i - 6 * i + 6;\n        }\n        return result;\n    }\n}",
        "Euler029": "class Global {\n    public static int distinctPowers(int n) {\n        int result = 0;\n        HashSet<String> xs = new HashSet<String>();\n        for (int i = 2; i <= n; i++) {\n            List<Integer> primes = new ArrayList<Integer>(Arrays.asList(2, 3, 5, 7));\n            List<Integer> powers = new ArrayList<Integer>(Arrays.asList(0, 0, 0, 0));\n            int num = i;\n            for (int j = 0; j < primes.size(); j++) {\n                while (num % primes.get(j) == 0) {\n                    num /= primes.get(j);\n                    powers.set(j, powers.get(j) + 1);\n                }\n            }\n            if (num != 1) {\n                result += n - 1;\n                continue;\n            }\n            for (int j = 2; j <= n; j++) {\n                String pstr = String.format(\"%d-%d-%d-%d\", powers.get(0) * j, powers.get(1) * j, powers.get(2) * j, powers.get(3) * j);\n                xs.add(pstr);\n            }\n        }\n        result += xs.size();\n        return result;\n    }\n}",
        "Euler030": "class Global {\n    public static int digitNthPowers(int n) {\n        int result = 0;\n        for (int i = 2; i < 4 * Math.pow(10, n); i++) {\n            int digitsSum = 0;\n            for (char digit : String.valueOf(i).toCharArray()) {\n                digitsSum += Math.pow(digit - '0', n);\n            }\n            if (i == digitsSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler031": "class Global {\n    public static int coinSums(int n) {\n        int[] coins = {1, 2, 5, 10, 20, 50, 100, 200};\n        int[] ways = new int[n + 1];\n        ways[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= n; i++) {\n                ways[i] += ways[i - coin];\n            }\n        }\n        return ways[n];\n    }\n}",
        "Euler032": "class Global {\n    public static int pandigitalProducts(int n) {\n        Set<Integer> products = new HashSet<>();\n        String s = \"\";\n        for (int i = 1; i <= n; i++) {\n            s += i;\n        }\n        for (int a = 1; a < 100; a++) {\n            for (int b = 1; b < 10000; b++) {\n                int c = a * b;\n                char[] chars = (Integer.toString(a) + Integer.toString(b) + Integer.toString(c)).toCharArray();\n                Arrays.sort(chars);\n                if (new String(chars).equals(s)) {\n                    products.add(c);\n                }\n            }\n        }\n        int result = 0;\n        for (int product : products) {\n            result += product;\n        }\n        return result;\n    }\n}",
        "Euler033": "class Global {\n    public static int digitCancelingFractions(int m) {\n        int numer = 1;\n        int denom = 1;\n        for (int d = 10; d < m; d++) {\n            for (int n = 10; n < d; n++) {\n                int n0 = n % 10;\n                int n1 = n / 10;\n                int d0 = d % 10;\n                int d1 = d / 10;\n                if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                    numer *= n;\n                    denom *= d;\n                }\n            }\n        }\n        int a = numer;\n        int b = denom;\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return denom / a;\n    }\n}",
        "Euler034": "class Global {\n    public static int digitFactorials(int n) {\n        int result = 0;\n        for (int i = 3; i < n; i++) {\n            int factSum = 0;\n            for (char digit : Integer.toString(i).toCharArray()) {\n                int fact = 1;\n                for (int j = 1; j <= digit - '0'; j++) {\n                    fact *= j;\n                }\n                factSum += fact;\n            }\n            if (i == factSum) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler035": "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int circularPrimes(int n) {\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime(i)) {\n                HashSet<Integer> rotations = new HashSet<Integer>();\n                String si = Integer.toString(i);\n                for (int j = 0; j < si.length(); j++) {\n                    rotations.add(Integer.parseInt(si.substring(j) + si.substring(0, j)));\n                }\n                boolean flag = true;\n                for (int x : rotations) {\n                    if (!isPrime(x)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
        "Euler036": "class Global {\n    public static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int doubleBasePalindromes(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++) {\n            String strI = Integer.toString(i);\n            String binI = Integer.toBinaryString(i);\n            if (isPalindrome(strI) && isPalindrome(binI)) {\n                result += i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler037": "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int truncatablePrimes(int n) {\n        int result = 0;\n        for (int i = 10; i < n; i++) {\n            if (isPrime(i)) {\n                String si = String.valueOf(i);\n                boolean flag = true;\n                for (int j = 1; j < si.length(); j++) {\n                    int p1 = Integer.parseInt(si.substring(j));\n                    int p2 = Integer.parseInt(si.substring(0, si.length() - j));\n                    if (!isPrime(p1) || !isPrime(p2)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result += i;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler038": "class Global {\n    public static int pandigitalMultiples(int n) {\n        int result = -1;\n        for (int i = 2; i <= n; i++) {\n            String cprod = \"\";\n            for (int j = 1; j < 10; j++) {\n                cprod += Integer.toString(i * j);\n                if (cprod.length() == 9) {\n                    char[] chars = cprod.toCharArray();\n                    Arrays.sort(chars);\n                    if (new String(chars).equals(\"123456789\")) {\n                        result = Math.max(result, Integer.parseInt(cprod));\n                        break;\n                    }\n                } else if (cprod.length() > 9) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler039": "class Global {\n    public static int integerRightTriangles(int n) {\n        int maxSol = 0;\n        int result = 0;\n        for (int p = 3; p <= n; p++) {\n            int sol = 0;\n            for (int a = 1; a < p / 2; a++) {\n                for (int b = a; b < p / 2; b++) {\n                    int c = p - a - b;\n                    if (a * a + b * b == c * c) {\n                        sol++;\n                    }\n                }\n            }\n            if (sol > maxSol) {\n                maxSol = sol;\n                result = p;\n            }\n        }\n        return result;\n    }\n}",
        "Euler040": "class Global {\n    public static int champernowneConstant(int b) {\n        String s = \"\";\n        for (int i = 1; i < Math.pow(b, 6); i++) {\n            s += Integer.toString(i);\n        }\n        int result = 1;\n        for (int i = 0; i < 7; i++) {\n            result *= s.charAt((int)Math.pow(b, i) - 1) - '0';\n        }\n        return result;\n    }\n}",
        "Euler041": "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int pandigitalPrime(int n) {\n        for (int i = n - 1; i > 0; i--) {\n            if (isPrime(i)) {\n                String si = Integer.toString(i);\n                int length = si.length();\n                boolean flag = true;\n                for (int j = 1; j <= length; j++) {\n                    if (si.indexOf(Integer.toString(j)) == -1) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "Euler042": "class Global {\n    public static int codedTriangleNumbers(List<String> words) {\n        int result = 0;\n        for (String word : words) {\n            int value = 0;\n            for (char c : word.toCharArray()) {\n                value += c - 64;\n            }\n            int n = (int)Math.sqrt(value * 2);\n            if (n * (n + 1) == value * 2) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
        "Euler043": "class Global {\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return List.of(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.charAt(0) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static int subStringDivisibility(int n) {\n        int result = 0;\n        List<Integer> primes = List.of(2, 3, 5, 7, 11, 13, 17);\n        String s = \"\";\n        for (int i = 0; i <= n; i++) {\n            s += i;\n        }\n        for (String i : genPermutations(s)) {\n            boolean flag = true;\n            for (int j = 1; j < n - 1; j++) {\n                if (Integer.parseInt(i.substring(j, j + 3)) % primes.get(j - 1) != 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += Integer.parseInt(i);\n            }\n        }\n        return result;\n    }\n}",
        "Euler044": "class Global {\n    public static int pentagonNumbers(int n) {\n        Set<Integer> pentagon = new HashSet<>();\n        for (int i = 1; i < n; i++) {\n            pentagon.add(i * (3 * i - 1) / 2);\n        }\n        int result = -1;\n        for (int j : pentagon) {\n            for (int k : pentagon) {\n                if (pentagon.contains(j + k) && pentagon.contains(k - j)) {\n                    if (result == -1 || k - j < result) {\n                        result = k - j;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
        "Euler045": "class Global {\n    public static int triangularPentagonalAndHexagonal(int n) {\n        HashSet<Integer> ps = new HashSet<Integer>();\n        int i = 1;\n        int c = (int)(0.5 * i * (3 * i - 1));\n        while (c < n) {\n            i++;\n            ps.add(c);\n            c = (int)(0.5 * i * (3 * i - 1));\n        }\n        i = 1;\n        c = i * (2 * i - 1);\n        int result = -1;\n        while (c < n) {\n            i++;\n            if (ps.contains(c)) {\n                result = c;\n            }\n            c = i * (2 * i - 1);\n        }\n        return result;\n    }\n}",
        "Euler046": "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int goldbachsOtherConjecture(int n) {\n        int result = -1;\n        for (int i = 9999; i > n; i -= 2) {\n            int upper = (int)Math.sqrt(i / 2);\n            boolean flag = false;\n            for (int j = 0; j <= upper; j++) {\n                if (isPrime(i - 2 * j * j)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) {\n                result = i;\n            }\n        }\n        return result;\n    }\n}",
        "Euler047": "class Global {\n    public static int primeFactors(int n) {\n        int num = n;\n        List<Integer> factors = new ArrayList<Integer>();\n        int i = 2;\n        while (i * i <= num) {\n            if (num % i != 0) {\n                i++;\n            } else {\n                num /= i;\n                factors.add(i);\n            }\n        }\n        if (num > 1) {\n            factors.add(num);\n        }\n        return new HashSet<Integer>(factors).size();\n    }\n\n    public static int distinctPrimesFactors(int n) {\n        for (int i = n; i < 1000000; i++) {\n            if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
        "Euler048": "class Global {\n    public static String selfPowers(int n) {\n        int[] digits = new int[10];\n        for (int i = 1; i <= n; i++) {\n            int[] tempDigits = new int[10];\n            tempDigits[0] = 1;\n            for (int j = 0; j < i; j++) {\n                int carry = 0;\n                for (int k = 0; k < 10; k++) {\n                    tempDigits[k] = tempDigits[k] * i + carry;\n                    carry = tempDigits[k] / 10;\n                    tempDigits[k] %= 10;\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                digits[j] += tempDigits[j];\n                if (digits[j] >= 10) {\n                    digits[j] -= 10;\n                    if (j < 9) {\n                        digits[j + 1] += 1;\n                    }\n                }\n            }\n        }\n        String result = \"\";\n        for (int i = 9; i >= 0; i--) {\n            result += Integer.toString(digits[i]);\n        }\n        return result;\n    }\n}",
        "Euler049": "class Global {\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n == 2) {\n            return true;\n        }\n        if (n % 2 == 0) {\n            return false;\n        }\n        for (int i = 3; i <= (int)Math.sqrt(n); i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<String> genPermutations(String s) {\n        if (s.length() <= 1) {\n            return List.of(s);\n        }\n        List<String> result = new ArrayList<>();\n        for (String perm : genPermutations(s.substring(1))) {\n            for (int i = 0; i < s.length(); i++) {\n                result.add(perm.substring(0, i) + s.charAt(0) + perm.substring(i));\n            }\n        }\n        return result;\n    }\n\n    public static String primePermutations(int n) {\n        for (int i = n; i > 999; --i) {\n            if (isPrime(i)) {\n                List<String> permutations = genPermutations(String.valueOf(i));\n                Set<Integer> candidates = new HashSet<>();\n                for (String j : permutations) {\n                    int candidate = Integer.parseInt(j);\n                    if (candidate > i && isPrime(candidate)) {\n                        candidates.add(candidate);\n                    }\n                }\n                for (int m : candidates) {\n                    if (candidates.contains(m + (m - i))) {\n                        return Integer.toString(i) + Integer.toString(m) + Integer.toString(m + (m - i));\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}",
        "Euler050": "class Global {\n    public static int consecutivePrimeSum(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < limit; i++) {\n            if (sieve[i]) {\n                primes.add(i);\n                for (int j = i * 2; j < limit; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n        int maxLength = 0;\n        int maxPrime = 0;\n        for (int i = 0; i < primes.size(); i++) {\n            for (int j = i + maxLength; j < primes.size(); j++) {\n                int s = 0;\n                for (int k = i; k < j; k++) {\n                    s += primes.get(k);\n                }\n                if (s >= limit) {\n                    break;\n                }\n                if (sieve[s] && j - i > maxLength) {\n                    maxLength = j - i;\n                    maxPrime = s;\n                }\n            }\n        }\n        return maxPrime;\n    }\n}"
    },
    "javascript": {
        "Euler001": "const multiplesOf3And5 = (n) => {\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler002": "const evenFibonacciNumbers = (n) => {\n    let result = 0;\n    let a = 1;\n    let b = 2;\n    while (a < n) {\n        if (a % 2 === 0) {\n            result += a;\n        }\n        const tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    return result;\n}",
        "Euler003": "const largestPrimeFactor = (n) => {\n    let result = n;\n    let i = 2;\n    while (i * i <= result) {\n        if (result % i !== 0) {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    return result;\n}",
        "Euler004": "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i] !== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst largestPalindromeProduct = (n) => {\n    let result = 0;\n    for (let i = 100; i < 1000; i++) {\n        for (let j = i; j < 1000; j++) {\n            let prod = i * j;\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod;\n            }\n        }\n    }\n    return result;\n}",
        "Euler005": "const smallestMultiple = (n) => {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n        if (result % i !== 0) {\n            for (let j = 1; j <= n; j++) {\n                if ((result * j) % i === 0) {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
        "Euler006": "const sumSquareDifference = (n) => {\n    let sqrSum = 0;\n    let numSum = 0;\n    for (let i = 1; i <= n; i++) {\n        sqrSum += i * i;\n        numSum += i;\n    }\n    return numSum * numSum - sqrSum;\n}",
        "Euler007": "const nthPrime = (n) => {\n    const primes = [2];\n    let i = 3;\n    while (primes.length < n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    return primes[primes.length - 1];\n}",
        "Euler008": "const largestProductInASeries = (s, k) => {\n    let result = 0;\n    for (let i = 0; i < s.length - k; i++) {\n        let product = 1;\n        for (let j = 0; j < k; j++) {\n            product *= parseInt(s[i + j]);\n        }\n        result = Math.max(result, product);\n    }\n    return result;\n}",
        "Euler009": "const specialPythagoreanTriplet = (n) => {\n    for (let a = 1; a < n; a++) {\n        for (let b = a; b < n; b++) {\n            let c = n - a - b;\n            if (a * a + b * b === c * c) {\n                return a * b * c;\n            }\n        }\n    }\n    return -1;\n}",
        "Euler010": "const summationOfPrimes = (n) => {\n    const primes = [2];\n    let i = 3;\n    while (i <= n) {\n        for (let p of primes) {\n            if (i % p === 0) {\n                break;\n            }\n            if (p * p > i) {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let result = 0;\n    for (let prime of primes) {\n        result += prime;\n    }\n    return result;\n}",
        "Euler011": "const largestProductInAGrid = (grid) => {\n    let result = 0;\n    for (let i = 0; i < grid.length - 3; i++) {\n        for (let j = 0; j < grid[i].length - 3; j++) {\n            let p1 = 1, p2 = 1, p3 = 1, p4 = 1;\n            for (let k = 0; k < 4; k++) {\n                p1 *= grid[i + k][j];\n            }\n            for (let k = 0; k < 4; k++) {\n                p2 *= grid[i][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p3 *= grid[i + k][j + k];\n            }\n            for (let k = 0; k < 4; k++) {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = Math.max(result, p1, p2, p3, p4);\n        }\n    }\n    return result;\n}",
        "Euler012": "const highlyDivisibleTriangularNumber = (n) => {\n    for (let i = 1; i < 100000000; i++) {\n        let result = i * (i + 1) / 2;\n        let count = 0;\n        for (let j = 1; j <= Math.trunc(Math.sqrt(result)); j++) {\n            if (result % j === 0) {\n                count += 2;\n            }\n            if (j * j === result) {\n                count -= 1;\n            }\n        }\n        if (count > n) {\n            return result;\n        }\n    }\n    return -1;\n}",
        "Euler013": "const largeSum = (numbers) => {\n    const digits = Array(60).fill(0);\n    for (let i = 0; i < 50; i++) {\n        let tmp = 0;\n        for (let num of numbers) {\n            tmp += parseInt(num[49 - i]);\n        }\n        for (let j = i; j < 60; j++) {\n            digits[j] += tmp % 10;\n            if (digits[j] >= 10) {\n                digits[j + 1] += Math.floor(digits[j] / 10);\n                digits[j] %= 10;\n            }\n            tmp = Math.floor(tmp / 10);\n            if (tmp === 0) {\n                break;\n            }\n        }\n    }\n    for (let i = 59; i >= 0; i--) {\n        if (digits[i] !== 0) {\n            let result = '';\n            for (let j = i; j > i - 10; j--) {\n                result += digits[j];\n            }\n            return result;\n        }\n    }\n    return '';\n}",
        "Euler014": "const longestCollatzSequence = (n) => {\n    let longest = 0;\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        let chain = 1;\n        let num = i;\n        while (num !== 1) {\n            if (num % 2 === 0) {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain++;\n        }\n        if (chain > longest) {\n            longest = chain;\n            result = i;\n        }\n    }\n    return result;\n}",
        "Euler015": "const latticePaths = (m, n) => {\n    const grid = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for (let i = 0; i <= m; i++) {\n        grid[i][0] = 1;\n    }\n    for (let j = 0; j <= n; j++) {\n        grid[0][j] = 1;\n    }\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n        }\n    }\n    return grid[m][n];\n}",
        "Euler016": "const powerDigitSum = (n) => {\n    let digits = [2];\n    for (let i = 1; i < n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = Math.floor(temp / 10);\n        }\n        if (carry !== 0) {\n            digits.push(carry);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
        "Euler017": "const numberToWords = (n) => {\n    const ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    const teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    const tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if (n === 1000) {\n        return \"one thousand\";\n    } else if (n >= 100) {\n        if (n % 100 === 0) {\n            return ones[Math.floor(n / 100)] + \" hundred\";\n        } else {\n            return ones[Math.floor(n / 100)] + \" hundred and \" + numberToWords(n % 100);\n        }\n    } else if (n >= 20) {\n        let suf = \"\";\n        if (n % 10 !== 0) {\n            suf = \" \" + ones[n % 10];\n        }\n        return tens[Math.floor(n / 10)] + suf;\n    } else if (n >= 10) {\n        return teens[n - 10];\n    } else {\n        return ones[n];\n    }       \n}",
        "Euler018": "const maximumPathSumI = (triangle) => {\n    let curr = triangle[triangle.length - 1].slice();\n    for (let i = triangle.length - 2; i >= 0; i--) {\n        let next = triangle[i].slice();\n        for (let j = 0; j < next.length; j++) {\n            next[j] += Math.max(curr[j], curr[j + 1]);\n        }\n        curr = next;\n    }\n    return curr[0];\n}",
        "Euler019": "const countingSundays = (y1, y2) => {\n    let day = 0;\n    let count = 0;\n    for (let year = 1900; year <= y2; year++) {\n        for (let month = 1; month <= 12; month++) {\n            if (year >= y1 && day % 7 === 6) {\n                count++;\n            }\n            if (month === 4 || month === 6 || month === 9 || month === 11) {\n                day += 30;\n            } else if (month === 2) {\n                if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    return count;\n}",
        "Euler020": "const factorialDigitSum = (n) => {\n    let digits = [1];\n    for (let i = 1; i <= n; i++) {\n        let carry = 0;\n        for (let j = 0; j < digits.length; j++) {\n            digits[j] = digits[j] * i + carry;\n            carry = Math.floor(digits[j] / 10);\n            digits[j] %= 10;\n        }\n        while (carry !== 0) {\n            digits.push(carry % 10);\n            carry = Math.floor(carry / 10);\n        }\n    }\n    let result = 0;\n    for (let digit of digits) {\n        result += digit;\n    }\n    return result;\n}",
        "Euler021": "const d = (n) => {\n    let result = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            result += i;\n            if (i !== n / i) {\n                result += n / i;\n            }\n        }\n    }\n    return result;\n}\n\nconst amicableNumbers = (n) => {\n    let result = 0;\n    for (let a = 2; a < n; a++) {\n        let b = d(a);\n        if (a !== b && a === d(b)) {\n            result += a;\n        }\n    }\n    return result;\n}",
        "Euler022": "const namesScores = (names, queries) => {\n    let sNames = names.slice().sort();\n    let result = 0;\n    for (let i = 0; i < sNames.length; i++) {\n        let x = 0;\n        for (let j = 0; j < sNames[i].length; j++) {\n            x += sNames[i].charCodeAt(j) - 64;\n        }\n        if (queries.includes(sNames[i])) {\n            result += x * (i + 1);\n        }\n    }\n    return result;\n}",
        "Euler023": "const isAbundant = (n) => {\n    if (n < 12) {\n        return false;\n    }\n    let sumDivisors = 1;\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            sumDivisors += i;\n            if (i !== n / i) {\n                sumDivisors += n / i;\n            }\n        }\n    }\n    return sumDivisors > n;\n}\n\nconst nonAbundantSums = (n) => {\n    const abundants = [];\n    for (let i = 12; i < n; i++) {\n        if (isAbundant(i)) {\n            abundants.push(i);\n        }\n    }\n    const abundantSums = new Set();\n    for (let i of abundants) {\n        for (let j of abundants) {\n            abundantSums.add(i + j);\n        }\n    }\n    let result = 0;\n    for (let i = 0; i < n; i++) {\n        if (!abundantSums.has(i)) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler024": "const lexicographicPermutations = (n) => {\n    let result = \"\";\n    let digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let x = n - 1;\n    for (let i = 10; i > 0; i--) {\n        let fact = 1;\n        for (let j = 1; j < i; j++) {\n            fact *= j;\n        }\n        let idx = Math.floor(x / fact);\n        result += digits[idx];\n        digits.splice(idx, 1);\n        x -= idx * fact;\n    }\n    return result;\n}",
        "Euler025": "const nDigitFibonacciNumber = (n) => {\n    let a = [1];\n    let b = [1];\n    let i = 2;\n    while (b.length < n) {\n        let carry = 0;\n        let c = b.slice();\n        for (let j = 0; j < b.length; j++) {\n            if (j < a.length) {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = Math.floor(b[j] / 10);\n            b[j] = b[j] % 10;\n        }\n        if (carry) {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    return i;\n}",
        "Euler026": "const reciprocalCycles = (n) => {\n    let result = 0;\n    let maxLength = 0;\n    for (let i = 1; i < n; i++) {\n        let remainders = [];\n        let remainder = 1;\n        while (remainder !== 0 && !remainders.includes(remainder)) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let length = 0;\n        if (remainder !== 0) {\n            length = remainders.length - remainders.indexOf(remainder);\n        }\n        if (length > maxLength) {\n            maxLength = length;\n            result = i;\n        }\n    }\n    return result;\n}",
        "Euler027": "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst quadraticPrimes = (n) => {\n    let maxPrimes = 0;\n    let result = 0;\n    for (let a = -n + 1; a < n; a += 2) {\n        for (let b = -n + 1; b < n; b += 2) {\n            let x = 0;\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break;\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break;\n                }\n                x++;\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x;\n                result = a * b;\n            }\n        }\n    }\n    return result;\n}",
        "Euler028": "const numberSpiralDiagonals = (n) => {\n    let result = 1;\n    for (let i = 3; i <= n; i += 2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    return result;\n}",
        "Euler029": "const distinctPowers = (n) => {\n    let result = 0;\n    let xs = new Set();\n    for (let i = 2; i <= n; i++) {\n        let primes = [2, 3, 5, 7];\n        let powers = [0, 0, 0, 0];\n        let num = i;\n        for (let j = 0; j < primes.length; j++) {\n            while (num % primes[j] === 0) {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if (num !== 1) {\n            result += n - 1;\n            continue;\n        }\n        for (let j = 2; j <= n; j++) {\n            let pstr = `${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}`;\n            xs.add(pstr);\n        }\n    }\n    result += xs.size;\n    return result;\n}",
        "Euler030": "const digitNthPowers = (n) => {\n    let result = 0;\n    for (let i = 2; i < 4 * 10 ** n; i++) {\n        let digitsSum = 0;\n        for (const digit of i.toString()) {\n            digitsSum += parseInt(digit) ** n;\n        }\n        if (i === digitsSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler031": "const coinSums = (n) => {\n    const coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    const ways = new Array(n + 1).fill(0);\n    ways[0] = 1;\n    for (const coin of coins) {\n        for (let i = coin; i <= n; i++) {\n            ways[i] += ways[i - coin];\n        }\n    }\n    return ways[n];\n}",
        "Euler032": "const pandigitalProducts = (n) => {\n    const products = new Set();\n    let s = \"\";\n    for (let i = 1; i <= n; i++) {\n        s += i;\n    }\n    for (let a = 1; a < 100; a++) {\n        for (let b = 1; b < 10000; b++) {\n            const c = a * b;\n            let chars = (a.toString() + b.toString() + c.toString()).split(\"\");\n            chars.sort();\n            if (chars.join(\"\") === s) {\n                products.add(c);\n            }\n        }\n    }\n    let result = 0;\n    for (let product of products) {\n        result += product;\n    }\n    return result;\n}",
        "Euler033": "const digitCancelingFractions = (m) => {\n    let numer = 1;\n    let denom = 1;\n    for (let d = 10; d < m; d++) {\n        for (let n = 10; n < d; n++) {\n            let n0 = n % 10;\n            let n1 = Math.floor(n / 10);\n            let d0 = d % 10;\n            let d1 = Math.floor(d / 10);\n            if ((n1 === d0 && n0 * d === n * d1) || (n0 === d1 && n1 * d === n * d0)) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let a = numer;\n    let b = denom;\n    while (b !== 0) {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return denom / a;\n}",
        "Euler034": "const digitFactorials = (n) => {\n    let result = 0;\n    for (let i = 3; i < n; i++) {\n        let factSum = 0;\n        for (let digit of i.toString()) {\n            let fact = 1;\n            for (let j = 1; j <= parseInt(digit); j++) {\n                fact *= j;\n            }\n            factSum += fact;\n        }\n        if (i === factSum) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler035": "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst circularPrimes = (n) => {\n    let count = 0;\n    for (let i = 2; i < n; i++) {\n        if (isPrime(i)) {\n            const rotations = new Set();\n            const si = i.toString();\n            for (let j = 0; j < si.length; j++) {\n                rotations.add(parseInt(si.substring(j) + si.substring(0, j)));\n            }\n            let flag = true;\n            for (let x of rotations) {\n                if (!isPrime(x)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                count++;\n            }\n        }\n    }\n    return count;\n}",
        "Euler036": "const isPalindrome = (s) => {\n    for (let i = 0; i < s.length / 2; i++) {\n        if (s[i] !== s[s.length - i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst doubleBasePalindromes = (n) => {\n    let result = 0;\n    for (let i = 1; i < n; i++) {\n        const strI = i.toString();\n        const binI = i.toString(2);\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i;\n        }\n    }\n    return result;\n}",
        "Euler037": "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst truncatablePrimes = (n) => {\n    let result = 0;\n    for (let i = 10; i < n; i++) {\n        if (isPrime(i)) {\n            const si = i.toString();\n            let flag = true;\n            for (let j = 1; j < si.length; j++) {\n                const p1 = parseInt(si.substring(j));\n                const p2 = parseInt(si.substring(0, si.length - j));\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                result += i;\n            }\n        }\n    }\n    return result;\n}",
        "Euler038": "const pandigitalMultiples = (n) => {\n    let result = -1;\n    for (let i = 2; i <= n; i++) {\n        let cprod = '';\n        for (let j = 1; j < 10; j++) {\n            cprod += (i * j).toString();\n            if (cprod.length === 9) {\n                let chars = cprod.split('');\n                chars.sort();\n                if (chars.join('') === '123456789') {\n                    result = Math.max(result, parseInt(cprod));\n                    break;\n                }\n            } else if (cprod.length > 9) {\n                break;\n            }\n        }\n    }\n    return result;\n}",
        "Euler039": "const integerRightTriangles = (n) => {\n    let maxSol = 0;\n    let result = 0;\n    for (let p = 3; p <= n; p++) {\n        let sol = 0;\n        for (let a = 1; a < p / 2; a++) {\n            for (let b = a; b < p / 2; b++) {\n                let c = p - a - b;\n                if (a * a + b * b === c * c) {\n                    sol++;\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol;\n            result = p;\n        }\n    }\n    return result;\n}",
        "Euler040": "const champernowneConstant = (b) => {\n    let s = \"\";\n    for (let i = 1; i < Math.pow(b, 6); i++) {\n        s += i.toString();\n    }\n    let result = 1;\n    for (let i = 0; i < 7; i++) {\n        result *= parseInt(s[Math.pow(b, i) - 1]);\n    }\n    return result;\n}",
        "Euler041": "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst pandigitalPrime = (n) => {\n    for (let i = n - 1; i > 0; i--) {\n        if (isPrime(i)) {\n            let si = i.toString();\n            let length = si.length;\n            let flag = true;\n            for (let j = 1; j <= length; j++) {\n                if (!si.includes(j.toString())) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}",
        "Euler042": "const codedTriangleNumbers = (words) => {\n    let result = 0;\n    for (let word of words) {\n        let value = 0;\n        for (let c of word) {\n            value += c.charCodeAt(0) - 64;\n        }\n        let n = parseInt(Math.sqrt(value * 2));\n        if (n * (n + 1) === value * 2) {\n            result++;\n        }\n    }\n    return result;\n}",
        "Euler043": "const genPermutations = (s) => {\n    if (s.length <= 1) {\n        return [s];\n    }\n    const result = [];\n    for (const perm of genPermutations(s.slice(1))) {\n        for (let i = 0; i < s.length; ++i) {\n            result.push(perm.slice(0, i) + s[0] + perm.slice(i));\n        }\n    }\n    return result;\n}\n\nconst subStringDivisibility = (n) => {\n    let result = 0;\n    const primes = [2, 3, 5, 7, 11, 13, 17];\n    let s = \"\";\n    for (let i = 0; i <= n; i++) {\n        s += i;\n    }\n    for (const i of genPermutations(s)) {\n        let flag = true;\n        for (let j = 1; j < n - 1; j++) {\n            if (parseInt(i.substring(j, j + 3)) % primes[j - 1] !== 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            result += parseInt(i);\n        }\n    }\n    return result;\n}",
        "Euler044": "const pentagonNumbers = (n) => {\n    const pentagon = new Set();\n    for (let i = 1; i < n; i++) {\n        pentagon.add(i * (3 * i - 1) / 2);\n    }\n    let result = -1;\n    for (let j of pentagon) {\n        for (let k of pentagon) {\n            if (pentagon.has(j + k) && pentagon.has(k - j)) {\n                if (result === -1 || k - j < result) {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    return result;\n}",
        "Euler045": "const triangularPentagonalAndHexagonal = (n) => {\n    const ps = new Set();\n    let i = 1;\n    let c = 0.5 * i * (3 * i - 1);\n    while (c < n) {\n        i++;\n        ps.add(c);\n        c = 0.5 * i * (3 * i - 1);\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let result = -1;\n    while (c < n) {\n        i++;\n        if (ps.has(c)) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    return result;\n}",
        "Euler046": "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst goldbachsOtherConjecture = (n) => {\n    let result = -1;\n    for (let i = 9999; i > n; i -= 2) {\n        let upper = parseInt(Math.sqrt(i / 2));\n        let flag = false;\n        for (let j = 0; j <= upper; j++) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            result = i;\n        }\n    }\n    return result;\n}",
        "Euler047": "const primeFactors = (n) => {\n    let num = n;\n    const factors = [];\n    let i = 2;\n    while (i * i <= num) {\n        if (num % i !== 0) {\n            i++;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if (num > 1) {\n        factors.push(num);\n    }\n    return new Set(factors).size;\n}\n\nconst distinctPrimesFactors = (n) => {\n    for (let i = n; i < 1000000; i++) {\n        if (primeFactors(i) === 4 && primeFactors(i + 1) === 4 && primeFactors(i + 2) === 4 && primeFactors(i + 3) === 4) {\n            return i;\n        }\n    }\n    return -1;\n}",
        "Euler048": "const selfPowers = (n) => {\n    const digits = new Array(10).fill(0);\n    for (let i = 1; i <= n; i++) {\n        const tempDigits = new Array(10).fill(0);\n        tempDigits[0] = 1;\n        for (let j = 0; j < i; j++) {\n            let carry = 0;\n            for (let k = 0; k < 10; k++) {\n                tempDigits[k] = tempDigits[k] * i + carry;\n                carry = Math.floor(tempDigits[k] / 10);\n                tempDigits[k] %= 10;\n            }\n        }\n        for (let j = 0; j < 10; j++) {\n            digits[j] += tempDigits[j];\n            if (digits[j] >= 10) {\n                digits[j] -= 10;\n                if (j < 9) {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let result = \"\";\n    for (let i = 9; i >= 0; i--) {\n        result += digits[i].toString();\n    }\n    return result;\n}",
        "Euler049": "const isPrime = (n) => {\n    if (n < 2) {\n        return false;\n    }\n    if (n === 2) {\n        return true;\n    }\n    if (n % 2 === 0) {\n        return false;\n    }\n    for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {\n        if (n % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst genPermutations = (s) => {\n    if (s.length <= 1) {\n        return [s];\n    }\n    const result = [];\n    for (const perm of genPermutations(s.substring(1))) {\n        for (let i = 0; i < s.length; ++i) {\n            result.push(perm.substring(0, i) + s[0] + perm.substring(i));\n        }\n    }\n    return result;\n}\n\nconst primePermutations = (n) => {\n    for (let i = n; i > 999; --i) {\n        if (isPrime(i)) {\n            const permutations = genPermutations(i.toString());\n            const candidates = new Set();\n            for (const j of permutations) {\n                const candidate = parseInt(j);\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.add(candidate);\n                }\n            }\n            for (const m of candidates) {\n                if (candidates.has(m + (m - i))) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString();\n                }\n            }\n        }\n    }\n    return \"\";\n}",
        "Euler050": "const consecutivePrimeSum = (limit) => {\n    const sieve = Array(limit).fill(true);\n    const primes = [];\n    for (let i = 2; i < limit; i++) {\n        if (sieve[i]) {\n            primes.push(i);\n            for (let j = i * 2; j < limit; j += i) {\n                sieve[j] = false;\n            }\n        }\n    }\n    let maxLength = 0;\n    let maxPrime = 0;\n    for (let i = 0; i < primes.length; i++) {\n        for (let j = i + maxLength; j < primes.length; j++) {\n            let s = 0;\n            for (let k = i; k < j; k++) {\n                s += primes[k];\n            }\n            if (s >= limit) {\n                break;\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i;\n                maxPrime = s;\n            }\n        }\n    }\n    return maxPrime;\n}"
    },
    "kotlin": {
        "Euler001": "fun multiplesOf3And5(n: Int): Int {\n    var result = 0\n    for (i in 0 until n) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler002": "fun evenFibonacciNumbers(n: Int): Int {\n    var result = 0\n    var a = 1\n    var b = 2\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a\n        }\n        val tmp = a\n        a = b\n        b = tmp + b\n    }\n    return result\n}",
        "Euler003": "fun largestPrimeFactor(n: Int): Int {\n    var result = n\n    var i = 2\n    while (i * i <= result) {\n        if (result % i != 0) {\n            i += 1\n        } else {\n            result /= i\n        }\n    }\n    return result\n}",
        "Euler004": "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i] != s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun largestPalindromeProduct(n: Int): Int {\n    var result = 0\n    for (i in 100 until 1000) {\n        for (j in i until 1000) {\n            val prod = i * j\n            if (isPalindrome(prod.toString()) && prod > result && prod < n) {\n                result = prod\n            }\n        }\n    }\n    return result\n}",
        "Euler005": "fun smallestMultiple(n: Int): Int {\n    var result = 1\n    for (i in 1..n) {\n        if (result % i != 0) {\n            for (j in 1..n) {\n                if ((result * j) % i == 0) {\n                    result *= j\n                    break\n                }\n            }\n        }\n    }\n    return result\n}",
        "Euler006": "fun sumSquareDifference(n: Int): Int {\n    var sqrSum = 0\n    var numSum = 0\n    for (i in 1..n) {\n        sqrSum += i * i\n        numSum += i\n    }\n    return numSum * numSum - sqrSum\n}",
        "Euler007": "fun nthPrime(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (primes.size < n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    return primes.last()\n}",
        "Euler008": "fun largestProductInASeries(s: String, k: Int): Int {\n    var result = 0\n    for (i in 0 until s.length - k) {\n        var product = 1\n        for (j in 0 until k) {\n            product *= s[i + j].digitToInt()\n        }\n        result = maxOf(result, product)\n    }\n    return result\n}",
        "Euler009": "fun specialPythagoreanTriplet(n: Int): Int {\n    for (a in 1 until n) {\n        for (b in a until n) {\n            val c = n - a - b\n            if (a * a + b * b == c * c) {\n                return a * b * c\n            }\n        }\n    }\n    return -1\n}",
        "Euler010": "fun summationOfPrimes(n: Int): Int {\n    val primes = mutableListOf(2)\n    var i = 3\n    while (i <= n) {\n        for (p in primes) {\n            if (i % p == 0) {\n                break\n            }\n            if (p * p > i) {\n                primes.add(i)\n                break\n            }\n        }\n        i += 2\n    }\n    var result = 0\n    for (prime in primes) {\n        result += prime\n    }\n    return result\n}",
        "Euler011": "fun largestProductInAGrid(grid: List<List<Int>>): Int {\n    var result = 0\n    for (i in 0 until grid.size - 3) {\n        for (j in 0 until grid[i].size - 3) {\n            var p1 = 1\n            var p2 = 1\n            var p3 = 1\n            var p4 = 1\n            for (k in 0 until 4) {\n                p1 *= grid[i + k][j]\n            }\n            for (k in 0 until 4) {\n                p2 *= grid[i][j + k]\n            }\n            for (k in 0 until 4) {\n                p3 *= grid[i + k][j + k]\n            }\n            for (k in 0 until 4) {\n                p4 *= grid[i + k][j + 3 - k]\n            }\n            result = maxOf(result, p1, p2, p3, p4)\n        }\n    }\n    return result\n}",
        "Euler012": "fun highlyDivisibleTriangularNumber(n: Int): Int {\n    for (i in 1 until 100000000) {\n        val result = i * (i + 1) / 2\n        var count = 0\n        for (j in 1..sqrt(result.toDouble()).toInt()) {\n            if (result % j == 0) {\n                count += 2\n            }\n            if (j * j == result) {\n                count -= 1\n            }\n        }\n        if (count > n) {\n            return result\n        }\n    }\n    return -1\n}",
        "Euler013": "fun largeSum(numbers: List<String>): String {\n    val digits = Array(60) { 0 }\n    for (i in 0 until 50) {\n        var tmp = 0\n        for (num in numbers) {\n            tmp += num[49 - i] - '0'\n        }\n        for (j in i until 60) {\n            digits[j] += tmp % 10\n            if (digits[j] >= 10) {\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            }\n            tmp /= 10\n            if (tmp == 0) {\n                break\n            }\n        }\n    }\n    for (i in 59 downTo 0) {\n        if (digits[i] != 0) {\n            val result = StringBuilder()\n            for (j in i downTo i - 9) {\n                result.append(digits[j])\n            }\n            return result.toString()\n        }\n    }\n    return \"\"\n}",
        "Euler014": "fun longestCollatzSequence(n: Int): Int {\n    var longest = 0\n    var result = 0\n    for (i in 1 until n) {\n        var chain = 1\n        var num = i\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain++\n        }\n        if (chain > longest) {\n            longest = chain\n            result = i\n        }\n    }\n    return result\n}",
        "Euler015": "fun latticePaths(m: Int, n: Int): Int {\n    val grid = Array(m + 1) { IntArray(n + 1) { 0 } }\n    for (i in 0..m) {\n        grid[i][0] = 1\n    }\n    for (j in 0..n) {\n        grid[0][j] = 1\n    }\n    for (i in 1..m) {\n        for (j in 1..n) {\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        }\n    }\n    return grid[m][n]\n}",
        "Euler016": "fun powerDigitSum(n: Int): Int {\n    val digits = mutableListOf(2)\n    for (i in 1 until n) {\n        var carry = 0\n        for (j in digits.indices) {\n            var temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        }\n        if (carry != 0) {\n            digits.add(carry)\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
        "Euler017": "fun numberToWords(n: Int): String {\n    val ones = listOf(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val teens = listOf(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n    val tens = listOf(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n    if (n == 1000) {\n        return \"one thousand\"\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            return ones[n / 100] + \" hundred\"\n        } else {\n            return ones[n / 100] + \" hundred and \" + numberToWords(n % 100)\n        }\n    } else if (n >= 20) {\n        var suf = \"\"\n        if (n % 10 != 0) {\n            suf = \" \" + ones[n % 10]\n        }\n        return tens[n / 10] + suf\n    } else if (n >= 10) {\n        return teens[n - 10]\n    } else {\n        return ones[n]\n    }\n}",
        "Euler018": "fun maximumPathSumI(triangle: List<List<Int>>): Int {\n    var curr = triangle.last().toMutableList()\n    for (i in triangle.size - 2 downTo 0) {\n        val next = triangle[i].toMutableList()\n        for (j in 0 until next.size) {\n            next[j] += max(curr[j], curr[j + 1])\n        }\n        curr = next\n    }\n    return curr[0]\n}",
        "Euler019": "fun countingSundays(y1: Int, y2: Int): Int {\n    var day = 0\n    var count = 0\n    for (year in 1900..y2) {\n        for (month in 1..12) {\n            if (year >= y1 && day % 7 == 6) {\n                count++\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    return count\n}",
        "Euler020": "fun factorialDigitSum(n: Int): Int {\n    val digits = mutableListOf(1)\n    for (i in 1..n) {\n        var carry = 0\n        for (j in digits.indices) {\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        }\n        while (carry != 0) {\n            digits.add(carry % 10)\n            carry /= 10\n        }\n    }\n    var result = 0\n    for (digit in digits) {\n        result += digit\n    }\n    return result\n}",
        "Euler021": "fun d(n: Int): Int {\n    var result = 1\n    for (i in 2..sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            result += i\n            if (i != n / i) {\n                result += n / i\n            }\n        }\n    }\n    return result\n}\n\nfun amicableNumbers(n: Int): Int {\n    var result = 0\n    for (a in 2 until n) {\n        val b = d(a)\n        if (a != b && a == d(b)) {\n            result += a\n        }\n    }\n    return result\n}",
        "Euler022": "fun namesScores(names: List<String>, queries: List<String>): Int {\n    val sNames = names.sorted().toMutableList()\n    var result = 0\n    for ((i, name) in sNames.withIndex()) {\n        var x = 0\n        for (c in name) {\n            x += c.toInt() - 64\n        }\n        if (name in queries) {\n            result += x * (i + 1)\n        }\n    }\n    return result\n}",
        "Euler023": "fun isAbundant(n: Int): Boolean {\n    if (n < 12) {\n        return false\n    }\n    var sumDivisors = 1\n    for (i in 2..sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            sumDivisors += i\n            if (i != n / i) {\n                sumDivisors += n / i\n            }\n        }\n    }\n    return sumDivisors > n\n}\n\nfun nonAbundantSums(n: Int): Int {\n    val abundants = mutableListOf<Int>()\n    for (i in 12 until n) {\n        if (isAbundant(i)) {\n            abundants.add(i)\n        }\n    }\n    val abundantSums = mutableSetOf<Int>()\n    for (i in abundants) {\n        for (j in abundants) {\n            abundantSums.add(i + j)\n        }\n    }\n    var result = 0\n    for (i in 0 until n) {\n        if (i !in abundantSums) {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler024": "fun lexicographicPermutations(n: Int): String {\n    var result = \"\"\n    var digits = mutableListOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n    var x = n - 1\n    for (i in 10 downTo 1) {\n        var fact = 1\n        for (j in 1 until i) {\n            fact *= j\n        }\n        var idx = x / fact\n        result += digits[idx]\n        digits.removeAt(idx)\n        x -= idx * fact\n    }\n    return result\n}",
        "Euler025": "fun nDigitFibonacciNumber(n: Int): Int {\n    var a = listOf(1)\n    var b = listOf(1)\n    var i = 2\n    while (b.size < n) {\n        var carry = 0\n        val c = b.toMutableList()\n        for (j in b.indices) {\n            if (j < a.size) {\n                b = b.toMutableList()\n                b[j] = a[j] + b[j] + carry\n            } else {\n                b = b.toMutableList()\n                b[j] = b[j] + carry\n            }\n            carry = b[j] / 10\n            b = b.toMutableList()\n            b[j] = b[j] % 10\n        }\n        if (carry != 0) {\n            b = b.toMutableList()\n            b = b + carry\n        }\n        a = c\n        i = i + 1\n    }\n    return i\n}",
        "Euler026": "fun reciprocalCycles(n: Int): Int {\n    var result = 0\n    var maxLength = 0\n    for (i in 1 until n) {\n        val remainders = mutableListOf<Int>()\n        var remainder = 1\n        while (remainder != 0 && !remainders.contains(remainder)) {\n            remainders.add(remainder)\n            remainder = (remainder * 10) % i\n        }\n        var length = 0\n        if (remainder != 0) {\n            length = remainders.size - remainders.indexOf(remainder)\n        }\n        if (length > maxLength) {\n            maxLength = length\n            result = i\n        }\n    }\n    return result\n}",
        "Euler027": "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun quadraticPrimes(n: Int): Int {\n    var maxPrimes = 0\n    var result = 0\n    for (a in -n + 1 until n step 2) {\n        for (b in -n + 1 until n step 2) {\n            var x = 0\n            while (true) {\n                if (x * x + a * x + b < 2) {\n                    break\n                }\n                if (!isPrime(x * x + a * x + b)) {\n                    break\n                }\n                x++\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    return result\n}",
        "Euler028": "fun numberSpiralDiagonals(n: Int): Int {\n    var result = 1\n    for (i in 3..n step 2) {\n        result += 4 * i * i - 6 * i + 6\n    }\n    return result\n}",
        "Euler029": "fun distinctPowers(n: Int): Int {\n    var result = 0\n    val xs = mutableSetOf<String>()\n    for (i in 2..n) {\n        val primes = listOf(2, 3, 5, 7)\n        val powers = mutableListOf(0, 0, 0, 0)\n        var num = i\n        for (j in primes.indices) {\n            while (num % primes[j] == 0) {\n                num /= primes[j]\n                powers[j] += 1\n            }\n        }\n        if (num != 1) {\n            result += n - 1\n            continue\n        }\n        for (j in 2..n) {\n            val pstr = \"${powers[0] * j}-${powers[1] * j}-${powers[2] * j}-${powers[3] * j}\"\n            xs.add(pstr)\n        }\n    }\n    result += xs.size\n    return result\n}",
        "Euler030": "fun digitNthPowers(n: Int): Int {\n    var result = 0\n    for (i in 2 until 4 * 10.0.pow(n).toInt()) {\n        var digitsSum = 0\n        for (digit in i.toString()) {\n            digitsSum += digit.digitToInt().toDouble().pow(n).toInt()\n        }\n        if (i == digitsSum) {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler031": "fun coinSums(n: Int): Int {\n    val coins = listOf(1, 2, 5, 10, 20, 50, 100, 200)\n    val ways = IntArray(n + 1) { 0 }\n    ways[0] = 1\n    for (coin in coins) {\n        for (i in coin..n) {\n            ways[i] += ways[i - coin]\n        }\n    }\n    return ways[n]\n}",
        "Euler032": "fun pandigitalProducts(n: Int): Int {\n    val products = HashSet<Int>()\n    var s = \"\"\n    for (i in 1..n) {\n        s += i\n    }\n    for (a in 1 until 100) {\n        for (b in 1 until 10000) {\n            val c = a * b\n            var chars = (a.toString() + b.toString() + c.toString()).toCharArray()\n            chars.sort()\n            if (chars.joinToString(\"\") == s) {\n                products.add(c)\n            }\n        }\n    }\n    var result = 0\n    for (product in products) {\n        result += product\n    }\n    return result\n}",
        "Euler033": "fun digitCancelingFractions(m: Int): Int {\n    var numer = 1\n    var denom = 1\n    for (d in 10 until m) {\n        for (n in 10 until d) {\n            val n0 = n % 10\n            val n1 = n / 10\n            val d0 = d % 10\n            val d1 = d / 10\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    var a = numer\n    var b = denom\n    while (b != 0) {\n        val temp = b\n        b = a % b\n        a = temp\n    }\n    return denom / a\n}",
        "Euler034": "fun digitFactorials(n: Int): Int {\n    var result = 0\n    for (i in 3 until n) {\n        var factSum = 0\n        for (digit in i.toString()) {\n            var fact = 1\n            for (j in 1..digit.toInt() - '0'.toInt()) {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if (i == factSum) {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler035": "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun circularPrimes(n: Int): Int {\n    var count = 0\n    for (i in 2 until n) {\n        if (isPrime(i)) {\n            val rotations = HashSet<Int>()\n            val si = i.toString()\n            for (j in 0 until si.length) {\n                rotations.add((si.substring(j) + si.substring(0, j)).toInt())\n            }\n            var flag = true\n            for (x in rotations) {\n                if (!isPrime(x)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                count++\n            }\n        }\n    }\n    return count\n}",
        "Euler036": "fun isPalindrome(s: String): Boolean {\n    for (i in 0 until s.length / 2) {\n        if (s[i] != s[s.length - i - 1]) {\n            return false\n        }\n    }\n    return true\n}\n\nfun doubleBasePalindromes(n: Int): Int {\n    var result = 0\n    for (i in 1 until n) {\n        val strI = i.toString()\n        val binI = Integer.toBinaryString(i)\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i\n        }\n    }\n    return result\n}",
        "Euler037": "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun truncatablePrimes(n: Int): Int {\n    var result = 0\n    for (i in 10 until n) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            var flag = true\n            for (j in 1 until si.length) {\n                val p1 = si.substring(j).toInt()\n                val p2 = si.substring(0, si.length - j).toInt()\n                if (!isPrime(p1) || !isPrime(p2)) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                result += i\n            }\n        }\n    }\n    return result\n}",
        "Euler038": "fun pandigitalMultiples(n: Int): Int {\n    var result = -1\n    for (i in 2..n) {\n        var cprod = \"\"\n        for (j in 1 until 10) {\n            cprod += (i * j).toString()\n            if (cprod.length == 9) {\n                val chars = cprod.toCharArray()\n                chars.sort()\n                if (String(chars) == \"123456789\") {\n                    result = max(result, cprod.toInt())\n                    break\n                }\n            } else if (cprod.length > 9) {\n                break\n            }\n        }\n    }\n    return result\n}",
        "Euler039": "fun integerRightTriangles(n: Int): Int {\n    var maxSol = 0\n    var result = 0\n    for (p in 3..n) {\n        var sol = 0\n        for (a in 1 until p / 2) {\n            for (b in a until p / 2) {\n                val c = p - a - b\n                if (a * a + b * b == c * c) {\n                    sol++\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol\n            result = p\n        }\n    }\n    return result\n}",
        "Euler040": "fun champernowneConstant(b: Int): Int {\n    var s = \"\"\n    for (i in 1 until b.toDouble().pow(6).toInt()) {\n        s += i.toString()\n    }\n    var result = 1\n    for (i in 0 until 7) {\n        result *= s[b.toDouble().pow(i).toInt() - 1] - '0'\n    }\n    return result\n}",
        "Euler041": "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun pandigitalPrime(n: Int): Int {\n    for (i in n - 1 downTo 1) {\n        if (isPrime(i)) {\n            val si = i.toString()\n            val length = si.length\n            var flag = true\n            for (j in 1..length) {\n                if (!si.contains(j.toString())) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                return i\n            }\n        }\n    }\n    return -1\n}",
        "Euler042": "fun codedTriangleNumbers(words: List<String>): Int {\n    var result = 0\n    for (word in words) {\n        var value = 0\n        for (c in word) {\n            value += c.toInt() - 64\n        }\n        val n = sqrt((value * 2).toDouble()).toInt()\n        if (n * (n + 1) == value * 2) {\n            result++\n        }\n    }\n    return result\n}",
        "Euler043": "fun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in s.indices) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun subStringDivisibility(n: Int): Int {\n    var result = 0\n    val primes = listOf(2, 3, 5, 7, 11, 13, 17)\n    var s = \"\"\n    for (i in 0..n) {\n        s += i\n    }\n    for (i in genPermutations(s)) {\n        var flag = true\n        for (j in 1 until n - 1) {\n            if (i.substring(j, j + 3).toInt() % primes[j - 1] != 0) {\n                flag = false\n                break\n            }\n        }\n        if (flag) {\n            result += i.toInt()\n        }\n    }\n    return result\n}",
        "Euler044": "fun pentagonNumbers(n: Int): Int {\n    val pentagon = HashSet<Int>()\n    for (i in 1 until n) {\n        pentagon.add(i * (3 * i - 1) / 2)\n    }\n    var result = -1\n    for (j in pentagon) {\n        for (k in pentagon) {\n            if (pentagon.contains(j + k) && pentagon.contains(k - j)) {\n                if (result == -1 || k - j < result) {\n                    result = k - j\n                }\n            }\n        }\n    }\n    return result\n}",
        "Euler045": "fun triangularPentagonalAndHexagonal(n: Int): Int {\n    val ps = HashSet<Int>()\n    var i = 1\n    var c = (0.5 * i * (3 * i - 1)).toInt()\n    while (c < n) {\n        i++\n        ps.add(c)\n        c = (0.5 * i * (3 * i - 1)).toInt()\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    var result = -1\n    while (c < n) {\n        i++\n        if (ps.contains(c)) {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    return result\n}",
        "Euler046": "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun goldbachsOtherConjecture(n: Int): Int {\n    var result = -1\n    for (i in 9999 downTo n + 1 step 2) {\n        val upper = sqrt(i / 2.0).toInt()\n        var flag = false\n        for (j in 0..upper) {\n            if (isPrime(i - 2 * j * j)) {\n                flag = true\n                break\n            }\n        }\n        if (!flag) {\n            result = i\n        }\n    }\n    return result\n}",
        "Euler047": "fun primeFactors(n: Int): Int {\n    var num = n\n    val factors = mutableListOf<Int>()\n    var i = 2\n    while (i * i <= num) {\n        if (num % i != 0) {\n            i++\n        } else {\n            num /= i\n            factors.add(i)\n        }\n    }\n    if (num > 1) {\n        factors.add(num)\n    }\n    return factors.toSet().size\n}\n\nfun distinctPrimesFactors(n: Int): Int {\n    for (i in n until 1000000) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i\n        }\n    }\n    return -1\n}",
        "Euler048": "fun selfPowers(n: Int): String {\n    val digits = IntArray(10) { 0 }\n    for (i in 1..n) {\n        val tempDigits = IntArray(10) { 0 }\n        tempDigits[0] = 1\n        for (j in 0 until i) {\n            var carry = 0\n            for (k in 0 until 10) {\n                tempDigits[k] = tempDigits[k] * i + carry\n                carry = tempDigits[k] / 10\n                tempDigits[k] %= 10\n            }\n        }\n        for (j in 0 until 10) {\n            digits[j] += tempDigits[j]\n            if (digits[j] >= 10) {\n                digits[j] -= 10\n                if (j < 9) {\n                    digits[j + 1] += 1\n                }\n            }\n        }\n    }\n    var result = \"\"\n    for (i in 9 downTo 0) {\n        result += digits[i].toString()\n    }\n    return result\n}",
        "Euler049": "fun isPrime(n: Int): Boolean {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i in 3..sqrt(n.toDouble()).toInt() step 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun genPermutations(s: String): List<String> {\n    if (s.length <= 1) {\n        return listOf(s)\n    }\n    val result = mutableListOf<String>()\n    for (perm in genPermutations(s.substring(1))) {\n        for (i in s.indices) {\n            result.add(perm.substring(0, i) + s[0] + perm.substring(i))\n        }\n    }\n    return result\n}\n\nfun primePermutations(n: Int): String {\n    for (i in n downTo 999) {\n        if (isPrime(i)) {\n            val permutations = genPermutations(i.toString())\n            val candidates = mutableSetOf<Int>()\n            for (j in permutations) {\n                val candidate = j.toInt()\n                if (candidate > i && isPrime(candidate)) {\n                    candidates.add(candidate)\n                }\n            }\n            for (m in candidates) {\n                if (candidates.contains(m + (m - i))) {\n                    return i.toString() + m.toString() + (m + (m - i)).toString()\n                }\n            }\n        }\n    }\n    return \"\"\n}",
        "Euler050": "fun consecutivePrimeSum(limit: Int): Int {\n    val sieve = Array(limit) { true }\n    val primes = mutableListOf<Int>()\n    for (i in 2 until limit) {\n        if (sieve[i]) {\n            primes.add(i)\n            for (j in i * 2 until limit step i) {\n                sieve[j] = false\n            }\n        }\n    }\n    var maxLength = 0\n    var maxPrime = 0\n    for (i in primes.indices) {\n        for (j in i + maxLength until primes.size) {\n            var s = 0\n            for (k in i until j) {\n                s += primes[k]\n            }\n            if (s >= limit) {\n                break\n            }\n            if (sieve[s] && j - i > maxLength) {\n                maxLength = j - i\n                maxPrime = s\n            }\n        }\n    }\n    return maxPrime\n}"
    },
    "php": {
        "Euler001": "function multiplesOf3And5($n) {\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if ($i % 3 === 0 || $i % 5 === 0) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
        "Euler002": "function evenFibonacciNumbers($n) {\n    $result = 0;\n    $a = 1;\n    $b = 2;\n    while ($a < $n) {\n        if ($a % 2 === 0) {\n            $result += $a;\n        }\n        $tmp = $a;\n        $a = $b;\n        $b = $tmp + $b;\n    }\n    return $result;\n}",
        "Euler003": "function largestPrimeFactor($n) {\n    $result = $n;\n    $i = 2;\n    while ($i * $i <= $result) {\n        if ($result % $i !== 0) {\n            $i += 1;\n        } else {\n            $result /= $i;\n        }\n    }\n    return $result;\n}",
        "Euler004": "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i] !== $s[strlen($s) - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction largestPalindromeProduct($n) {\n    $result = 0;\n    for ($i = 100; $i < 1000; $i++) {\n        for ($j = $i; $j < 1000; $j++) {\n            $prod = $i * $j;\n            if (isPalindrome((string)$prod) && $prod > $result && $prod < $n) {\n                $result = $prod;\n            }\n        }\n    }\n    return $result;\n}",
        "Euler005": "function smallestMultiple($n) {\n    $result = 1;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($result % $i !== 0) {\n            for ($j = 1; $j <= $n; $j++) {\n                if (($result * $j) % $i === 0) {\n                    $result *= $j;\n                    break;\n                }\n            }\n        }\n    }\n    return $result;\n}",
        "Euler006": "function sumSquareDifference($n) {\n    $sqrSum = 0;\n    $numSum = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $sqrSum += $i * $i;\n        $numSum += $i;\n    }\n    return $numSum * $numSum - $sqrSum;\n}",
        "Euler007": "function nthPrime($n) {\n    $primes = [2];\n    $i = 3;\n    while (count($primes) < $n) {\n        foreach ($primes as $p) {\n            if ($i % $p === 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                $primes[] = $i;\n                break;\n            }\n        }\n        $i += 2;\n    }\n    return end($primes);\n}",
        "Euler008": "function largestProductInASeries($s, $k) {\n    $result = 0;\n    for ($i = 0; $i < strlen($s) - $k; $i++) {\n        $product = 1;\n        for ($j = 0; $j < $k; $j++) {\n            $product *= intval($s[$i + $j]);\n        }\n        $result = max($result, $product);\n    }\n    return $result;\n}",
        "Euler009": "function specialPythagoreanTriplet($n) {\n    for ($a = 1; $a < $n; $a++) {\n        for ($b = $a; $b < $n; $b++) {\n            $c = $n - $a - $b;\n            if ($a * $a + $b * $b === $c * $c) {\n                return $a * $b * $c;\n            }\n        }\n    }\n    return -1;\n}",
        "Euler010": "function summationOfPrimes($n) {\n    $primes = [2];\n    $i = 3;\n    while ($i <= $n) {\n        foreach ($primes as $p) {\n            if ($i % $p === 0) {\n                break;\n            }\n            if ($p * $p > $i) {\n                $primes[] = $i;\n                break;\n            }\n        }\n        $i += 2;\n    }\n    $result = 0;\n    foreach ($primes as $prime) {\n        $result += $prime;\n    }\n    return $result;\n}",
        "Euler011": "function largestProductInAGrid($grid) {\n    $result = 0;\n    for ($i = 0; $i < count($grid) - 3; $i++) {\n        for ($j = 0; $j < count($grid[$i]) - 3; $j++) {\n            $p1 = 1;\n            $p2 = 1;\n            $p3 = 1;\n            $p4 = 1;\n            for ($k = 0; $k < 4; $k++) {\n                $p1 *= $grid[$i + $k][$j];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p2 *= $grid[$i][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p3 *= $grid[$i + $k][$j + $k];\n            }\n            for ($k = 0; $k < 4; $k++) {\n                $p4 *= $grid[$i + $k][$j + 3 - $k];\n            }\n            $result = max($result, $p1, $p2, $p3, $p4);\n        }\n    }\n    return $result;\n}",
        "Euler012": "function highlyDivisibleTriangularNumber($n) {\n    for ($i = 1; $i < 100000000; $i++) {\n        $result = $i * ($i + 1) / 2;\n        $count = 0;\n        for ($j = 1; $j <= intval(sqrt($result)); $j++) {\n            if ($result % $j === 0) {\n                $count += 2;\n            }\n            if ($j * $j === $result) {\n                $count -= 1;\n            }\n        }\n        if ($count > $n) {\n            return $result;\n        }\n    }\n    return -1;\n}",
        "Euler013": "function largeSum($numbers) {\n    $digits = array_fill(0, 60, 0);\n    for ($i = 0; $i < 50; $i++) {\n        $tmp = 0;\n        foreach ($numbers as $num) {\n            $tmp += (int)$num[49 - $i];\n        }\n        for ($j = $i; $j < 60; $j++) {\n            $digits[$j] += $tmp % 10;\n            if ($digits[$j] >= 10) {\n                $digits[$j + 1] += intdiv($digits[$j], 10);\n                $digits[$j] %= 10;\n            }\n            $tmp = intdiv($tmp, 10);\n            if ($tmp === 0) {\n                break;\n            }\n        }\n    }\n    for ($i = 59; $i >= 0; $i--) {\n        if ($digits[$i] !== 0) {\n            $result = '';\n            for ($j = $i; $j > $i - 10; $j--) {\n                $result .= $digits[$j];\n            }\n            return $result;\n        }\n    }\n    return '';\n}",
        "Euler014": "function longestCollatzSequence($n) {\n    $longest = 0;\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $chain = 1;\n        $num = $i;\n        while ($num !== 1) {\n            if ($num % 2 === 0) {\n                $num = $num / 2;\n            } else {\n                $num = 3 * $num + 1;\n            }\n            $chain++;\n        }\n        if ($chain > $longest) {\n            $longest = $chain;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
        "Euler015": "function latticePaths($m, $n) {\n    $grid = array_fill(0, $m + 1, array_fill(0, $n + 1, 0));\n    for ($i = 0; $i <= $m; $i++) {\n        $grid[$i][0] = 1;\n    }\n    for ($j = 0; $j <= $n; $j++) {\n        $grid[0][$j] = 1;\n    }\n    for ($i = 1; $i <= $m; $i++) {\n        for ($j = 1; $j <= $n; $j++) {\n            $grid[$i][$j] = $grid[$i - 1][$j] + $grid[$i][$j - 1];\n        }\n    }\n    return $grid[$m][$n];\n}",
        "Euler016": "function powerDigitSum($n) {\n    $digits = [2];\n    for ($i = 1; $i < $n; $i++) {\n        $carry = 0;\n        for ($j = 0; $j < count($digits); $j++) {\n            $temp = $digits[$j] * 2 + $carry;\n            $digits[$j] = $temp % 10;\n            $carry = intdiv($temp, 10);\n        }\n        if ($carry !== 0) {\n            array_push($digits, $carry);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
        "Euler017": "function numberToWords($n) {\n    $ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    $teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    $tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if ($n === 1000) {\n        return \"one thousand\";\n    } elseif ($n >= 100) {\n        if ($n % 100 === 0) {\n            return $ones[$n / 100] . \" hundred\";\n        } else {\n            return $ones[$n / 100] . \" hundred and \" . numberToWords($n % 100);\n        }\n    } elseif ($n >= 20) {\n        $suf = \"\";\n        if ($n % 10 !== 0) {\n            $suf = \" \" . $ones[$n % 10];\n        }\n        return $tens[$n / 10] . $suf;\n    } elseif ($n >= 10) {\n        return $teens[$n - 10];\n    } else {\n        return $ones[$n];\n    }\n}",
        "Euler018": "function maximumPathSumI($triangle) {\n    $curr = end($triangle);\n    for ($i = count($triangle) - 2; $i >= 0; $i--) {\n        $next = $triangle[$i];\n        for ($j = 0; $j < count($next); $j++) {\n            $next[$j] += max($curr[$j], $curr[$j + 1]);\n        }\n        $curr = $next;\n    }\n    return $curr[0];\n}",
        "Euler019": "function countingSundays($y1, $y2) {\n    $day = 0;\n    $count = 0;\n    for ($year = 1900; $year <= $y2; $year++) {\n        for ($month = 1; $month <= 12; $month++) {\n            if ($year >= $y1 && $day % 7 === 6) {\n                $count++;\n            }\n            if ($month === 4 || $month === 6 || $month === 9 || $month === 11) {\n                $day += 30;\n            } else if ($month === 2) {\n                if ($year % 4 === 0 && ($year % 100 !== 0 || $year % 400 === 0)) {\n                    $day += 29;\n                } else {\n                    $day += 28;\n                }\n            } else {\n                $day += 31;\n            }\n        }\n    }\n    return $count;\n}",
        "Euler020": "function factorialDigitSum($n) {\n    $digits = [1];\n    for ($i = 1; $i <= $n; $i++) {\n        $carry = 0;\n        for ($j = 0; $j < count($digits); $j++) {\n            $digits[$j] = $digits[$j] * $i + $carry;\n            $carry = (int)($digits[$j] / 10);\n            $digits[$j] %= 10;\n        }\n        while ($carry !== 0) {\n            $digits[] = $carry % 10;\n            $carry = (int)($carry / 10);\n        }\n    }\n    $result = 0;\n    foreach ($digits as $digit) {\n        $result += $digit;\n    }\n    return $result;\n}",
        "Euler021": "function d($n) {\n    $result = 1;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i === 0) {\n            $result += $i;\n            if ($i !== $n / $i) {\n                $result += $n / $i;\n            }\n        }\n    }\n    return $result;\n}\n\nfunction amicableNumbers($n) {\n    $result = 0;\n    for ($a = 2; $a < $n; $a++) {\n        $b = d($a);\n        if ($a !== $b && $a === d($b)) {\n            $result += $a;\n        }\n    }\n    return $result;\n}",
        "Euler022": "function namesScores($names, $queries) {\n    $sNames = $names;\n    sort($sNames);\n    $result = 0;\n    foreach ($sNames as $i => $name) {\n        $x = 0;\n        foreach (str_split($name) as $c) {\n            $x += ord($c) - 64;\n        }\n        if (in_array($name, $queries)) {\n            $result += $x * ($i + 1);\n        }\n    }\n    return $result;\n}",
        "Euler023": "function isAbundant($n) {\n    if ($n < 12) {\n        return false;\n    }\n    $sumDivisors = 1;\n    for ($i = 2; $i <= sqrt($n); $i++) {\n        if ($n % $i === 0) {\n            $sumDivisors += $i;\n            if ($i !== $n / $i) {\n                $sumDivisors += $n / $i;\n            }\n        }\n    }\n    return $sumDivisors > $n;\n}\n\nfunction nonAbundantSums($n) {\n    $abundants = [];\n    for ($i = 12; $i < $n; $i++) {\n        if (isAbundant($i)) {\n            $abundants[] = $i;\n        }\n    }\n    $abundantSums = [];\n    foreach ($abundants as $i) {\n        foreach ($abundants as $j) {\n            $abundantSums[] = $i + $j;\n        }\n    }\n    $result = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!in_array($i, $abundantSums)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
        "Euler024": "function lexicographicPermutations($n) {\n    $result = \"\";\n    $digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    $x = $n - 1;\n    for ($i = 10; $i > 0; $i--) {\n        $fact = 1;\n        for ($j = 1; $j < $i; $j++) {\n            $fact *= $j;\n        }\n        $idx = floor($x / $fact);\n        $result .= $digits[$idx];\n        array_splice($digits, $idx, 1);\n        $x -= $idx * $fact;\n    }\n    return $result;\n}",
        "Euler025": "function nDigitFibonacciNumber($n) {\n    $a = [1];\n    $b = [1];\n    $i = 2;\n    while (count($b) < $n) {\n        $carry = 0;\n        $c = $b;\n        for ($j = 0; $j < count($b); $j++) {\n            if ($j < count($a)) {\n                $b[$j] = $a[$j] + $b[$j] + $carry;\n            } else {\n                $b[$j] = $b[$j] + $carry;\n            }\n            $carry = intdiv($b[$j], 10);\n            $b[$j] = $b[$j] % 10;\n        }\n        if ($carry !== 0) {\n            array_push($b, $carry);\n        }\n        $a = $c;\n        $i = $i + 1;\n    }\n    return $i;\n}",
        "Euler026": "function reciprocalCycles($n) {\n    $result = 0;\n    $maxLength = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $remainders = [];\n        $remainder = 1;\n        while ($remainder !== 0 && !in_array($remainder, $remainders)) {\n            array_push($remainders, $remainder);\n            $remainder = ($remainder * 10) % $i;\n        }\n        $length = 0;\n        if ($remainder !== 0) {\n            $length = count($remainders) - array_search($remainder, $remainders);\n        }\n        if ($length > $maxLength) {\n            $maxLength = $length;\n            $result = $i;\n        }\n    }\n    return $result;\n}",
        "Euler027": "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction quadraticPrimes($n) {\n    $maxPrimes = 0;\n    $result = 0;\n    for ($a = -$n + 1; $a < $n; $a += 2) {\n        for ($b = -$n + 1; $b < $n; $b += 2) {\n            $x = 0;\n            while (true) {\n                if ($x * $x + $a * $x + $b < 2) {\n                    break;\n                }\n                if (!isPrime($x * $x + $a * $x + $b)) {\n                    break;\n                }\n                $x++;\n            }\n            if ($x > $maxPrimes) {\n                $maxPrimes = $x;\n                $result = $a * $b;\n            }\n        }\n    }\n    return $result;\n}",
        "Euler028": "function numberSpiralDiagonals($n) {\n    $result = 1;\n    for ($i = 3; $i <= $n; $i += 2) {\n        $result += 4 * $i * $i - 6 * $i + 6;\n    }\n    return $result;\n}",
        "Euler029": "function distinctPowers($n) {\n    $result = 0;\n    $xs = [];\n    for ($i = 2; $i <= $n; $i++) {\n        $primes = [2, 3, 5, 7];\n        $powers = [0, 0, 0, 0];\n        $num = $i;\n        for ($j = 0; $j < count($primes); $j++) {\n            while ($num % $primes[$j] === 0) {\n                $num /= $primes[$j];\n                $powers[$j] += 1;\n            }\n        }\n        if ($num !== 1) {\n            $result += $n - 1;\n            continue;\n        }\n        for ($j = 2; $j <= $n; $j++) {\n            $pstr = sprintf(\"%d-%d-%d-%d\", $powers[0] * $j, $powers[1] * $j, $powers[2] * $j, $powers[3] * $j);\n            $xs[$pstr] = true;\n        }\n    }\n    $result += count($xs);\n    return $result;\n}",
        "Euler030": "function digitNthPowers($n) {\n    $result = 0;\n    for ($i = 2; $i < 4 * pow(10, $n); $i++) {\n        $digitsSum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $digitsSum += pow($digit, $n);\n        }\n        if ($i === $digitsSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
        "Euler031": "function coinSums($n) {\n    $coins = [1, 2, 5, 10, 20, 50, 100, 200];\n    $ways = array_fill(0, $n + 1, 0);\n    $ways[0] = 1;\n    foreach ($coins as $coin) {\n        for ($i = $coin; $i <= $n; $i++) {\n            $ways[$i] += $ways[$i - $coin];\n        }\n    }\n    return $ways[$n];\n}",
        "Euler032": "function pandigitalProducts($n) {\n    $products = [];\n    $s = \"\";\n    for ($i = 1; $i <= $n; $i++) {\n        $s .= $i;\n    }\n    for ($a = 1; $a < 100; $a++) {\n        for ($b = 1; $b < 10000; $b++) {\n            $c = $a * $b;\n            $chars = str_split(strval($a) . strval($b) . strval($c));\n            sort($chars);\n            if (implode(\"\", $chars) === $s) {\n                $products[$c] = true;\n            }\n        }\n    }\n    $result = 0;\n    foreach (array_keys($products) as $product) {\n        $result += $product;\n    }\n    return $result;\n}",
        "Euler033": "function digitCancelingFractions($m) {\n    $numer = 1;\n    $denom = 1;\n    for ($d = 10; $d < $m; $d++) {\n        for ($n = 10; $n < $d; $n++) {\n            $n0 = $n % 10;\n            $n1 = intdiv($n, 10);\n            $d0 = $d % 10;\n            $d1 = intdiv($d, 10);\n            if (($n1 === $d0 && $n0 * $d === $n * $d1) || ($n0 === $d1 && $n1 * $d === $n * $d0)) {\n                $numer *= $n;\n                $denom *= $d;\n            }\n        }\n    }\n    $a = $numer;\n    $b = $denom;\n    while ($b !== 0) {\n        $temp = $b;\n        $b = $a % $b;\n        $a = $temp;\n    }\n    return intdiv($denom, $a);\n}",
        "Euler034": "function digitFactorials($n) {\n    $result = 0;\n    for ($i = 3; $i < $n; $i++) {\n        $factSum = 0;\n        foreach (str_split(strval($i)) as $digit) {\n            $fact = 1;\n            for ($j = 1; $j <= intval($digit); $j++) {\n                $fact *= $j;\n            }\n            $factSum += $fact;\n        }\n        if ($i === $factSum) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
        "Euler035": "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction circularPrimes($n) {\n    $count = 0;\n    for ($i = 2; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $rotations = [];\n            $si = strval($i);\n            for ($j = 0; $j < strlen($si); $j++) {\n                $rotations[] = intval(substr($si, $j) . substr($si, 0, $j));\n            }\n            $flag = true;\n            foreach ($rotations as $x) {\n                if (!isPrime($x)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}",
        "Euler036": "function isPalindrome($s) {\n    for ($i = 0; $i < strlen($s) / 2; $i++) {\n        if ($s[$i] !== $s[strlen($s) - ($i + 1)]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction doubleBasePalindromes($n) {\n    $result = 0;\n    for ($i = 1; $i < $n; $i++) {\n        $strI = strval($i);\n        $binI = decbin($i);\n        if (isPalindrome($strI) && isPalindrome($binI)) {\n            $result += $i;\n        }\n    }\n    return $result;\n}",
        "Euler037": "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction truncatablePrimes($n) {\n    $result = 0;\n    for ($i = 10; $i < $n; $i++) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $flag = true;\n            for ($j = 1; $j < strlen($si); $j++) {\n                $p1 = intval(substr($si, $j));\n                $p2 = intval(substr($si, 0, strlen($si) - $j));\n                if (!isPrime($p1) || !isPrime($p2)) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                $result += $i;\n            }\n        }\n    }\n    return $result;\n}",
        "Euler038": "function pandigitalMultiples($n) {\n    $result = -1;\n    for ($i = 2; $i <= $n; $i++) {\n        $cprod = '';\n        for ($j = 1; $j < 10; $j++) {\n            $cprod .= $i * $j;\n            if (strlen($cprod) === 9) {\n                $chars = str_split($cprod);\n                sort($chars);\n                if (implode($chars) === '123456789') {\n                    $result = max($result, (int)$cprod);\n                    break;\n                }\n            } elseif (strlen($cprod) > 9) {\n                break;\n            }\n        }\n    }\n    return $result;\n}",
        "Euler039": "function integerRightTriangles($n) {\n    $maxSol = 0;\n    $result = 0;\n    for ($p = 3; $p <= $n; $p++) {\n        $sol = 0;\n        for ($a = 1; $a < $p / 2; $a++) {\n            for ($b = $a; $b < $p / 2; $b++) {\n                $c = $p - $a - $b;\n                if ($a * $a + $b * $b === $c * $c) {\n                    $sol++;\n                }\n            }\n        }\n        if ($sol > $maxSol) {\n            $maxSol = $sol;\n            $result = $p;\n        }\n    }\n    return $result;\n}",
        "Euler040": "function champernowneConstant($b) {\n    $s = \"\";\n    for ($i = 1; $i < pow($b, 6); $i++) {\n        $s .= strval($i);\n    }\n    $result = 1;\n    for ($i = 0; $i < 7; $i++) {\n        $result *= intval($s[pow($b, $i) - 1]);\n    }\n    return $result;\n}",
        "Euler041": "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction pandigitalPrime($n) {\n    for ($i = $n - 1; $i > 0; $i--) {\n        if (isPrime($i)) {\n            $si = strval($i);\n            $length = strlen($si);\n            $flag = true;\n            for ($j = 1; $j <= $length; $j++) {\n                if (strpos($si, strval($j)) === false) {\n                    $flag = false;\n                    break;\n                }\n            }\n            if ($flag) {\n                return $i;\n            }\n        }\n    }\n    return -1;\n}",
        "Euler042": "function codedTriangleNumbers($words) {\n    $result = 0;\n    foreach ($words as $word) {\n        $value = 0;\n        for ($i = 0; $i < strlen($word); $i++) {\n            $value += ord($word[$i]) - 64;\n        }\n        $n = intval(sqrt($value * 2));\n        if ($n * ($n + 1) === $value * 2) {\n            $result++;\n        }\n    }\n    return $result;\n}",
        "Euler043": "function genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return [$s];\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); $i++) {\n            $result[] = substr($perm, 0, $i) . $s[0] . substr($perm, $i);\n        }\n    }\n    return $result;\n}\n\nfunction subStringDivisibility($n) {\n    $result = 0;\n    $primes = [2, 3, 5, 7, 11, 13, 17];\n    $s = \"\";\n    for ($i = 0; $i <= $n; $i++) {\n        $s .= $i;\n    }\n    foreach (genPermutations($s) as $i) {\n        $flag = true;\n        for ($j = 1; $j < $n - 1; $j++) {\n            if (intval(substr($i, $j, 3)) % $primes[$j - 1] !== 0) {\n                $flag = false;\n                break;\n            }\n        }\n        if ($flag) {\n            $result += intval($i);\n        }\n    }\n    return $result;\n}",
        "Euler044": "function pentagonNumbers($n) {\n    $pentagon = array();\n    for ($i = 1; $i < $n; $i++) {\n        $pentagon[$i * (3 * $i - 1) / 2] = true;\n    }\n    $result = -1;\n    foreach ($pentagon as $j => $value) {\n        foreach ($pentagon as $k => $value) {\n            if (isset($pentagon[$j + $k]) && isset($pentagon[$k - $j])) {\n                if ($result === -1 || $k - $j < $result) {\n                    $result = $k - $j;\n                }\n            }\n        }\n    }\n    return $result;\n}",
        "Euler045": "function triangularPentagonalAndHexagonal($n) {\n    $ps = [];\n    $i = 1;\n    $c = 0.5 * $i * (3 * $i - 1);\n    while ($c < $n) {\n        $i++;\n        $ps[$c] = true;\n        $c = 0.5 * $i * (3 * $i - 1);\n    }\n    $i = 1;\n    $c = $i * (2 * $i - 1);\n    $result = -1;\n    while ($c < $n) {\n        $i++;\n        if (isset($ps[$c])) {\n            $result = $c;\n        }\n        $c = $i * (2 * $i - 1);\n    }\n    return $result;\n}",
        "Euler046": "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction goldbachsOtherConjecture($n) {\n    $result = -1;\n    for ($i = 9999; $i > $n; $i -= 2) {\n        $upper = sqrt($i / 2);\n        $flag = false;\n        for ($j = 0; $j <= $upper; $j++) {\n            if (isPrime($i - 2 * $j * $j)) {\n                $flag = true;\n                break;\n            }\n        }\n        if (!$flag) {\n            $result = $i;\n        }\n    }\n    return $result;\n}",
        "Euler047": "function primeFactors($n) {\n    $num = $n;\n    $factors = [];\n    $i = 2;\n    while ($i * $i <= $num) {\n        if ($num % $i !== 0) {\n            $i++;\n        } else {\n            $num /= $i;\n            $factors[] = $i;\n        }\n    }\n    if ($num > 1) {\n        $factors[] = $num;\n    }\n    return count(array_unique($factors));\n}\n\nfunction distinctPrimesFactors($n) {\n    for ($i = $n; $i < 1000000; $i++) {\n        if (primeFactors($i) === 4 && primeFactors($i + 1) === 4 && primeFactors($i + 2) === 4 && primeFactors($i + 3) === 4) {\n            return $i;\n        }\n    }\n    return -1;\n}",
        "Euler048": "function selfPowers($n) {\n    $digits = array_fill(0, 10, 0);\n    for ($i = 1; $i <= $n; $i++) {\n        $tempDigits = array_fill(0, 10, 0);\n        $tempDigits[0] = 1;\n        for ($j = 0; $j < $i; $j++) {\n            $carry = 0;\n            for ($k = 0; $k < 10; $k++) {\n                $tempDigits[$k] = $tempDigits[$k] * $i + $carry;\n                $carry = intdiv($tempDigits[$k], 10);\n                $tempDigits[$k] %= 10;\n            }\n        }\n        for ($j = 0; $j < 10; $j++) {\n            $digits[$j] += $tempDigits[$j];\n            if ($digits[$j] >= 10) {\n                $digits[$j] -= 10;\n                if ($j < 9) {\n                    $digits[$j + 1] += 1;\n                }\n            }\n        }\n    }\n    $result = \"\";\n    for ($i = 9; $i >= 0; $i--) {\n        $result .= strval($digits[$i]);\n    }\n    return $result;\n}",
        "Euler049": "function isPrime($n) {\n    if ($n < 2) {\n        return false;\n    }\n    if ($n === 2) {\n        return true;\n    }\n    if ($n % 2 === 0) {\n        return false;\n    }\n    for ($i = 3; $i <= intval(sqrt($n)); $i += 2) {\n        if ($n % $i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction genPermutations($s) {\n    if (strlen($s) <= 1) {\n        return [$s];\n    }\n    $result = [];\n    foreach (genPermutations(substr($s, 1)) as $perm) {\n        for ($i = 0; $i < strlen($s); ++$i) {\n            $result[] = substr($perm, 0, $i) . $s[0] . substr($perm, $i);\n        }\n    }\n    return $result;\n}\n\nfunction primePermutations($n) {\n    for ($i = $n; $i > 999; --$i) {\n        if (isPrime($i)) {\n            $permutations = genPermutations(strval($i));\n            $candidates = [];\n            foreach ($permutations as $j) {\n                $candidate = intval($j);\n                if ($candidate > $i && isPrime($candidate)) {\n                    $candidates[] = $candidate;\n                }\n            }\n            foreach ($candidates as $m) {\n                if (in_array($m + ($m - $i), $candidates)) {\n                    return strval($i) . strval($m) . strval($m + ($m - $i));\n                }\n            }\n        }\n    }\n    return \"\";\n}",
        "Euler050": "function consecutivePrimeSum($limit) {\n    $sieve = array_fill(0, $limit, true);\n    $primes = [];\n    for ($i = 2; $i < $limit; $i++) {\n        if ($sieve[$i]) {\n            $primes[] = $i;\n            for ($j = $i * 2; $j < $limit; $j += $i) {\n                $sieve[$j] = false;\n            }\n        }\n    }\n    $maxLength = 0;\n    $maxPrime = 0;\n    for ($i = 0; $i < count($primes); $i++) {\n        for ($j = $i + $maxLength; $j < count($primes); $j++) {\n            $s = 0;\n            for ($k = $i; $k < $j; $k++) {\n                $s += $primes[$k];\n            }\n            if ($s >= $limit) {\n                break;\n            }\n            if ($sieve[$s] && $j - $i > $maxLength) {\n                $maxLength = $j - $i;\n                $maxPrime = $s;\n            }\n        }\n    }\n    return $maxPrime;\n}"
    },
    "ruby": {
        "Euler001": "def multiples_of_3_and_5(n)\n    result = 0\n    (0...n).each do |i|\n        if i % 3 == 0 || i % 5 == 0\n            result += i\n        end\n    end\n    result\nend",
        "Euler002": "def even_fibonacci_numbers(n)\n    result = 0\n    a = 1\n    b = 2\n    while a < n\n        if a % 2 == 0\n            result += a\n        end\n        tmp = a\n        a = b\n        b = tmp + b\n    end\n    result\nend",
        "Euler003": "def largest_prime_factor(n)\n    result = n\n    i = 2\n    while i * i <= result\n        if result % i != 0\n            i += 1\n        else\n            result /= i\n        end\n    end\n    result\nend",
        "Euler004": "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        if s[i] != s[s.length - i - 1]\n            return false\n        end\n    end\n    true\nend\n\ndef largest_palindrome_product(n)\n    result = 0\n    (100...1000).each do |i|\n        (i...1000).each do |j|\n            prod = i * j\n            if is_palindrome(prod.to_s) && prod > result && prod < n\n                result = prod\n            end\n        end\n    end\n    result\nend",
        "Euler005": "def smallest_multiple(n)\n    result = 1\n    (1..n).each do |i|\n        if result % i != 0\n            (1..n).each do |j|\n                if (result * j) % i == 0\n                    result *= j\n                    break\n                end\n            end\n        end\n    end\n    result\nend",
        "Euler006": "def sum_square_difference(n)\n    sqr_sum = 0\n    num_sum = 0\n    (1..n).each do |i|\n        sqr_sum += i * i\n        num_sum += i\n    end\n    num_sum * num_sum - sqr_sum\nend",
        "Euler007": "def nth_prime(n)\n    primes = [2]\n    i = 3\n    while primes.length < n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    primes.last\nend",
        "Euler008": "def largest_product_in_a_series(s, k)\n    result = 0\n    (0..s.length - k).each do |i|\n        product = 1\n        (0...k).each do |j|\n            product *= s[i + j].to_i\n        end\n        result = [result, product].max\n    end\n    result\nend",
        "Euler009": "def special_pythagorean_triplet(n)\n    (1...n).each do |a|\n        (a...n).each do |b|\n            c = n - a - b\n            return a * b * c if a * a + b * b == c * c\n        end\n    end\nend",
        "Euler010": "def summation_of_primes(n)\n    primes = [2]\n    i = 3\n    while i <= n\n        primes.each do |p|\n            if i % p == 0\n                break\n            end\n            if p * p > i\n                primes.push(i)\n                break\n            end\n        end\n        i += 2\n    end\n    result = 0\n    primes.each do |prime|\n        result += prime\n    end\n    result\nend",
        "Euler011": "def largest_product_in_a_grid(grid)\n    result = 0\n    (0...grid.length - 3).each do |i|\n        (0...grid[i].length - 3).each do |j|\n            p1, p2, p3, p4 = 1, 1, 1, 1\n            (0...4).each do |k|\n                p1 *= grid[i + k][j]\n            end\n            (0...4).each do |k|\n                p2 *= grid[i][j + k]\n            end\n            (0...4).each do |k|\n                p3 *= grid[i + k][j + k]\n            end\n            (0...4).each do |k|\n                p4 *= grid[i + k][j + 3 - k]\n            end\n            result = [result, p1, p2, p3, p4].max\n        end\n    end\n    result\nend",
        "Euler012": "def highly_divisible_triangular_number(n)\n    (1...100000000).each do |i|\n        result = i * (i + 1) / 2\n        count = 0\n        (1..Math.sqrt(result).to_i).each do |j|\n            if result % j == 0\n                count += 2\n            end\n            if j * j == result\n                count -= 1\n            end\n        end\n        if count > n\n            return result\n        end\n    end\n    -1\nend",
        "Euler013": "def large_sum(numbers)\n    digits = Array.new(60, 0)\n    (0...50).each do |i|\n        tmp = 0\n        numbers.each do |num|\n            tmp += num[49 - i].to_i\n        end\n        (i...60).each do |j|\n            digits[j] += tmp % 10\n            if digits[j] >= 10\n                digits[j + 1] += digits[j] / 10\n                digits[j] %= 10\n            end\n            tmp /= 10\n            break if tmp == 0\n        end\n    end\n    59.downto(0) do |i|\n        next if digits[i] == 0\n        result = ''\n        i.downto(i - 9).each do |j|\n            result += digits[j].to_s\n        end\n        return result\n    end\nend",
        "Euler014": "def longest_collatz_sequence(n)\n    longest = 0\n    result = 0\n    (1...n).each do |i|\n        chain = 1\n        num = i\n        while num != 1\n            if num % 2 == 0\n                num = num / 2\n            else\n                num = 3 * num + 1\n            end\n            chain += 1\n        end\n        if chain > longest\n            longest = chain\n            result = i\n        end\n    end\n    result\nend",
        "Euler015": "def lattice_paths(m, n)\n    grid = Array.new(m + 1) { Array.new(n + 1, 0) }\n    (0..m).each do |i|\n        grid[i][0] = 1\n    end\n    (0..n).each do |j|\n        grid[0][j] = 1\n    end\n    (1..m).each do |i|\n        (1..n).each do |j|\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        end\n    end\n    grid[m][n]\nend",
        "Euler016": "def power_digit_sum(n)\n    digits = [2]\n    (1...n).each do\n        carry = 0\n        digits.each_with_index do |_, j|\n            temp = digits[j] * 2 + carry\n            digits[j] = temp % 10\n            carry = temp / 10\n        end\n        digits.push(carry) if carry != 0\n    end\n    result = 0\n    digits.each { |digit| result += digit }\n    result\nend",
        "Euler017": "def number_to_words(n)\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    if n == 1000\n        \"one thousand\"\n    elsif n >= 100\n        if n % 100 == 0\n            ones[n / 100] + \" hundred\"\n        else\n            ones[n / 100] + \" hundred and \" + number_to_words(n % 100)\n        end\n    elsif n >= 20\n        suf = \"\"\n        if n % 10 != 0\n            suf = \" \" + ones[n % 10]\n        end\n        tens[n / 10] + suf\n    elsif n >= 10\n        teens[n - 10]\n    else\n        ones[n]\n    end\nend",
        "Euler018": "def maximum_path_sum_i(triangle)\n    curr = triangle.last.dup\n    (triangle.size - 2).downto(0) do |i|\n        next_ = triangle[i].dup\n        next_.each_with_index do |_, j|\n            next_[j] += [curr[j], curr[j + 1]].max\n        end\n        curr = next_\n    end\n    curr[0]\nend",
        "Euler019": "def counting_sundays(y1, y2)\n    day = 0\n    count = 0\n    (1900..y2).each do |year|\n        (1..12).each do |month|\n            if year >= y1 && day % 7 == 6\n                count += 1\n            end\n            if [4, 6, 9, 11].include?(month)\n                day += 30\n            elsif month == 2\n                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)\n                    day += 29\n                else\n                    day += 28\n                end\n            else\n                day += 31\n            end\n        end\n    end\n    count\nend",
        "Euler020": "def factorial_digit_sum(n)\n    digits = [1]\n    (1..n).each do |i|\n        carry = 0\n        (0...digits.length).each do |j|\n            digits[j] = digits[j] * i + carry\n            carry = digits[j] / 10\n            digits[j] %= 10\n        end\n        while carry != 0\n            digits.push(carry % 10)\n            carry /= 10\n        end\n    end\n    result = 0\n    digits.each do |digit|\n        result += digit\n    end\n    result\nend",
        "Euler021": "def d(n)\n    result = 1\n    (2..Math.sqrt(n)).each do |i|\n        if n % i == 0\n            result += i\n            result += n / i if i != n / i\n        end\n    end\n    result\nend\n\ndef amicable_numbers(n)\n    result = 0\n    (2...n).each do |a|\n        b = d(a)\n        result += a if a != b && a == d(b)\n    end\n    result\nend",
        "Euler022": "def names_scores(names, queries)\n    s_names = names.sort\n    result = 0\n    s_names.each_with_index do |name, i|\n        x = 0\n        name.each_char do |c|\n            x += c.ord - 64\n        end\n        if queries.include?(name)\n            result += x * (i + 1)\n        end\n    end\n    result\nend",
        "Euler023": "def is_abundant(n)\n    if n < 12\n        false\n    end\n    sum_divisors = 1\n    (2..Math.sqrt(n)).each do |i|\n        if n % i == 0\n            sum_divisors += i\n            sum_divisors += n / i if i != n / i\n        end\n    end\n    sum_divisors > n\nend\n\ndef non_abundant_sums(n)\n    abundants = []\n    (12...n).each do |i|\n        abundants.push(i) if is_abundant(i)\n    end\n    abundant_sums = []\n    abundants.each do |i|\n        abundants.each do |j|\n            abundant_sums.push(i + j)\n        end\n    end\n    result = 0\n    (0...n).each do |i|\n        result += i if !abundant_sums.include?(i)\n    end\n    result\nend",
        "Euler024": "def lexicographic_permutations(n)\n    result = \"\"\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    x = n - 1\n    10.downto(1) do |i|\n        fact = 1\n        (1...i).each do |j|\n            fact *= j\n        end\n        idx = x / fact\n        result += digits[idx].to_s\n        digits.delete_at(idx)\n        x -= idx * fact\n    end\n    result\nend",
        "Euler025": "def n_digit_fibonacci_number(n)\n    a = [1]\n    b = [1]\n    i = 2\n    while b.length < n\n        carry = 0\n        c = b.clone\n        b.each_with_index do |_, j|\n            if j < a.length\n                b[j] = a[j] + b[j] + carry\n            else\n                b[j] = b[j] + carry\n            end\n            carry = b[j] / 10\n            b[j] = b[j] % 10\n        end\n        if carry != 0\n            b.push(carry)\n        end\n        a = c\n        i = i + 1\n    end\n    i\nend",
        "Euler026": "def reciprocal_cycles(n)\n    result = 0\n    max_length = 0\n    (1...n).each do |i|\n        remainders = []\n        remainder = 1\n        while remainder != 0 && !remainders.include?(remainder)\n            remainders.push(remainder)\n            remainder = (remainder * 10) % i\n        end\n        length = 0\n        if remainder != 0\n            length = remainders.length - remainders.index(remainder)\n        end\n        if length > max_length\n            max_length = length\n            result = i\n        end\n    end\n    result\nend",
        "Euler027": "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3..Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef quadratic_primes(n)\n    max_primes = 0\n    result = 0\n    (-n + 1...n).step(2) do |a|\n        (-n + 1...n).step(2) do |b|\n            x = 0\n            while true\n                if x * x + a * x + b < 2\n                    break\n                end\n                if !is_prime(x * x + a * x + b)\n                    break\n                end\n                x += 1\n            end\n            if x > max_primes\n                max_primes = x\n                result = a * b\n            end\n        end\n    end\n    result\nend",
        "Euler028": "def number_spiral_diagonals(n)\n    result = 1\n    (3..n).step(2) do |i|\n        result += 4 * i * i - 6 * i + 6\n    end\n    result\nend",
        "Euler029": "def distinct_powers(n)\n    result = 0\n    xs = Set.new\n    (2..n).each do |i|\n        primes = [2, 3, 5, 7]\n        powers = [0, 0, 0, 0]\n        num = i\n        primes.each_with_index do |p, j|\n            while num % p == 0\n                num /= p\n                powers[j] += 1\n            end\n        end\n        if num != 1\n            result += n - 1\n            next\n        end\n        (2..n).each do |j|\n            pstr = \"#{powers[0] * j}-#{powers[1] * j}-#{powers[2] * j}-#{powers[3] * j}\"\n            xs.add(pstr)\n        end\n    end\n    result += xs.size\n    result\nend",
        "Euler030": "def digit_nth_powers(n)\n    result = 0\n    (2..4 * 10 ** n).each do |i|\n        digits_sum = 0\n        i.to_s.each_char do |digit|\n            digits_sum += digit.to_i ** n\n        end\n        result += i if i == digits_sum\n    end\n    result\nend",
        "Euler031": "def coin_sums(n)\n    coins = [1, 2, 5, 10, 20, 50, 100, 200]\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    coins.each do |coin|\n        (coin..n).each do |i|\n            ways[i] += ways[i - coin]\n        end\n    end\n    ways[n]\nend",
        "Euler032": "def pandigital_products(n)\n    products = Set.new\n    s = \"\"\n    (1..n).each do |i|\n        s += i.to_s\n    end\n    (1...100).each do |a|\n        (1...10000).each do |b|\n            c = a * b\n            chars = (a.to_s + b.to_s + c.to_s).chars\n            chars.sort!\n            if chars.join(\"\") == s\n                products.add(c)\n            end\n        end\n    end\n    result = 0\n    products.each do |product|\n        result += product\n    end\n    result\nend",
        "Euler033": "def digit_canceling_fractions(m)\n    numer = 1\n    denom = 1\n    (10...m).each do |d|\n        (10...d).each do |n|\n            n0 = n % 10\n            n1 = n / 10\n            d0 = d % 10\n            d1 = d / 10\n            if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0)\n                numer *= n\n                denom *= d\n            end\n        end\n    end\n    a, b = numer, denom\n    while b != 0\n        a, b = b, a % b\n    end\n    denom / a\nend",
        "Euler034": "def digit_factorials(n)\n    result = 0\n    (3...n).each do |i|\n        fact_sum = 0\n        i.to_s.each_char do |digit|\n            fact = 1\n            (1..digit.to_i).each do |j|\n                fact *= j\n            end\n            fact_sum += fact\n        end\n        if i == fact_sum\n            result += i\n        end\n    end\n    result\nend",
        "Euler035": "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3..Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef circular_primes(n)\n    count = 0\n    (2...n).each do |i|\n        if is_prime(i)\n            rotations = Set.new\n            si = i.to_s\n            (0...si.length).each do |j|\n                rotations.add((si[j..-1] + si[0...j]).to_i)\n            end\n            flag = true\n            rotations.each do |x|\n                if !is_prime(x)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                count += 1\n            end\n        end\n    end\n    count\nend",
        "Euler036": "def is_palindrome(s)\n    (0...s.length / 2).each do |i|\n        if s[i] != s[s.length - i - 1]\n            return false\n        end\n    end\n    true\nend\n\ndef double_base_palindromes(n)\n    result = 0\n    (1...n).each do |i|\n        str_i = i.to_s\n        bin_i = i.to_s(2)\n        if is_palindrome(str_i) && is_palindrome(bin_i)\n            result += i\n        end\n    end\n    result\nend",
        "Euler037": "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3..Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef truncatable_primes(n)\n    result = 0\n    (10...n).each do |i|\n        if is_prime(i)\n            si = i.to_s\n            flag = true\n            (1...si.length).each do |j|\n                p1 = si[j..-1].to_i\n                p2 = si[0...-j].to_i\n                if !is_prime(p1) || !is_prime(p2)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                result += i\n            end\n        end\n    end\n    result\nend",
        "Euler038": "def pandigital_multiples(n)\n    result = -1\n    (2..n).each do |i|\n        cprod = ''\n        (1...10).each do |j|\n            cprod += (i * j).to_s\n            if cprod.length == 9\n                chars = cprod.split('').sort.join\n                if chars == '123456789'\n                    result = [result, cprod.to_i].max\n                    break\n                end\n            elsif cprod.length > 9\n                break\n            end\n        end\n    end\n    result\nend",
        "Euler039": "def integer_right_triangles(n)\n    max_sol = 0\n    result = 0\n    (3..n).each do |p|\n        sol = 0\n        (1...p / 2).each do |a|\n            (a...p / 2).each do |b|\n                c = p - a - b\n                if a * a + b * b == c * c\n                    sol += 1\n                end\n            end\n        end\n        if sol > max_sol\n            max_sol = sol\n            result = p\n        end\n    end\n    result\nend",
        "Euler040": "def champernowne_constant(b)\n    s = \"\"\n    (1..b**6).each do |i|\n        s += i.to_s\n    end\n    result = 1\n    (0..6).each do |i|\n        result *= s[b**i - 1].to_i\n    end\n    result\nend",
        "Euler041": "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3..Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef pandigital_prime(n)\n    (n - 1).downto(1) do |i|\n        if is_prime(i)\n            si = i.to_s\n            length = si.length\n            flag = true\n            (1..length).each do |j|\n                if !si.include?(j.to_s)\n                    flag = false\n                    break\n                end\n            end\n            if flag\n                return i\n            end\n        end\n    end\n    -1\nend",
        "Euler042": "def coded_triangle_numbers(words)\n    result = 0\n    words.each do |word|\n        value = 0\n        word.each_char do |c|\n            value += c.ord - 64\n        end\n        n = Math.sqrt(value * 2).to_i\n        if n * (n + 1) == value * 2\n            result += 1\n        end\n    end\n    result\nend",
        "Euler043": "def gen_permutations(s)\n    if s.length <= 1\n        return [s]\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0] + perm[i..-1])\n        end\n    end\n    result\nend\n\n\ndef sub_string_divisibility(n)\n    result = 0\n    primes = [2, 3, 5, 7, 11, 13, 17]\n    s = \"\"\n    (0..n).each do |i|\n        s += i.to_s\n    end\n    gen_permutations(s).each do |i|\n        flag = true\n        (1...n - 1).each do |j|\n            if i[j..j + 2].to_i % primes[j - 1] != 0\n                flag = false\n                break\n            end\n        end\n        if flag\n            result += i.to_i\n        end\n    end\n    result\nend",
        "Euler044": "def pentagon_numbers(n)\n    pentagon = {}\n    (1...n).each do |i|\n        pentagon[i * (3 * i - 1) / 2] = true\n    end\n    result = -1\n    pentagon.each do |j, _|\n        pentagon.each do |k, _|\n            if pentagon[j + k] && pentagon[k - j]\n                if result == -1 || k - j < result\n                    result = k - j\n                end\n            end\n        end\n    end\n    result\nend",
        "Euler045": "def triangular_pentagonal_and_hexagonal(n)\n    ps = Set.new\n    i = 1\n    c = (0.5 * i * (3 * i - 1)).to_i\n    while c < n\n        i += 1\n        ps.add(c)\n        c = (0.5 * i * (3 * i - 1)).to_i\n    end\n    i = 1\n    c = i * (2 * i - 1)\n    result = -1\n    while c < n\n        i += 1\n        if ps.include?(c)\n            result = c\n        end\n        c = i * (2 * i - 1)\n    end\n    result\nend",
        "Euler046": "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3..Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef goldbachs_other_conjecture(n)\n    result = -1\n    (9999...n).step(-2).each do |i|\n        upper = Math.sqrt(i / 2).to_i\n        flag = false\n        (0..upper).each do |j|\n            if is_prime(i - 2 * j * j)\n                flag = true\n                break\n            end\n        end\n        if !flag\n            result = i\n        end\n    end\n    result\nend",
        "Euler047": "def prime_factors(n)\n    num = n\n    factors = []\n    i = 2\n    while i * i <= num\n        if num % i != 0\n            i += 1\n        else\n            num /= i\n            factors.push(i)\n        end\n    end\n    if num > 1\n        factors.push(num)\n    end\n    factors.uniq.length\nend\n\ndef distinct_primes_factors(n)\n    (n...1000000).each do |i|\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4\n            return i\n        end\n    end\n    -1\nend",
        "Euler048": "def self_powers(n)\n    digits = [0] * 10\n    (1..n).each do |i|\n        temp_digits = [0] * 10\n        temp_digits[0] = 1\n        (0...i).each do |j|\n            carry = 0\n            (0...10).each do |k|\n                temp_digits[k] = temp_digits[k] * i + carry\n                carry = temp_digits[k] / 10\n                temp_digits[k] %= 10\n            end\n        end\n        (0...10).each do |j|\n            digits[j] += temp_digits[j]\n            if digits[j] >= 10\n                digits[j] -= 10\n                if j < 9\n                    digits[j + 1] += 1\n                end\n            end\n        end\n    end\n    result = \"\"\n    (9).downto(0).each do |i|\n        result += digits[i].to_s\n    end\n    result\nend",
        "Euler049": "def is_prime(n)\n    if n < 2\n        return false\n    end\n    if n == 2\n        return true\n    end\n    if n % 2 == 0\n        return false\n    end\n    (3..Math.sqrt(n)).step(2) do |i|\n        if n % i == 0\n            return false\n        end\n    end\n    true\nend\n\ndef gen_permutations(s)\n    if s.length <= 1\n        return [s]\n    end\n    result = []\n    gen_permutations(s[1..-1]).each do |perm|\n        (0...s.length).each do |i|\n            result.push(perm[0...i] + s[0] + perm[i..-1])\n        end\n    end\n    result\nend\n\ndef prime_permutations(n)\n    (n).downto(999).each do |i|\n        if is_prime(i)\n            permutations = gen_permutations(i.to_s)\n            candidates = Set.new\n            permutations.each do |j|\n                candidate = j.to_i\n                if candidate > i && is_prime(candidate)\n                    candidates.add(candidate)\n                end\n            end\n            candidates.each do |m|\n                if candidates.include?(m + (m - i))\n                    return i.to_s + m.to_s + (m + (m - i)).to_s\n                end\n            end\n        end\n    end\n    \"\"\nend",
        "Euler050": "def consecutive_prime_sum(limit)\n    sieve = Array.new(limit, true)\n    primes = []\n    (2...limit).each do |i|\n        if sieve[i]\n            primes.push(i)\n            (i * 2...limit).step(i) do |j|\n                sieve[j] = false\n            end\n        end\n    end\n    max_length = 0\n    max_prime = 0\n    primes.each_with_index do |_, i|\n        (i + max_length...primes.length).each do |j|\n            s = 0\n            (i...j).each do |k|\n                s += primes[k]\n            end\n            if s >= limit\n                break\n            end\n            if sieve[s] && j - i > max_length\n                max_length = j - i\n                max_prime = s\n            end\n        end\n    end\n    max_prime\nend"
    },
    "rust": {
        "Euler001": "fn multiples_of_3_and_5(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..n {\n        if i % 3 == 0 || i % 5 == 0 {\n            result += i;\n        }\n    }\n    result\n}",
        "Euler002": "fn even_fibonacci_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut a = 1;\n    let mut b = 2;\n    while a < n {\n        if a % 2 == 0 {\n            result += a;\n        }\n        let tmp = a;\n        a = b;\n        b = tmp + b;\n    }\n    result\n}",
        "Euler003": "fn largest_prime_factor(n: i32) -> i32 {\n    let mut result = n;\n    let mut i = 2;\n    while i * i <= result {\n        if result % i != 0 {\n            i += 1;\n        } else {\n            result /= i;\n        }\n    }\n    result\n}",
        "Euler004": "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s.chars().nth(i).unwrap() != s.chars().nth(s.len() - i - 1).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n\nfn largest_palindrome_product(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 100..1000 {\n        for j in i..1000 {\n            let prod = i * j;\n            if is_palindrome(&prod.to_string()) && prod > result && prod < n {\n                result = prod;\n            }\n        }\n    }\n    result\n}",
        "Euler005": "fn smallest_multiple(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 1..=n {\n        if result % i != 0 {\n            for j in 1..=n {\n                if (result * j) % i == 0 {\n                    result *= j;\n                    break;\n                }\n            }\n        }\n    }\n    result\n}",
        "Euler006": "fn sum_square_difference(n: i32) -> i32 {\n    let mut sqr_sum = 0;\n    let mut num_sum = 0;\n    for i in 1..=n {\n        sqr_sum += i * i;\n        num_sum += i;\n    }\n    num_sum * num_sum - sqr_sum\n}",
        "Euler007": "fn nth_prime(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while primes.len() < n as usize {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    primes[primes.len() - 1]\n}",
        "Euler008": "fn largest_product_in_a_series(s: &String, k: i32) -> i32 {\n    let mut result = 0;\n    for i in 0..s.len() - k as usize {\n        let mut product = 1;\n        for j in 0..k as usize {\n            product *= s.chars().nth(i + j).unwrap().to_digit(10).unwrap() as i32;\n        }\n        result = result.max(product);\n    }\n    result\n}",
        "Euler009": "fn special_pythagorean_triplet(n: i32) -> i32 {\n    for a in 1..n {\n        for b in a..n {\n            let c = n - a - b;\n            if a * a + b * b == c * c {\n                return a * b * c;\n            }\n        }\n    }\n    -1\n}",
        "Euler010": "fn summation_of_primes(n: i32) -> i32 {\n    let mut primes = vec![2];\n    let mut i = 3;\n    while i <= n {\n        for p in &primes {\n            if i % p == 0 {\n                break;\n            }\n            if p * p > i {\n                primes.push(i);\n                break;\n            }\n        }\n        i += 2;\n    }\n    let mut result = 0;\n    for prime in &primes {\n        result += prime;\n    }\n    result\n}",
        "Euler011": "fn largest_product_in_a_grid(grid: &Vec<Vec<i32>>) -> i32 {\n    let mut result = 0;\n    for i in 0..grid.len() - 3 {\n        for j in 0..grid[i].len() - 3 {\n            let mut p1 = 1;\n            let mut p2 = 1;\n            let mut p3 = 1;\n            let mut p4 = 1;\n            for k in 0..4 {\n                p1 *= grid[i + k][j];\n            }\n            for k in 0..4 {\n                p2 *= grid[i][j + k];\n            }\n            for k in 0..4 {\n                p3 *= grid[i + k][j + k];\n            }\n            for k in 0..4 {\n                p4 *= grid[i + k][j + 3 - k];\n            }\n            result = vec![result, p1, p2, p3, p4].into_iter().max().unwrap();\n        }\n    }\n    result\n}",
        "Euler012": "fn highly_divisible_triangular_number(n: i32) -> i32 {\n    for i in 1..100000000 {\n        let result = i * (i + 1) / 2;\n        let mut count = 0;\n        for j in 1..=(result as f64).sqrt() as i32 {\n            if result % j == 0 {\n                count += 2;\n            }\n            if j * j == result {\n                count -= 1;\n            }\n        }\n        if count > n {\n            return result;\n        }\n    }\n    -1\n}",
        "Euler013": "fn large_sum(numbers: &Vec<String>) -> String {\n    let mut digits = vec![0; 60];\n    for i in 0..50 {\n        let mut tmp = 0;\n        for num in numbers.iter() {\n            tmp += num.chars().nth(49 - i).unwrap().to_digit(10).unwrap();\n        }\n        for j in i..60 {\n            digits[j] += tmp % 10;\n            if digits[j] >= 10 {\n                digits[j + 1] += digits[j] / 10;\n                digits[j] %= 10;\n            }\n            tmp /= 10;\n            if tmp == 0 {\n                break;\n            }\n        }\n    }\n    for i in (0..60).rev() {\n        if digits[i] != 0 {\n            let mut result = String::new();\n            for j in (i - 9..=i).rev() {\n                result += &digits[j].to_string();\n            }\n            return result;\n        }\n    }\n    String::new()\n}",
        "Euler014": "fn longest_collatz_sequence(n: i32) -> i32 {\n    let mut longest = 0;\n    let mut result = 0;\n    for i in 1..n {\n        let mut chain = 1;\n        let mut num = i;\n        while num != 1 {\n            if num % 2 == 0 {\n                num = num / 2;\n            } else {\n                num = 3 * num + 1;\n            }\n            chain += 1;\n        }\n        if chain > longest {\n            longest = chain;\n            result = i;\n        }\n    }\n    result\n}",
        "Euler015": "fn lattice_paths(m: i32, n: i32) -> i32 {\n    let mut grid = vec![vec![0; (n + 1) as usize]; (m + 1) as usize];\n    for i in 0..=m {\n        grid[i as usize][0] = 1;\n    }\n    for j in 0..=n {\n        grid[0][j as usize] = 1;\n    }\n    for i in 1..=m {\n        for j in 1..=n {\n            grid[i as usize][j as usize] = grid[(i - 1) as usize][j as usize] + grid[i as usize][(j - 1) as usize];\n        }\n    }\n    grid[m as usize][n as usize]\n}",
        "Euler016": "fn power_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![2];\n    for _ in 1..n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            let temp = digits[j] * 2 + carry;\n            digits[j] = temp % 10;\n            carry = temp / 10;\n        }\n        if carry != 0 {\n            digits.push(carry);\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
        "Euler017": "fn number_to_words(n: i32) -> String {\n    let ones = vec![\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    let teens = vec![\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    let tens = vec![\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    if n == 1000 {\n        \"one thousand\".to_string()\n    } else if n >= 100 {\n        if n % 100 == 0 {\n            ones[(n / 100) as usize].to_string() + \" hundred\"\n        } else {\n            ones[(n / 100) as usize].to_string() + \" hundred and \" + &number_to_words(n % 100)\n        }\n    } else if n >= 20 {\n        let mut suf = \"\".to_string();\n        if n % 10 != 0 {\n            suf = \" \".to_string() + &ones[(n % 10) as usize];\n        }\n        tens[(n / 10) as usize].to_string() + &suf\n    } else if n >= 10 {\n        teens[(n - 10) as usize].to_string()\n    } else {\n        ones[n as usize].to_string()\n    }\n}",
        "Euler018": "fn maximum_path_sum_i(triangle: &Vec<Vec<i32>>) -> i32 {\n    let mut curr = triangle.last().unwrap().clone();\n    for i in (0..triangle.len() - 1).rev() {\n        let mut next = triangle[i].clone();\n        for j in 0..next.len() {\n            next[j] += curr[j].max(curr[j + 1]);\n        }\n        curr = next;\n    }\n    curr[0]\n}",
        "Euler019": "fn counting_sundays(y1: i32, y2: i32) -> i32 {\n    let mut day = 0;\n    let mut count = 0;\n    for year in 1900..=y2 {\n        for month in 1..=12 {\n            if year >= y1 && day % 7 == 6 {\n                count += 1;\n            }\n            if month == 4 || month == 6 || month == 9 || month == 11 {\n                day += 30;\n            } else if month == 2 {\n                if year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) {\n                    day += 29;\n                } else {\n                    day += 28;\n                }\n            } else {\n                day += 31;\n            }\n        }\n    }\n    count\n}",
        "Euler020": "fn factorial_digit_sum(n: i32) -> i32 {\n    let mut digits = vec![1];\n    for i in 1..=n {\n        let mut carry = 0;\n        for j in 0..digits.len() {\n            digits[j] = digits[j] * i + carry;\n            carry = digits[j] / 10;\n            digits[j] %= 10;\n        }\n        while carry != 0 {\n            digits.push(carry % 10);\n            carry /= 10;\n        }\n    }\n    let mut result = 0;\n    for digit in digits {\n        result += digit;\n    }\n    result\n}",
        "Euler021": "fn d(n: i32) -> i32 {\n    let mut result = 1;\n    for i in 2..=(n as f64).sqrt() as i32 {\n        if n % i == 0 {\n            result += i;\n            if i != n / i {\n                result += n / i;\n            }\n        }\n    }\n    result\n}\n\nfn amicable_numbers(n: i32) -> i32 {\n    let mut result = 0;\n    for a in 2..n {\n        let b = d(a);\n        if a != b && a == d(b) {\n            result += a;\n        }\n    }\n    result\n}",
        "Euler022": "fn names_scores(names: &Vec<String>, queries: &Vec<String>) -> i32 {\n    let mut s_names = names.clone();\n    s_names.sort();\n    let mut result = 0;\n    for (i, name) in s_names.iter().enumerate() {\n        let mut x = 0;\n        for c in name.chars() {\n            x += c as i32 - 64;\n        }\n        if queries.contains(name) {\n            result += x * (i as i32 + 1);\n        }\n    }\n    result\n}",
        "Euler023": "fn is_abundant(n: i32) -> bool {\n    if n < 12 {\n        return false;\n    }\n    let mut sum_divisors = 1;\n    for i in 2..=(n as f64).sqrt() as i32 {\n        if n % i == 0 {\n            sum_divisors += i;\n            if i != n / i {\n                sum_divisors += n / i;\n            }\n        }\n    }\n    sum_divisors > n\n}\n\nfn non_abundant_sums(n: i32) -> i32 {\n    let mut abundants = vec![];\n    for i in 12..n {\n        if is_abundant(i) {\n            abundants.push(i);\n        }\n    }\n    let mut abundant_sums = vec![];\n    for i in &abundants {\n        for j in &abundants {\n            abundant_sums.push(i + j);\n        }\n    }\n    let mut result = 0;\n    for i in 0..n {\n        if !abundant_sums.contains(&i) {\n            result += i;\n        }\n    }\n    result\n}",
        "Euler024": "fn lexicographic_permutations(n: i32) -> String {\n    let mut result = String::new();\n    let mut digits = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut x = n - 1;\n    for i in (1..11).rev() {\n        let mut fact = 1;\n        for j in 1..i {\n            fact *= j;\n        }\n        let idx = x / fact;\n        result.push_str(&digits[idx as usize].to_string());\n        digits.remove(idx as usize);\n        x -= idx * fact;\n    }\n    result\n}",
        "Euler025": "fn n_digit_fibonacci_number(n: i32) -> i32 {\n    let mut a = vec![1];\n    let mut b = vec![1];\n    let mut i = 2;\n    while b.len() < n as usize {\n        let mut carry = 0;\n        let c = b.clone();\n        for j in 0..b.len() {\n            if j < a.len() {\n                b[j] = a[j] + b[j] + carry;\n            } else {\n                b[j] = b[j] + carry;\n            }\n            carry = b[j] / 10;\n            b[j] = b[j] % 10;\n        }\n        if carry != 0 {\n            b.push(carry);\n        }\n        a = c;\n        i = i + 1;\n    }\n    i\n}",
        "Euler026": "fn reciprocal_cycles(n: i32) -> i32 {\n    let mut result = 0;\n    let mut max_length = 0;\n    for i in 1..n {\n        let mut remainders = vec![];\n        let mut remainder = 1;\n        while remainder != 0 && !remainders.contains(&remainder) {\n            remainders.push(remainder);\n            remainder = (remainder * 10) % i;\n        }\n        let mut length = 0;\n        if remainder != 0 {\n            length = remainders.len() - remainders.iter().position(|&x| x == remainder).unwrap();\n        }\n        if length > max_length {\n            max_length = length;\n            result = i;\n        }\n    }\n    result\n}",
        "Euler027": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn quadratic_primes(n: i32) -> i32 {\n    let mut max_primes = 0;\n    let mut result = 0;\n    for a in (-n + 1..n).step_by(2) {\n        for b in (-n + 1..n).step_by(2) {\n            let mut x = 0;\n            while x * x + a * x + b >= 2 {\n                if !is_prime(x * x + a * x + b) {\n                    break;\n                }\n                x += 1;\n            }\n            if x > max_primes {\n                max_primes = x;\n                result = a * b;\n            }\n        }\n    }\n    result\n}",
        "Euler028": "fn number_spiral_diagonals(n: i32) -> i32 {\n    let mut result = 1;\n    for i in (3..=n).step_by(2) {\n        result += 4 * i * i - 6 * i + 6;\n    }\n    result\n}",
        "Euler029": "fn distinct_powers(n: i32) -> i32 {\n    let mut result = 0;\n    let mut xs = HashSet::new();\n    for i in 2..=n {\n        let primes = vec![2, 3, 5, 7];\n        let mut powers = vec![0, 0, 0, 0];\n        let mut num = i;\n        for j in 0..primes.len() {\n            while num % primes[j] == 0 {\n                num /= primes[j];\n                powers[j] += 1;\n            }\n        }\n        if num != 1 {\n            result += n - 1;\n            continue;\n        }\n        for j in 2..=n {\n            let pstr = format!(\"{}-{}-{}-{}\", powers[0] * j, powers[1] * j, powers[2] * j, powers[3] * j);\n            xs.insert(pstr);\n        }\n    }\n    result += xs.len() as i32;\n    result\n}",
        "Euler030": "fn digit_nth_powers(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 2..4 * (10 as i32).pow(n as u32) {\n        let mut digits_sum = 0;\n        for digit in i.to_string().chars() {\n            digits_sum += (digit.to_digit(10).unwrap() as i32).pow(n as u32);\n        }\n        if i == digits_sum {\n            result += i;\n        }\n    }\n    result\n}",
        "Euler031": "fn coin_sums(n: i32) -> i32 {\n    let coins = vec![1, 2, 5, 10, 20, 50, 100, 200];\n    let mut ways = vec![0; (n + 1) as usize];\n    ways[0] = 1;\n    for coin in coins {\n        for i in coin..=n {\n            ways[i as usize] += ways[(i - coin) as usize];\n        }\n    }\n    ways[n as usize]\n}",
        "Euler032": "fn pandigital_products(n: i32) -> i32 {\n    let mut products = HashSet::new();\n    let mut s = String::new();\n    for i in 1..=n {\n        s.push_str(&i.to_string());\n    }\n    for a in 1..100 {\n        for b in 1..10000 {\n            let c = a * b;\n            let mut chars = (a.to_string() + &b.to_string() + &c.to_string()).chars().collect::<Vec<char>>();\n            chars.sort();\n            if chars.into_iter().collect::<String>() == s {\n                products.insert(c);\n            }\n        }\n    }\n    let mut result = 0;\n    for product in products {\n        result += product;\n    }\n    result\n}",
        "Euler033": "fn digit_canceling_fractions(m: i32) -> i32 {\n    let mut numer = 1;\n    let mut denom = 1;\n    for d in 10..m {\n        for n in 10..d {\n            let n0 = n % 10;\n            let n1 = n / 10;\n            let d0 = d % 10;\n            let d1 = d / 10;\n            if (n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0) {\n                numer *= n;\n                denom *= d;\n            }\n        }\n    }\n    let mut a = numer;\n    let mut b = denom;\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    denom / a\n}",
        "Euler034": "fn digit_factorials(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 3..n {\n        let mut fact_sum = 0;\n        for digit in i.to_string().chars() {\n            let mut fact = 1;\n            for j in 1..=digit.to_digit(10).unwrap() {\n                fact *= j;\n            }\n            fact_sum += fact;\n        }\n        if i == fact_sum as i32 {\n            result += i;\n        }\n    }\n    result\n}",
        "Euler035": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn circular_primes(n: i32) -> i32 {\n    let mut count = 0;\n    for i in 2..n {\n        if is_prime(i) {\n            let mut rotations = HashSet::new();\n            let si = i.to_string();\n            for j in 0..si.len() {\n                rotations.insert((si[j..].to_string() + &si[..j]).parse().unwrap());\n            }\n            let mut flag = true;\n            for x in rotations {\n                if !is_prime(x) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
        "Euler036": "fn is_palindrome(s: &String) -> bool {\n    for i in 0..s.len() / 2 {\n        if s.chars().nth(i).unwrap() != s.chars().nth(s.len() - i - 1).unwrap() {\n            return false;\n        }\n    }\n    true\n}\n\nfn double_base_palindromes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 1..n {\n        let str_i = i.to_string();\n        let bin_i = format!(\"{:b}\", i);\n        if is_palindrome(&str_i) && is_palindrome(&bin_i) {\n            result += i;\n        }\n    }\n    result\n}",
        "Euler037": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn truncatable_primes(n: i32) -> i32 {\n    let mut result = 0;\n    for i in 10..n {\n        if is_prime(i) {\n            let si = i.to_string();\n            let mut flag = true;\n            for j in 1..si.len() {\n                let p1 = si[j..].parse().unwrap();\n                let p2 = si[..si.len() - j].parse().unwrap();\n                if !is_prime(p1) || !is_prime(p2) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                result += i;\n            }\n        }\n    }\n    result\n}",
        "Euler038": "fn pandigital_multiples(n: i32) -> i32 {\n    let mut result = -1;\n    for i in 2..=n {\n        let mut cprod = String::new();\n        for j in 1..10 {\n            cprod += &(i * j).to_string();\n            if cprod.len() == 9 {\n                let mut chars: Vec<char> = cprod.chars().collect();\n                chars.sort();\n                if chars.iter().collect::<String>() == \"123456789\" {\n                    result = result.max(cprod.parse::<i32>().unwrap());\n                    break;\n                }\n            } else if cprod.len() > 9 {\n                break;\n            }\n        }\n    }\n    result\n}",
        "Euler039": "fn integer_right_triangles(n: i32) -> i32 {\n    let mut max_sol = 0;\n    let mut result = 0;\n    for p in 3..=n {\n        let mut sol = 0;\n        for a in 1..p / 2 {\n            for b in a..p / 2 {\n                let c = p - a - b;\n                if a * a + b * b == c * c {\n                    sol += 1;\n                }\n            }\n        }\n        if sol > max_sol {\n            max_sol = sol;\n            result = p;\n        }\n    }\n    result\n}",
        "Euler040": "fn champernowne_constant(b: i32) -> i32 {\n    let mut s = String::new();\n    for i in 1..i32::pow(b, 6) {\n        s += &i.to_string();\n    }\n    let mut result = 1;\n    for i in 0..7 {\n        result *= s.chars().nth(i32::pow(b, i) as usize - 1).unwrap().to_digit(10).unwrap() as i32;\n    }\n    result\n}",
        "Euler041": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn pandigital_prime(n: i32) -> i32 {\n    for i in (1..n).rev() {\n        if is_prime(i) {\n            let si = i.to_string();\n            let length = si.len();\n            let mut flag = true;\n            for j in 1..=length {\n                if !si.contains(&j.to_string()) {\n                    flag = false;\n                    break;\n                }\n            }\n            if flag {\n                return i;\n            }\n        }\n    }\n    -1\n}",
        "Euler042": "fn coded_triangle_numbers(words: &Vec<String>) -> i32 {\n    let mut result = 0;\n    for word in words {\n        let mut value = 0;\n        for c in word.chars() {\n            value += c as i32 - 64;\n        }\n        let n = ((value * 2) as f64).sqrt() as i32;\n        if n * (n + 1) == value * 2 {\n            result += 1;\n        }\n    }\n    result\n}",
        "Euler043": "fn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.clone()];\n    }\n    let mut result = vec![];\n    for perm in gen_permutations(&s[1..].to_string()) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn sub_string_divisibility(n: i32) -> i32 {\n    let mut result = 0;\n    let primes = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut s = String::new();\n    for i in 0..=n {\n        s += &i.to_string();\n    }\n    for i in gen_permutations(&s) {\n        let mut flag = true;\n        for j in 1..(n - 1) as usize {\n            if i[j..j + 3].parse::<i32>().unwrap() % primes[j - 1] != 0 {\n                flag = false;\n                break;\n            }\n        }\n        if flag {\n            result += i.parse::<i32>().unwrap();\n        }\n    }\n    result\n}",
        "Euler044": "fn pentagon_numbers(n: i32) -> i32 {\n    let mut pentagon = HashSet::new();\n    for i in 1..n {\n        pentagon.insert(i * (3 * i - 1) / 2);\n    }\n    let mut result = -1;\n    for &j in &pentagon {\n        for &k in &pentagon {\n            if pentagon.contains(&(j + k)) && pentagon.contains(&(k - j)) {\n                if result == -1 || k - j < result {\n                    result = k - j;\n                }\n            }\n        }\n    }\n    result\n}",
        "Euler045": "fn triangular_pentagonal_and_hexagonal(n: i32) -> i32 {\n    let mut ps = HashSet::new();\n    let mut i = 1;\n    let mut c = (0.5 * i as f64 * (3 * i - 1) as f64) as i32;\n    while c < n {\n        i += 1;\n        ps.insert(c);\n        c = (0.5 * i as f64 * (3 * i - 1) as f64) as i32;\n    }\n    i = 1;\n    c = i * (2 * i - 1);\n    let mut result = -1;\n    while c < n {\n        i += 1;\n        if ps.contains(&c) {\n            result = c;\n        }\n        c = i * (2 * i - 1);\n    }\n    result\n}",
        "Euler046": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn goldbachs_other_conjecture(n: i32) -> i32 {\n    let mut result = -1;\n    for i in (n + 1..=9999).rev().step_by(2) {\n        let upper = ((i / 2) as f64).sqrt() as i32;\n        let mut flag = false;\n        for j in 0..=upper {\n            if is_prime(i - 2 * j * j) {\n                flag = true;\n                break;\n            }\n        }\n        if !flag {\n            result = i;\n        }\n    }\n    result\n}",
        "Euler047": "fn prime_factors(n: i32) -> i32 {\n    let mut num = n;\n    let mut factors = vec![];\n    let mut i = 2;\n    while i * i <= num {\n        if num % i != 0 {\n            i += 1;\n        } else {\n            num /= i;\n            factors.push(i);\n        }\n    }\n    if num > 1 {\n        factors.push(num);\n    }\n    factors.into_iter().collect::<HashSet<_>>().len() as i32\n}\n\nfn distinct_primes_factors(n: i32) -> i32 {\n    for i in n..1000000 {\n        if prime_factors(i) == 4 && prime_factors(i + 1) == 4 && prime_factors(i + 2) == 4 && prime_factors(i + 3) == 4 {\n            return i;\n        }\n    }\n    -1\n}",
        "Euler048": "fn self_powers(n: i32) -> String {\n    let mut digits = [0; 10];\n    for i in 1..=n {\n        let mut temp_digits = [0; 10];\n        temp_digits[0] = 1;\n        for j in 0..i {\n            let mut carry = 0;\n            for k in 0..10 {\n                temp_digits[k] = temp_digits[k] * i + carry;\n                carry = temp_digits[k] / 10;\n                temp_digits[k] %= 10;\n            }\n        }\n        for j in 0..10 {\n            digits[j] += temp_digits[j];\n            if digits[j] >= 10 {\n                digits[j] -= 10;\n                if j < 9 {\n                    digits[j + 1] += 1;\n                }\n            }\n        }\n    }\n    let mut result = String::new();\n    for i in (0..10).rev() {\n        result += &digits[i].to_string();\n    }\n    result\n}",
        "Euler049": "fn is_prime(n: i32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn gen_permutations(s: &String) -> Vec<String> {\n    if s.len() <= 1 {\n        return vec![s.clone()];\n    }\n    let mut result = vec![];\n    for perm in gen_permutations(&s[1..].to_string()) {\n        for i in 0..s.len() {\n            result.push(perm[..i].to_string() + &s[0..1] + &perm[i..]);\n        }\n    }\n    result\n}\n\nfn prime_permutations(n: i32) -> String {\n    for i in (999..n).rev() {\n        if is_prime(i) {\n            let permutations = gen_permutations(&i.to_string());\n            let mut candidates = std::collections::HashSet::new();\n            for j in permutations {\n                let candidate = j.parse::<i32>().unwrap();\n                if candidate > i && is_prime(candidate) {\n                    candidates.insert(candidate);\n                }\n            }\n            for m in &candidates {\n                if candidates.contains(&(m + (m - i))) {\n                    return i.to_string() + &m.to_string() + &(m + (m - i)).to_string();\n                }\n            }\n        }\n    }\n    \"\".to_string()\n}",
        "Euler050": "fn consecutive_prime_sum(limit: i32) -> i32 {\n    let mut sieve = vec![true; limit as usize];\n    let mut primes = vec![];\n    for i in 2..limit {\n        if sieve[i as usize] {\n            primes.push(i);\n            for j in (i * 2..limit).step_by(i as usize) {\n                sieve[j as usize] = false;\n            }\n        }\n    }\n    let mut max_length = 0;\n    let mut max_prime = 0;\n    for i in 0..primes.len() {\n        for j in i + max_length..primes.len() {\n            let mut s = 0;\n            for k in i..j {\n                s += primes[k];\n            }\n            if s >= limit {\n                break;\n            }\n            if sieve[s as usize] && j - i > max_length {\n                max_length = j - i;\n                max_prime = s;\n            }\n        }\n    }\n    max_prime\n}"
    },
    "scala": {
        "Euler001": "def multiplesOf3And5(n: Int): Int = {\n    var result = 0\n    for (i <- 0 until n) {\n        if (i % 3 == 0 || i % 5 == 0) {\n            result += i\n        }\n    }\n    result\n}",
        "Euler002": "def evenFibonacciNumbers(n: Int): Int = {\n    var result = 0\n    var a = 1\n    var b = 2\n    while (a < n) {\n        if (a % 2 == 0) {\n            result += a\n        }\n        val tmp = a\n        a = b\n        b = tmp + b\n    }\n    result\n}",
        "Euler003": "def largestPrimeFactor(n: Int): Int = {\n    var result = n\n    var i = 2\n    while (i * i <= result) {\n        if (result % i != 0) {\n            i += 1\n        } else {\n            result /= i\n        }\n    }\n    result\n}",
        "Euler004": "def isPalindrome(s: String): Boolean = {\n    for (i <- 0 until s.length / 2) {\n        if (s(i) != s(s.length - i - 1)) {\n            return false\n        }\n    }\n    true\n}\n\ndef largestPalindromeProduct(n: Int): Int = {\n    var result = 0\n    for (i <- 100 until 1000) {\n        for (j <- i until 1000) {\n            val prod = i * j\n            if (isPalindrome(prod.toString) && prod > result && prod < n) {\n                result = prod\n            }\n        }\n    }\n    result\n}",
        "Euler005": "def smallestMultiple(n: Int): Int = {\n    var result = 1\n    for (i <- 1 to n) {\n        if (result % i != 0) {\n            breakable {\n                for (j <- 1 to n) {\n                    if ((result * j) % i == 0) {\n                        result *= j\n                        break\n                    }\n                }\n            }\n        }\n    }\n    result\n}",
        "Euler006": "def sumSquareDifference(n: Int): Int = {\n    var sqrSum = 0\n    var numSum = 0\n    for (i <- 1 to n) {\n        sqrSum += i * i\n        numSum += i\n    }\n    numSum * numSum - sqrSum\n}",
        "Euler007": "def nthPrime(n: Int): Int = {\n    var primes = mutable.Buffer(2)\n    var i = 3\n    while (primes.length < n) {\n        breakable {\n            for (p <- primes) {\n                if (i % p == 0) {\n                    break\n                }\n                if (p * p > i) {\n                    primes += i\n                    break\n                }\n            }\n        }\n        i += 2\n    }\n    primes.last\n}",
        "Euler008": "def largestProductInASeries(s: String, k: Int): Int = {\n    var result = 0\n    for (i <- 0 until s.length - k) {\n        var product = 1\n        for (j <- 0 until k) {\n            product *= s(i + j).asDigit\n        }\n        result = result.max(product)\n    }\n    result\n}",
        "Euler009": "def specialPythagoreanTriplet(n: Int): Int = {\n    for (a <- 1 until n) {\n        for (b <- a until n) {\n            val c = n - a - b\n            if (a * a + b * b == c * c) {\n                return a * b * c\n            }\n        }\n    }\n    -1\n}",
        "Euler010": "def summationOfPrimes(n: Int): Int = {\n    var primes = mutable.Buffer(2)\n    var i = 3\n    while (i <= n) {\n        var isPrime = true\n        breakable {\n            for (p <- primes) {\n                if (i % p == 0) {\n                    isPrime = false\n                    break\n                }\n                if (p * p > i) {\n                    break\n                }\n            }\n        }\n        if (isPrime) {\n            primes += i\n        }\n        i += 2\n    }\n    var result = 0\n    for (prime <- primes) {\n        result += prime\n    }\n    result\n}",
        "Euler011": "def largestProductInAGrid(grid: collection.Seq[collection.Seq[Int]]): Int = {\n    var result = 0\n    for (i <- 0 until grid.length - 3) {\n        for (j <- 0 until grid(i).length - 3) {\n            var p1 = 1\n            var p2 = 1\n            var p3 = 1\n            var p4 = 1\n            for (k <- 0 until 4) {\n                p1 *= grid(i + k)(j)\n            }\n            for (k <- 0 until 4) {\n                p2 *= grid(i)(j + k)\n            }\n            for (k <- 0 until 4) {\n                p3 *= grid(i + k)(j + k)\n            }\n            for (k <- 0 until 4) {\n                p4 *= grid(i + k)(j + 3 - k)\n            }\n            result = List(result, p1, p2, p3, p4).max\n        }\n    }\n    result\n}",
        "Euler012": "def highlyDivisibleTriangularNumber(n: Int): Int = {\n    for (i <- 1 until 100000000) {\n        val result = i * (i + 1) / 2\n        var count = 0\n        for (j <- 1 to math.sqrt(result).toInt) {\n            if (result % j == 0) {\n                count += 2\n            }\n            if (j * j == result) {\n                count -= 1\n            }\n        }\n        if (count > n) {\n            return result\n        }\n    }\n    -1\n}",
        "Euler013": "def largeSum(numbers: collection.Seq[String]): String = {\n    val digits = Array.fill(60)(0)\n    for (i <- 0 until 50) {\n        var tmp = 0\n        for (num <- numbers) {\n            tmp += num(49 - i).asDigit\n        }\n        breakable {\n            for (j <- i until 60) {\n                digits(j) += tmp % 10\n                if (digits(j) >= 10) {\n                    digits(j + 1) += digits(j) / 10\n                    digits(j) %= 10\n                }\n                tmp /= 10\n                if (tmp == 0) {\n                    break\n                }\n            }\n        }\n    }\n    for (i <- 59 to 0 by -1) {\n        if (digits(i) != 0) {\n            val result = new StringBuilder\n            for (j <- i to i - 9 by -1) {\n                result.append(digits(j))\n            }\n            return result.toString\n        }\n    }\n    \"\"\n}",
        "Euler014": "def longestCollatzSequence(n: Int): Int = {\n    var longest = 0\n    var result = 0\n    for (i <- 1 until n) {\n        var chain = 1\n        var num = i\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2\n            } else {\n                num = 3 * num + 1\n            }\n            chain += 1\n        }\n        if (chain > longest) {\n            longest = chain\n            result = i\n        }\n    }\n    result\n}",
        "Euler015": "def latticePaths(m: Int, n: Int): Int = {\n    val grid = Array.ofDim[Int](m + 1, n + 1)\n    for (i <- 0 to m) {\n        grid(i)(0) = 1\n    }\n    for (j <- 0 to n) {\n        grid(0)(j) = 1\n    }\n    for (i <- 1 to m) {\n        for (j <- 1 to n) {\n            grid(i)(j) = grid(i - 1)(j) + grid(i)(j - 1)\n        }\n    }\n    grid(m)(n)\n}",
        "Euler016": "def powerDigitSum(n: Int): Int = {\n    var digits = mutable.Buffer(2)\n    for (i <- 1 until n) {\n        var carry = 0\n        for (j <- digits.indices) {\n            val temp = digits(j) * 2 + carry\n            digits(j) = temp % 10\n            carry = temp / 10\n        }\n        if (carry != 0) {\n            digits += carry\n        }\n    }\n    var result = 0\n    for (digit <- digits) {\n        result += digit\n    }\n    result\n}",
        "Euler017": "def numberToWords(n: Int): String = {\n    val ones = Array(\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\n    val teens = Array(\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\")\n    val tens = Array(\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\")\n    if (n == 1000) {\n        \"one thousand\"\n    } else if (n >= 100) {\n        if (n % 100 == 0) {\n            ones(n / 100) + \" hundred\"\n        } else {\n            ones(n / 100) + \" hundred and \" + numberToWords(n % 100)\n        }\n    } else if (n >= 20) {\n        val suf = if (n % 10 != 0) \" \" + ones(n % 10) else \"\"\n        tens(n / 10) + suf\n    } else if (n >= 10) {\n        teens(n - 10)\n    } else {\n        ones(n)\n    }\n}",
        "Euler018": "def maximumPathSumI(triangle: collection.Seq[collection.Seq[Int]]): Int = {\n    var curr = triangle.last.to(mutable.Buffer)\n    for (i <- triangle.length - 2 to 0 by -1) {\n        val next = triangle(i).to(mutable.Buffer)\n        for (j <- 0 until next.length) {\n            next(j) += curr(j).max(curr(j + 1))\n        }\n        curr = next\n    }\n    curr.head\n}",
        "Euler019": "def countingSundays(y1: Int, y2: Int): Int = {\n    var day = 0\n    var count = 0\n    for (year <- 1900 to y2) {\n        for (month <- 1 to 12) {\n            if (year >= y1 && day % 7 == 6) {\n                count += 1\n            }\n            if (month == 4 || month == 6 || month == 9 || month == 11) {\n                day += 30\n            } else if (month == 2) {\n                if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n                    day += 29\n                } else {\n                    day += 28\n                }\n            } else {\n                day += 31\n            }\n        }\n    }\n    count\n}",
        "Euler020": "def factorialDigitSum(n: Int): Int = {\n    var digits = mutable.Buffer(1)\n    for (i <- 1 to n) {\n        var carry = 0\n        for (j <- digits.indices) {\n            digits(j) = digits(j) * i + carry\n            carry = digits(j) / 10\n            digits(j) = digits(j) % 10\n        }\n        while (carry != 0) {\n            digits += carry % 10\n            carry /= 10\n        }\n    }\n    var result = 0\n    for (digit <- digits) {\n        result += digit\n    }\n    result\n}",
        "Euler021": "def d(n: Int): Int = {\n    var result = 1\n    for (i <- 2 to math.sqrt(n).toInt) {\n        if (n % i == 0) {\n            result += i\n            if (i != n / i) {\n                result += n / i\n            }\n        }\n    }\n    result\n}\n\ndef amicableNumbers(n: Int): Int = {\n    var result = 0\n    for (a <- 2 until n) {\n        val b = d(a)\n        if (a != b && a == d(b)) {\n            result += a\n        }\n    }\n    result\n}",
        "Euler022": "def namesScores(names: collection.Seq[String], queries: collection.Seq[String]): Int = {\n    val sNames = names.sorted.to(mutable.Buffer)\n    var result = 0\n    for ((name, i) <- sNames.zipWithIndex) {\n        var x = 0\n        for (c <- name) {\n            x += c.toInt - 64\n        }\n        if (queries.contains(name)) {\n            result += x * (i + 1)\n        }\n    }\n    result\n}",
        "Euler023": "def isAbundant(n: Int): Boolean = {\n    if (n < 12) {\n        return false\n    }\n    var sumDivisors = 1\n    for (i <- 2 to math.sqrt(n).toInt) {\n        if (n % i == 0) {\n            sumDivisors += i\n            if (i != n / i) {\n                sumDivisors += n / i\n            }\n        }\n    }\n    sumDivisors > n\n}\n\ndef nonAbundantSums(n: Int): Int = {\n    val abundants = mutable.Buffer[Int]()\n    for (i <- 12 until n) {\n        if (isAbundant(i)) {\n            abundants += i\n        }\n    }\n    val abundantSums = mutable.Buffer[Int]()\n    for (i <- abundants) {\n        for (j <- abundants) {\n            abundantSums += i + j\n        }\n    }\n    var result = 0\n    for (i <- 0 until n) {\n        if (!abundantSums.contains(i)) {\n            result += i\n        }\n    }\n    result\n}",
        "Euler024": "def lexicographicPermutations(n: Int): String = {\n    var result = \"\"\n    var digits = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n    var x = n - 1\n    for (i <- 10 to 1 by -1) {\n        var fact = 1\n        for (j <- 1 until i) {\n            fact *= j\n        }\n        var idx = x / fact\n        result += digits(idx)\n        digits = digits.patch(idx, Nil, 1)\n        x -= idx * fact\n    }\n    result\n}",
        "Euler025": "def nDigitFibonacciNumber(n: Int): Int = {\n    val a = mutable.Buffer(1)\n    val b = mutable.Buffer(1)\n    var i = 2\n    while (b.length < n) {\n        var carry = 0\n        val c = b.clone\n        for (j <- b.indices) {\n            if (j < a.length) {\n                b(j) = a(j) + b(j) + carry\n            } else {\n                b(j) = b(j) + carry\n            }\n            carry = b(j) / 10\n            b(j) = b(j) % 10\n        }\n        if (carry != 0) {\n            b += carry\n        }\n        a.clear\n        a ++= c\n        i = i + 1\n    }\n    i\n}",
        "Euler026": "def reciprocalCycles(n: Int): Int = {\n    var result = 0\n    var maxLength = 0\n    for (i <- 1 until n) {\n        val remainders = mutable.Buffer[Int]()\n        var remainder = 1\n        while (remainder != 0 && !remainders.contains(remainder)) {\n            remainders += remainder\n            remainder = (remainder * 10) % i\n        }\n        var length = 0\n        if (remainder != 0) {\n            length = remainders.length - remainders.indexOf(remainder)\n        }\n        if (length > maxLength) {\n            maxLength = length\n            result = i\n        }\n    }\n    result\n}",
        "Euler027": "def isPrime(n: Int): Boolean = {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    true\n}\n\ndef quadraticPrimes(n: Int): Int = {\n    var maxPrimes = 0\n    var result = 0\n    for (a <- -n + 1 until n by 2) {\n        for (b <- -n + 1 until n by 2) {\n            var x = 0\n            breakable {\n                while (x * x + a * x + b >= 2) {\n                    if (!isPrime(x * x + a * x + b)) {\n                        break\n                    }\n                    x += 1\n                }\n            }\n            if (x > maxPrimes) {\n                maxPrimes = x\n                result = a * b\n            }\n        }\n    }\n    result\n}",
        "Euler028": "def numberSpiralDiagonals(n: Int): Int = {\n    var result = 1\n    for (i <- 3 to n by 2) {\n        result += 4 * i * i - 6 * i + 6\n    }\n    result\n}",
        "Euler029": "def distinctPowers(n: Int): Int = {\n    var result = 0\n    val xs = mutable.Set[String]()\n    for (i <- 2 to n) {\n        val primes = List(2, 3, 5, 7)\n        val powers = mutable.Buffer(0, 0, 0, 0)\n        var num = i\n        for (j <- primes.indices) {\n            while (num % primes(j) == 0) {\n                num /= primes(j)\n                powers(j) += 1\n            }\n        }\n        if (num != 1) {\n            result += n - 1\n        } else {\n            for (j <- 2 to n) {\n                val pstr = s\"${powers(0) * j}-${powers(1) * j}-${powers(2) * j}-${powers(3) * j}\"\n                xs.add(pstr)\n            }\n        }\n    }\n    result += xs.size\n    result\n}",
        "Euler030": "def digitNthPowers(n: Int): Int = {\n    var result = 0\n    for (i <- 2 until 4 * math.pow(10, n).toInt) {\n        var digitsSum = 0\n        for (digit <- i.toString) {\n            digitsSum += math.pow(digit.asDigit, n).toInt\n        }\n        if (i == digitsSum) {\n            result += i\n        }\n    }\n    result\n}",
        "Euler031": "def coinSums(n: Int): Int = {\n    val coins = List(1, 2, 5, 10, 20, 50, 100, 200)\n    val ways = Array.fill(n + 1)(0)\n    ways(0) = 1\n    for (coin <- coins) {\n        for (i <- coin to n) {\n            ways(i) += ways(i - coin)\n        }\n    }\n    ways(n)\n}",
        "Euler032": "def pandigitalProducts(n: Int): Int = {\n    val products =  mutable.Set[Int]()\n    var s = \"\"\n    for (i <- 1 to n) {\n        s += i\n    }\n    for (a <- 1 until 100) {\n        for (b <- 1 until 10000) {\n            val c = a * b\n            var chars = (a.toString + b.toString + c.toString).toCharArray\n            chars = chars.sorted\n            if (chars.mkString == s) {\n                products.add(c)\n            }\n        }\n    }\n    var result = 0\n    for (product <- products) {\n        result += product\n    }\n    result\n}",
        "Euler033": "def digitCancelingFractions(m: Int): Int = {\n    var numer = 1\n    var denom = 1\n    for (d <- 10 until m) {\n        for (n <- 10 until d) {\n            val n0 = n % 10\n            val n1 = n / 10\n            val d0 = d % 10\n            val d1 = d / 10\n            if ((n1 == d0 && n0 * d == n * d1) || (n0 == d1 && n1 * d == n * d0)) {\n                numer *= n\n                denom *= d\n            }\n        }\n    }\n    var a = numer\n    var b = denom\n    while (b != 0) {\n        val temp = b\n        b = a % b\n        a = temp\n    }\n    denom / a\n}",
        "Euler034": "def digitFactorials(n: Int): Int = {\n    var result = 0\n    for (i <- 3 until n) {\n        var factSum = 0\n        for (digit <- i.toString) {\n            var fact = 1\n            for (j <- 1 to digit.asDigit) {\n                fact *= j\n            }\n            factSum += fact\n        }\n        if (i == factSum) {\n            result += i\n        }\n    }\n    result\n}",
        "Euler035": "def isPrime(n: Int): Boolean = {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    true\n}\n\ndef circularPrimes(n: Int): Int = {\n    var count = 0\n    for (i <- 2 until n) {\n        if (isPrime(i)) {\n            val rotations =  mutable.Set[Int]()\n            val si = i.toString\n            for (j <- 0 until si.length) {\n                rotations.add((si.substring(j) + si.substring(0, j)).toInt)\n            }\n            var flag = true\n            breakable {\n                for (x <- rotations) {\n                    if (!isPrime(x)) {\n                        flag = false\n                        break\n                    }\n                }\n            }\n            if (flag) {\n                count += 1\n            }\n        }\n    }\n    count\n}",
        "Euler036": "def isPalindrome(s: String): Boolean = {\n    for (i <- 0 until s.length / 2) {\n        if (s(i) != s(s.length - i - 1)) {\n            return false\n        }\n    }\n    true\n}\n\ndef doubleBasePalindromes(n: Int): Int = {\n    var result = 0\n    for (i <- 1 until n) {\n        val strI = i.toString\n        val binI = i.toBinaryString\n        if (isPalindrome(strI) && isPalindrome(binI)) {\n            result += i\n        }\n    }\n    result\n}",
        "Euler037": "def isPrime(n: Int): Boolean = {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    true\n}\n\ndef truncatablePrimes(n: Int): Int = {\n    var result = 0\n    for (i <- 10 until n) {\n        if (isPrime(i)) {\n            val si = i.toString\n            var flag = true\n            breakable {\n                for (j <- 1 until si.length) {\n                    val p1 = si.substring(j).toInt\n                    val p2 = si.substring(0, si.length - j).toInt\n                    if (!isPrime(p1) || !isPrime(p2)) {\n                        flag = false\n                        break\n                    }\n                }\n            }\n            if (flag) {\n                result += i\n            }\n        }\n    }\n    result\n}",
        "Euler038": "def pandigitalMultiples(n: Int): Int = {\n    var result = -1\n    for (i <- 2 to n) {\n        var cprod = \"\"\n        breakable {\n            for (j <- 1 until 10) {\n                cprod += (i * j).toString\n                if (cprod.length == 9) {\n                    val chars = cprod.split(\"\").sorted\n                    if (chars.mkString == \"123456789\") {\n                        result = result.max(cprod.toInt)\n                        break\n                    }\n                } else if (cprod.length > 9) {\n                    break\n                }\n            }\n        }\n    }\n    result\n}",
        "Euler039": "def integerRightTriangles(n: Int): Int = {\n    var maxSol = 0\n    var result = 0\n    for (p <- 3 to n) {\n        var sol = 0\n        for (a <- 1 until p / 2) {\n            for (b <- a until p / 2) {\n                val c = p - a - b\n                if (a * a + b * b == c * c) {\n                    sol += 1\n                }\n            }\n        }\n        if (sol > maxSol) {\n            maxSol = sol\n            result = p\n        }\n    }\n    result\n}",
        "Euler040": "def champernowneConstant(b: Int): Int = {\n    var s = \"\"\n    for (i <- 1 until math.pow(b, 6).toInt) {\n        s += i.toString\n    }\n    var result = 1\n    for (i <- 0 until 7) {\n        result *= s(math.pow(b, i).toInt - 1).asDigit\n    }\n    result\n}",
        "Euler041": "def isPrime(n: Int): Boolean = {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    true\n}\n\ndef pandigitalPrime(n: Int): Int = {\n    for (i <- n - 1 to 1 by -1) {\n        if (isPrime(i)) {\n            val si = i.toString\n            val length = si.length\n            var flag = true\n            breakable {\n                for (j <- 1 to length) {\n                    if (!si.contains(j.toString)) {\n                        flag = false\n                        break\n                    }\n                }\n                if (flag) {\n                    return i\n                }\n            }\n        }\n    }\n    -1\n}",
        "Euler042": "def codedTriangleNumbers(words: collection.Seq[String]): Int = {\n    var result = 0\n    for (word <- words) {\n        var value = 0\n        for (c <- word) {\n            value += c.toInt - 64\n        }\n        val n = math.sqrt(value * 2).toInt\n        if (n * (n + 1) == value * 2) {\n            result += 1\n        }\n    }\n    result\n}",
        "Euler043": "def genPermutations(s: String): collection.Seq[String] = {\n    if (s.length <= 1) {\n        return Seq(s)\n    }\n    val result = mutable.Buffer[String]()\n    for (perm <- genPermutations(s.substring(1))) {\n        for (i <- s.indices) {\n            result += perm.substring(0, i) + s(0) + perm.substring(i)\n        }\n    }\n    result\n}\n\ndef subStringDivisibility(n: Int): Int = {\n    var result = 0\n    val primes = Seq(2, 3, 5, 7, 11, 13, 17)\n    var s = \"\"\n    for (i <- 0 to n) {\n        s += i\n    }\n    for (i <- genPermutations(s)) {\n        var flag = true\n            breakable {\n            for (j <- 1 until n - 1) {\n                if (i.substring(j, j + 3).toInt % primes(j - 1) != 0) {\n                    flag = false\n                    break\n                }\n            }\n            if (flag) {\n                result += i.toInt\n            }\n        }\n    }\n    result\n}",
        "Euler044": "def pentagonNumbers(n: Int): Int = {\n    val pentagon = mutable.Set[Int]()\n    for (i <- 1 until n) {\n        pentagon.add(i * (3 * i - 1) / 2)\n    }\n    var result = -1\n    for (j <- pentagon) {\n        for (k <- pentagon) {\n            if (pentagon.contains(j + k) && pentagon.contains(k - j)) {\n                if (result == -1 || k - j < result) {\n                    result = k - j\n                }\n            }\n        }\n    }\n    result\n}",
        "Euler045": "def triangularPentagonalAndHexagonal(n: Int): Int = {\n    val ps =  mutable.Set[Int]()\n    var i = 1\n    var c = (0.5 * i * (3 * i - 1)).toInt\n    while (c < n) {\n        i += 1\n        ps.add(c)\n        c = (0.5 * i * (3 * i - 1)).toInt\n    }\n    i = 1\n    c = i * (2 * i - 1)\n    var result = -1\n    while (c < n) {\n        i += 1\n        if (ps.contains(c)) {\n            result = c\n        }\n        c = i * (2 * i - 1)\n    }\n    result\n}",
        "Euler046": "def isPrime(n: Int): Boolean = {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    true\n}\n\ndef goldbachsOtherConjecture(n: Int): Int = {\n    var result = -1\n    for (i <- 9999 until n by -2) {\n        val upper = math.sqrt(i / 2).toInt\n        var flag = false\n        breakable {\n            for (j <- 0 to upper) {\n                if (isPrime(i - 2 * j * j)) {\n                    flag = true\n                    break\n                }\n            }\n        }\n        if (!flag) {\n            result = i\n        }\n    }\n    result\n}",
        "Euler047": "def primeFactors(n: Int): Int = {\n    var num = n\n    val factors = mutable.Buffer[Int]()\n    var i = 2\n    while (i * i <= num) {\n        if (num % i != 0) {\n            i += 1\n        } else {\n            num /= i\n            factors += i\n        }\n    }\n    if (num > 1) {\n        factors += num\n    }\n    factors.toSet.size\n}\n\ndef distinctPrimesFactors(n: Int): Int = {\n    for (i <- n until 1000000) {\n        if (primeFactors(i) == 4 && primeFactors(i + 1) == 4 && primeFactors(i + 2) == 4 && primeFactors(i + 3) == 4) {\n            return i\n        }\n    }\n    -1\n}",
        "Euler048": "def selfPowers(n: Int): String = {\n    val digits = Array.fill(10)(0)\n    for (i <- 1 to n) {\n        val tempDigits = Array.fill(10)(0)\n        tempDigits(0) = 1\n        for (j <- 0 until i) {\n            var carry = 0\n            for (k <- 0 until 10) {\n                tempDigits(k) = tempDigits(k) * i + carry\n                carry = tempDigits(k) / 10\n                tempDigits(k) %= 10\n            }\n        }\n        for (j <- 0 until 10) {\n            digits(j) += tempDigits(j)\n            if (digits(j) >= 10) {\n                digits(j) -= 10\n                if (j < 9) {\n                    digits(j + 1) += 1\n                }\n            }\n        }\n    }\n    var result = \"\"\n    for (i <- 9 to 0 by -1) {\n        result += digits(i).toString\n    }\n    result\n}",
        "Euler049": "def isPrime(n: Int): Boolean = {\n    if (n < 2) {\n        return false\n    }\n    if (n == 2) {\n        return true\n    }\n    if (n % 2 == 0) {\n        return false\n    }\n    for (i <- 3 to math.sqrt(n).toInt by 2) {\n        if (n % i == 0) {\n            return false\n        }\n    }\n    true\n}\n\ndef genPermutations(s: String): collection.Seq[String] = {\n    if (s.length <= 1) {\n        return Seq(s)\n    }\n    val result = mutable.Buffer[String]()\n    for (perm <- genPermutations(s.substring(1))) {\n        for (i <- s.indices) {\n            result += perm.substring(0, i) + s(0) + perm.substring(i)\n        }\n    }\n    result\n}\n\ndef primePermutations(n: Int): String = {\n    for (i <- n to 999 by -1) {\n        if (isPrime(i)) {\n            val permutations = genPermutations(i.toString)\n            val candidates =  mutable.Set[Int]()\n            for (j <- permutations) {\n                val candidate = j.toInt\n                if (candidate > i && isPrime(candidate)) {\n                    candidates += candidate\n                }\n            }\n            for (m <- candidates) {\n                if (candidates.contains(m + (m - i))) {\n                    return i.toString + m.toString + (m + (m - i)).toString\n                }\n            }\n        }\n    }\n    \"\"\n}",
        "Euler050": "def consecutivePrimeSum(limit: Int): Int = {\n    val sieve = Array.fill(limit)(true)\n    val primes = mutable.Buffer[Int]()\n    for (i <- 2 until limit) {\n        if (sieve(i)) {\n            primes += i\n            for (j <- i * 2 until limit by i) {\n                sieve(j) = false\n            }\n        }\n    }\n    var maxLength = 0\n    var maxPrime = 0\n    for (i <- primes.indices) {\n        breakable {\n            for (j <- i + maxLength until primes.length) {\n                var s = 0\n                for (k <- i until j) {\n                    s += primes(k)\n                }\n                if (s >= limit) {\n                    break\n                }\n                if (sieve(s) && j - i > maxLength) {\n                    maxLength = j - i\n                    maxPrime = s\n                }\n            }\n        }\n    }\n    maxPrime\n}"
    }
}